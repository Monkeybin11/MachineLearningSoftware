<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emgu.TF.World</name>
    </assembly>
    <members>
        <member name="T:Emgu.TF.Buffer">
            <summary>
            Buffer holds a pointer to a block of data and its associated length.
            Typically, the data consists of a serialized protocol buffer, but other data
            may also be held in a buffer.
            </summary>
        </member>
        <member name="M:Emgu.TF.Buffer.#ctor">
            <summary>
            Create a new empty buffer
            </summary>
        </member>
        <member name="M:Emgu.TF.Buffer.FromString(System.Byte[])">
            <summary>
            Create a new Buffer from raw protobuf data
            </summary>
            <param name="rawProtoBuf">The raw protobuf data</param>
            <returns>A Tensorflow buffer</returns>
        </member>
        <member name="P:Emgu.TF.Buffer.Data">
            <summary>
            Get the pointer to the unmanaged data
            </summary>
        </member>
        <member name="P:Emgu.TF.Buffer.Length">
            <summary>
            The length of the Data in bytes
            </summary>
        </member>
        <member name="M:Emgu.TF.Buffer.GetMemoryStream">
            <summary>
            Get a copy of the data as a memory stream
            </summary>
            <returns>A copy of the data as a Memory stream</returns>
        </member>
        <member name="M:Emgu.TF.Buffer.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with this Buffer
            </summary>
        </member>
        <member name="T:Emgu.TF.TfInvoke">
            <summary>
            Entry points to the native Tensorflow library.
            </summary>
        </member>
        <member name="M:Emgu.TF.TfInvoke.GetNativeType(Emgu.TF.DataType)">
            <summary>
            Get the equivalent native type from Tensorflow DataType
            </summary>
            <param name="dataType">The tensorflow DataType</param>
            <returns>The equivalent native type</returns>
        </member>
        <member name="M:Emgu.TF.TfInvoke.CheckLibraryLoaded">
            <summary>
            Check to make sure all the unmanaged libraries are loaded
            </summary>
            <returns>True if library loaded</returns>
        </member>
        <member name="F:Emgu.TF.TfInvoke.TFCallingConvention">
            <summary>
            The Tensorflow native api calling convention
            </summary>
        </member>
        <member name="F:Emgu.TF.TfInvoke.StringMarshalType">
            <summary>
            The string marshal type
            </summary>
        </member>
        <member name="F:Emgu.TF.TfInvoke.BoolMarshalType">
            <summary>
            Represent a bool value in C++
            </summary>
        </member>
        <member name="F:Emgu.TF.TfInvoke.BoolToIntMarshalType">
            <summary>
            Represent a int value in C++
            </summary>
        </member>
        <member name="M:Emgu.TF.TfInvoke.LoadUnmanagedModules(System.String,System.String[])">
            <summary>
            Attempts to load tensorflow modules from the specific location
            </summary>
            <param name="loadDirectory">The directory where the unmanaged modules will be loaded. If it is null, the default location will be used.</param>
            <param name="unmanagedModules">The names of tensorflow modules. </param>
            <returns>True if all the modules has been loaded successfully</returns>
            <remarks>If <paramref name="loadDirectory"/> is null, the default location on windows is the dll's path appended by either "x64" or "x86", depends on the applications current mode.</remarks>
        </member>
        <member name="M:Emgu.TF.TfInvoke.GetModuleFormatString">
            <summary>
            Get the module format string.
            </summary>
            <returns>On Windows, "{0}".dll will be returned; On Linux, "lib{0}.so" will be returned; Otherwise {0} is returned.</returns>
        </member>
        <member name="M:Emgu.TF.TfInvoke.DefaultLoadUnmanagedModules(System.String[])">
            <summary>
            Attempts to load tensorflow modules from the specific location
            </summary>
            <param name="modules">The names of tensorflow modules.</param>
            <returns>True if all the modules has been loaded successfully</returns>
        </member>
        <member name="M:Emgu.TF.TfInvoke.#cctor">
            <summary>
            Static Constructor to setup tensorflow environment
            </summary>
        </member>
        <member name="P:Emgu.TF.TfInvoke.Version">
            <summary>
            Get the tensor flow version
            </summary>
        </member>
        <member name="M:Emgu.TF.TfInvoke.DataTypeSize(Emgu.TF.DataType)">
            <summary>
            Get the size of the datatype in bytes.
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.TF.TfInvoke.GetAllOpList">
            <summary>
            Get the proto buffer that contains the list of all the supported operations.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Emgu.TF.TfInvoke.IsGoogleCudaEnabled">
            <summary>
            Returns true if GOOGLE_CUDA is defined.
            </summary>
        </member>
        <member name="F:Emgu.TF.TfInvoke.ExternLibrary">
            <summary>
            The file name of the tfextern library
            </summary>
        </member>
        <member name="F:Emgu.TF.TfInvoke.TensorflowModuleList">
            <summary>
            The List of the opencv modules
            </summary>
        </member>
        <member name="T:Emgu.TF.Graph">
            <summary>
            Tensorflow Graph
            </summary>
        </member>
        <member name="M:Emgu.TF.Graph.#ctor">
            <summary>
            Create a new Graph
            </summary>
        </member>
        <member name="M:Emgu.TF.Graph.SetTensorShape(Emgu.TF.Output,System.Int32[],Emgu.TF.Status)">
            <summary>
            Sets the shape of the Tensor referenced by <paramref name="output"/> in graph to
            the shape described by <paramref name="dims"/>.
            </summary>
            <param name="output">The output</param>
            <param name="dims">The shape</param>
            <param name="status">The status</param>
        </member>
        <member name="M:Emgu.TF.Graph.GetTensorShape(Emgu.TF.Output,System.Int32,Emgu.TF.Status)">
            <summary>
            Returns the shape of the Tensor
            </summary>
            <param name="output">The output</param>
            <param name="numDim">The rank of the tensor</param>
            <param name="status">The status</param>
            <returns>The shape of the Tensor</returns>
        </member>
        <member name="M:Emgu.TF.Graph.DisposeObject">
            <summary>
            Release all the unmanaged memory associated with the graph
            </summary>
        </member>
        <member name="M:Emgu.TF.Graph.ImportGraphDef(Emgu.TF.Buffer,Emgu.TF.ImportGraphDefOptions,Emgu.TF.Status)">
            <summary>
            Import the graph serialized in <paramref name="graphDef"/> into the current graph.
            Convenience function for when no return outputs have been added.
            </summary>
            <param name="graphDef">The GraphDef to be imported</param>
            <param name="options">The import options</param>
            <param name="status">The status</param>
        </member>
        <member name="M:Emgu.TF.Graph.NewOperation(System.String,System.String)">
            <summary>
            Operation will only be added to graph when FinishOperation() is
            called (assuming FinishOperation() does not return an error).
            Graph must not be deleted until after FinishOperation() is
            called.
            </summary>
            <param name="opType">The operation type</param>
            <param name="opName">The name of the operation</param>
            <returns>A new operation description</returns>
        </member>
        <member name="M:Emgu.TF.Graph.OperationByName(System.String)">
            <summary>
            Returns the operation in the graph with the specific name. Returns null if
            no operation found.
            </summary>
            <param name="opName">The name of the operation</param>
            <returns>
            Returns the operation in the graph with the specific name. Returns null if
            no operation found.
            </returns>
        </member>
        <member name="P:Emgu.TF.Graph.Item(System.String)">
            <summary>
            Returns the operation in the graph with the specific name. Returns null if
            no operation found.
            </summary>
            <param name="name">The name of the operation</param>
            <returns>
            Returns the operation in the graph with the specific name. Returns null if
            no operation found.
            </returns>
        </member>
        <member name="M:Emgu.TF.Graph.NextOperation(System.IntPtr)">
            <summary>
            Iterate through the operations of a graph.
            </summary>
            <param name="pos">The position pointer that can be used to iterate though the operations of this graph. Use IntPtr.Zero to get the first operation</param>
            <returns>The next operation from the position</returns>
        </member>
        <member name="M:Emgu.TF.Graph.ToGraphDef(Emgu.TF.Buffer,Emgu.TF.Status)">
            <summary>
            Write out a serialized representation of `graph` (as a GraphDef protocol
            message).
            </summary>
            <param name="outputGraphDef">The buffer to store the GraphDef</param>
            <param name="status">The status</param>
        </member>
        <member name="M:Emgu.TF.Graph.StackPop(Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Deprecated, use StackPopV2.
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="elem_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] elem(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.GatherV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Gather slices from `params` axis `axis` according to `indices`.
            </summary>
            <param name="parameters">Input to the operation: The tensor from which to gather values. Must be at least rank `axis + 1`.</param>
            <param name="indices">Input to the operation: Index tensor. Must be in range `[0, params.shape[axis])`.</param>
            <param name="axis">Input to the operation: The axis in `params` to gather `indices` from. Defaults to the first dimension. Supports negative indexes.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Values from `params` gathered from indices given by `indices`, with shape `params.shape[:axis] + indices.shape + params.shape[axis + 1:]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ParallelConcat(Emgu.TF.Output,System.Int64[],System.String)">
            <summary>
            Concatenates a list of `N` tensors along the first dimension.
            </summary>
            <param name="values">Input to the operation: Tensors to be concatenated. All must have size 1 in the first dimension and same shape.</param>
            <param name="shape">the final shape of the result; should be equal to the shapes of any input but with the number of input values in the first dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The concatenated tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ConcatOffset(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes offsets of concat inputs within its output.
            </summary>
            <param name="concat_dim">Input to the operation: The dimension along which to concatenate.</param>
            <param name="shape">Input to the operation: The `N` int32 vectors representing shape of tensors being concatenated.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] offset(type: DtInt32): The `N` int32 vectors representing the starting offset of input tensors within the concatenated output.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Transpose(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Shuffle dimensions of x according to a permutation.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="perm">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Barrier(Emgu.TF.DataType[],System.Int64[][],System.Int64,System.String,System.String,System.String)">
            <summary>
            Defines a barrier that persists across different graph executions.
            </summary>
            <param name="component_types">The type of each component in a value.</param>
            <param name="shapes">The shape of each component in a value. Each shape must be 1 in the first dimension. The length of this attr must be the same as the length of component_types.</param>
            <param name="capacity">The capacity of the barrier.  The default capacity is MAX_INT32, which is the largest capacity of the underlying queue.</param>
            <param name="container">If non-empty, this barrier is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this barrier will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString): The handle to the barrier.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Pack(Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Packs a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor.
            </summary>
            <param name="values">Input to the operation: Must be of same shape and type.</param>
            <param name="axis">Dimension along which to pack.  Negative values wrap around, so the valid range is `[-(R+1), R+1)`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The packed tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IRFFT2D(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Inverse 2D real-valued fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A complex64 tensor.</param>
            <param name="fft_length">Input to the operation: An int32 tensor of shape [2]. The FFT length for each dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat): A float32 tensor of the same rank as `input`. The inner-most 2   dimensions of `input` are replaced with the `fft_length` samples of their   inverse 2D Fourier transform.  @compatibility(numpy) Equivalent to np.fft.irfft2 @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Lgamma(Emgu.TF.Output,System.String)">
            <summary>
            Computes the log of the absolute value of `Gamma(x)` element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LogUniformCandidateSampler(Emgu.TF.Output,System.Int64,System.Int64,System.Boolean,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Generates labels for candidate sampling with a log-uniform distribution.
            </summary>
            <param name="true_classes">Input to the operation: A batch_size * num_true matrix, in which each row contains the IDs of the num_true target_classes in the corresponding original label.</param>
            <param name="num_true">Number of true labels per context.</param>
            <param name="num_sampled">Number of candidates to randomly sample.</param>
            <param name="unique">If unique is true, we sample with rejection, so that all sampled candidates in a batch are unique. This requires some approximation to estimate the post-rejection sampling probabilities.</param>
            <param name="range_max">The sampler will sample integers from the interval [0, range_max).</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sampled_candidates(type: DtInt64): A vector of length num_sampled, in which each element is the ID of a sampled candidate.
            [1] true_expected_count(type: DtFloat): A batch_size * num_true matrix, representing the number of times each candidate is expected to occur in a batch of sampled candidates. If unique=true, then this is a probability.
            [2] sampled_expected_count(type: DtFloat): A vector of length num_sampled, for each sampled candidate representing the number of times the candidate is expected to occur in a batch of sampled candidates.  If unique=true, then this is a probability.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CTCBeamSearchDecoder(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Boolean,System.String)">
            <summary>
            Performs beam search decoding on the logits given in input.
            </summary>
            <param name="inputs">Input to the operation: 3-D, shape: `(max_time x batch_size x num_classes)`, the logits.</param>
            <param name="sequence_length">Input to the operation: A vector containing sequence lengths, size `(batch)`.</param>
            <param name="beam_width">A scalar &gt;= 0 (beam search beam width).</param>
            <param name="top_paths">A scalar &gt;= 0, &lt;= beam_width (controls output size).</param>
            <param name="merge_repeated">If true, merge repeated classes in output.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] decoded_indices(type: DtInt64): A list (length: top_paths) of indices matrices.  Matrix j, size `(total_decoded_outputs[j] x 2)`, has indices of a `SparseTensor&lt;int64, 2&gt;`.  The rows store: [batch, time].
            [1] decoded_values(type: DtInt64): A list (length: top_paths) of values vectors.  Vector j, size `(length total_decoded_outputs[j])`, has the values of a `SparseTensor&lt;int64, 2&gt;`.  The vector stores the decoded classes for beam j.
            [2] decoded_shape(type: DtInt64): A list (length: top_paths) of shape vector.  Vector j, size `(2)`, stores the shape of the decoded `SparseTensor[j]`. Its values are: `[batch_size, max_decoded_length[j]]`.
            [3] log_probability(type: DtFloat): A matrix, shaped: `(batch_size x top_paths)`.  The sequence log-probabilities.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderNumRecordsProducedV2(Emgu.TF.Output,System.String)">
            <summary>
            Returns the number of records this Reader has produced.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] records_produced(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Split(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Splits a tensor into `num_split` tensors along one dimension.
            </summary>
            <param name="split_dim">Input to the operation: 0-D.  The dimension along which to split.  Must be in the range `[-rank(value), rank(value))`.</param>
            <param name="value">Input to the operation: The tensor to split.</param>
            <param name="num_split">The number of ways to split.  Must evenly divide `value.shape[split_dim]`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): They are identically shaped tensors, whose shape matches that of `value` except along `split_dim`, where their sizes are `values.shape[split_dim] / num_split`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.OrderedMapUnstageNoKey(Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op removes and returns the (key, value) element with the smallest
            </summary>
            <param name="indices">Input to the operation. </param>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] key(type: DtInt64).
            [1] values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Unpack(Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors.
            </summary>
            <param name="value">Input to the operation: 1-D or higher, with `axis` dimension size equal to `num`.</param>
            <param name="num"></param>
            <param name="axis">Dimension along which to unpack.  Negative values wrap around, so the valid range is `[-R, R)`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The list of tensors unpacked from `value`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Concat(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Concatenates tensors along one dimension.
            </summary>
            <param name="concat_dim">Input to the operation: 0-D.  The dimension along which to concatenate.  Must be in the range [0, rank(values)).</param>
            <param name="values">Input to the operation: The `N` Tensors to concatenate. Their ranks and types must match, and their sizes must match in all dimensions except `concat_dim`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A `Tensor` with the concatenation of values stacked along the `concat_dim` dimension.  This tensor's shape matches that of `values` except in `concat_dim` where it has the sum of the sizes.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ConcatV2(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Concatenates tensors along one dimension.
            </summary>
            <param name="values">Input to the operation: List of `N` Tensors to concatenate. Their ranks and types must match, and their sizes must match in all dimensions except `concat_dim`.</param>
            <param name="axis">Input to the operation: 0-D.  The dimension along which to concatenate.  Must be in the range [-rank(values), rank(values)).</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A `Tensor` with the concatenation of values stacked along the `concat_dim` dimension.  This tensor's shape matches that of `values` except in `concat_dim` where it has the sum of the sizes.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TFRecordReader(System.String,System.String,System.String,System.String)">
            <summary>
            A Reader that outputs the records from a TensorFlow Records file.
            </summary>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="compression_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtString): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArraySplit(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="value">Input to the operation. </param>
            <param name="lengths">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatrixDeterminant(Emgu.TF.Output,System.String)">
            <summary>
            Computes the determinant of one ore more square matrices.
            </summary>
            <param name="input">Input to the operation: Shape is `[..., M, M]`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Shape is `[...]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchSelfAdjointEigV2(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="compute_v"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] e(type: DtInvalid).
            [1] v(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MaxPool(Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Performs max pooling on the input.
            </summary>
            <param name="input">Input to the operation: 4-D input to pool over.</param>
            <param name="ksize">The size of the window for each dimension of the input tensor.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, in_height, in_width, in_channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, in_channels, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The max pooled output tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SplitV(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Splits a tensor into `num_split` tensors along one dimension.
            </summary>
            <param name="value">Input to the operation: The tensor to split.</param>
            <param name="size_splits">Input to the operation: list containing the sizes of each output tensor along the split dimension. Must sum to the dimension of value along split_dim. Can contain one -1 indicating that dimension is to be inferred.</param>
            <param name="split_dim">Input to the operation: 0-D.  The dimension along which to split.  Must be in the range `[-rank(value), rank(value))`.</param>
            <param name="num_split"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Tensors whose shape matches that of `value` except along `split_dim`, where their sizes are `size_splits[i]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResizeNearestNeighborGrad(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the gradient of nearest neighbor interpolation.
            </summary>
            <param name="grads">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="size">Input to the operation: = A 1-D int32 Tensor of 2 elements: `orig_height, orig_width`. The original input size.</param>
            <param name="align_corners">If true, rescale grads by (orig_height - 1) / (height - 1), which exactly aligns the 4 corners of grads and original_image. If false, rescale by orig_height / height. Treat similarly the width dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D with shape `[batch, orig_height, orig_width, channels]`. Gradients with respect to the input image.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Const(Emgu.TF.Tensor,Emgu.TF.DataType,System.String)">
            <summary>
            Returns a constant tensor.
            </summary>
            <param name="value">Attr `value` is the tensor to return.</param>
            <param name="dtype"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Placeholder(Emgu.TF.DataType,System.Int64[],System.String)">
            <summary>
            A placeholder op for a value that will be fed into the computation.
            </summary>
            <param name="dtype">The type of elements in the tensor.</param>
            <param name="shape">(Optional) The shape of the tensor. If the shape has 0 dimensions, the shape is unconstrained.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A placeholder tensor that must be replaced using the feed mechanism.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ImmutableConst(Emgu.TF.DataType,System.Int64[],System.String,System.String)">
            <summary>
            Returns immutable tensor from memory region.
            </summary>
            <param name="dtype">Type of the returned tensor.</param>
            <param name="shape">Shape of the returned tensor.</param>
            <param name="memory_region_name">Name of readonly memory region used by the tensor, see NewReadOnlyMemoryRegionFromFile in tensorflow::Env.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] tensor(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceGather(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Boolean,System.String)">
            <summary>
            Gather slices from the variable pointed to by `resource` according to `indices`.
            </summary>
            <param name="resource">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="validate_indices"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatrixDiag(Emgu.TF.Output,System.String)">
            <summary>
            Returns a batched diagonal tensor with a given batched diagonal values.
            </summary>
            <param name="diagonal">Input to the operation: Rank `k`, where `k &gt;= 1`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Rank `k+1`, with `output.shape = diagonal.shape + [diagonal.shape[-1]]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResizeNearestNeighbor(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Resize `images` to `size` using nearest neighbor interpolation.
            </summary>
            <param name="images">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="size">Input to the operation: = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The new size for the images.</param>
            <param name="align_corners">If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] resized_images(type: DtInvalid): 4-D with shape `[batch, new_height, new_width, channels]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ZerosLike(Emgu.TF.Output,System.String)">
            <summary>
            Returns a tensor of zeros with the same shape and type as x.
            </summary>
            <param name="x">Input to the operation: a tensor of type T.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid): a tensor of the same shape and type as x but filled with zeros.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.OnesLike(Emgu.TF.Output,System.String)">
            <summary>
            Returns a tensor of ones with the same shape and type as x.
            </summary>
            <param name="x">Input to the operation: a tensor of type T.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid): a tensor of the same shape and type as x but filled with ones.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StridedSlice(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Return a strided slice from `input`.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="begin">Input to the operation: `begin[k]` specifies the offset into the `k`th range specification. The exact dimension this corresponds to will be determined by context. Out-of-bounds values will be silently clamped. If the `k`th bit of `begin_mask` then `begin[k]` is ignored and the full range of the appropriate dimension is used instead. Negative values causes indexing to start from the highest element e.g. If `foo==[1,2,3]` then `foo[-1]==3`.</param>
            <param name="end">Input to the operation: `end[i]` is like `begin` with the exception that `end_mask` is used to determine full ranges.</param>
            <param name="strides">Input to the operation: `strides[i]` specifies the increment in the `i`th specification after extracting a given element. Negative indices will reverse the original order. Out or range values are clamped to `[0,dim[i]) if slice[i]&gt;0` or `[-1,dim[i]-1] if slice[i] &lt; 0`</param>
            <param name="begin_mask">a bitmask where a bit i being 1 means to ignore the begin value and instead use the largest interval possible. At runtime begin[i] will be replaced with `[0, n-1) if `stride[i] &gt; 0` or `[-1, n-1]` if `stride[i] &lt; 0`</param>
            <param name="end_mask">analogous to `begin_mask`</param>
            <param name="ellipsis_mask">a bitmask where bit `i` being 1 means the `i`th position is actually an ellipsis. One bit at most can be 1. If `ellipsis_mask == 0`, then an implicit ellipsis mask of `1 &lt;&lt; (m+1)` is provided. This means that `foo[3:5] == foo[3:5, ...]`. An ellipsis implicitly creates as many range specifications as necessary to fully specify the sliced range for every dimension. For example for a 4-dimensional tensor `foo` the slice `foo[2, ..., 5:8]` implies `foo[2, :, :, 5:8]`.</param>
            <param name="new_axis_mask">a bitmask where bit `i` being 1 means the `i`th specification creates a new shape 1 dimension. For example `foo[:4, tf.newaxis, :2]` would produce a shape `(4, 1, 2)` tensor.</param>
            <param name="shrink_axis_mask">a bitmask where bit `i` implies that the `i`th specification should shrink the dimensionality. begin and end must imply a slice of size 1 in the dimension. For example in python one might do `foo[:, 3, :]` which would result in `shrink_axis_mask` being 2.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderReadV2(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the next record (key, value pair) produced by a Reader.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="queue_handle">Input to the operation: Handle to a Queue, with string work items.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] key(type: DtString): A scalar.
            [1] value(type: DtString): A scalar.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AvgPool3DGrad(Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes gradients of average pooling function.
            </summary>
            <param name="orig_input_shape">Input to the operation: The original input dimensions.</param>
            <param name="grad">Input to the operation: Output backprop of shape `[batch, depth, rows, cols, channels]`.</param>
            <param name="ksize">1-D tensor of length 5. The size of the window for each dimension of the input tensor. Must have `ksize[0] = ksize[4] = 1`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">The data format of the input and output data. With the default format "NDHWC", the data is stored in the order of:     [batch, in_depth, in_height, in_width, in_channels]. Alternatively, the format could be "NCDHW", the data storage order is:     [batch, in_channels, in_depth, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The backprop for input.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TakeDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that contains `count` elements from the `input_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="count">Input to the operation: A scalar representing the number of elements from the `input_dataset` that should be taken. A value of `-1` indicates that all of `input_dataset` is taken.</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.UniqueWithCounts(Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Finds unique elements in a 1-D tensor.
            </summary>
            <param name="x">Input to the operation: 1-D.</param>
            <param name="out_idx"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid): 1-D.
            [1] idx(type: DtInvalid): 1-D.
            [2] count(type: DtInvalid): 1-D.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.EditDistance(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the (possibly normalized) Levenshtein Edit Distance.
            </summary>
            <param name="hypothesis_indices">Input to the operation: The indices of the hypothesis list SparseTensor. This is an N x R int64 matrix.</param>
            <param name="hypothesis_values">Input to the operation: The values of the hypothesis list SparseTensor. This is an N-length vector.</param>
            <param name="hypothesis_shape">Input to the operation: The shape of the hypothesis list SparseTensor. This is an R-length vector.</param>
            <param name="truth_indices">Input to the operation: The indices of the truth list SparseTensor. This is an M x R int64 matrix.</param>
            <param name="truth_values">Input to the operation: The values of the truth list SparseTensor. This is an M-length vector.</param>
            <param name="truth_shape">Input to the operation: truth indices, vector.</param>
            <param name="normalize">boolean (if true, edit distances are normalized by length of truth).  The output is:</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat): A dense float tensor with rank R - 1.  For the example input:      // hypothesis represents a 2x1 matrix with variable-length values:     //   (0,0) = ["a"]     //   (1,0) = ["b"]     hypothesis_indices = [[0, 0, 0],                           [1, 0, 0]]     hypothesis_values = ["a", "b"]     hypothesis_shape = [2, 1, 1]      // truth represents a 2x2 matrix with variable-length values:     //   (0,0) = []     //   (0,1) = ["a"]     //   (1,0) = ["b", "c"]     //   (1,1) = ["a"]     truth_indices = [[0, 1, 0],                      [1, 0, 0],                      [1, 0, 1],                      [1, 1, 0]]     truth_values = ["a", "b", "c", "a"]     truth_shape = [2, 2, 2]     normalize = true  The output will be:      // output is a 2x2 matrix with edit distances normalized by truth lengths.     output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis               [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Rint(Emgu.TF.Output,System.String)">
            <summary>
            Returns element-wise integer closest to x.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Diag(Emgu.TF.Output,System.String)">
            <summary>
            Returns a diagonal tensor with a given diagonal values.
            </summary>
            <param name="diagonal">Input to the operation: Rank k tensor where k is at most 3.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatrixInverse(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="adjoint"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AddN(Emgu.TF.Output,System.String)">
            <summary>
            Add all input tensors element wise.
            </summary>
            <param name="inputs">Input to the operation: Must all be the same size and shape.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sum(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Rank(Emgu.TF.Output,System.String)">
            <summary>
            Returns the rank of a tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInt32).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DiagPart(Emgu.TF.Output,System.String)">
            <summary>
            Returns the diagonal part of the tensor.
            </summary>
            <param name="input">Input to the operation: Rank k tensor where k is 2, 4, or 6.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] diagonal(type: DtInvalid): The extracted diagonal.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseCross(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Int64,System.Int64,Emgu.TF.DataType,Emgu.TF.DataType,System.String)">
            <summary>
            Generates sparse cross from a list of sparse and dense tensors.
            </summary>
            <param name="indices">Input to the operation: 2-D.  Indices of each input `SparseTensor`.</param>
            <param name="values">Input to the operation: 1-D.   values of each `SparseTensor`.</param>
            <param name="shapes">Input to the operation: 1-D.   Shapes of each `SparseTensor`.</param>
            <param name="dense_inputs">Input to the operation: 2-D.    Columns represented by dense `Tensor`.</param>
            <param name="hashed_output">If true, returns the hash of the cross instead of the string. This will allow us avoiding string manipulations.</param>
            <param name="num_buckets">It is used if hashed_output is true. output = hashed_value%num_buckets if num_buckets &gt; 0 else hashed_value.</param>
            <param name="hash_key">Specify the hash_key that will be used by the `FingerprintCat64` function to combine the crosses fingerprints.</param>
            <param name="out_type"></param>
            <param name="internal_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64): 2-D.  Indices of the concatenated `SparseTensor`.
            [1] output_values(type: DtInvalid): 1-D.  Non-empty values of the concatenated or hashed `SparseTensor`.
            [2] output_shape(type: DtInt64): 1-D.  Shape of the concatenated `SparseTensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StackPush(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Deprecated, use StackPushV2.
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="elem">Input to the operation. </param>
            <param name="swap_memory"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatrixSetDiag(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns a batched matrix tensor with new batched diagonal values.
            </summary>
            <param name="input">Input to the operation: Rank `k+1`, where `k &gt;= 1`.</param>
            <param name="diagonal">Input to the operation: Rank `k`, where `k &gt;= 1`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Rank `k+1`, with `output.shape = input.shape`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.OrderedMapStage(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Stage (key, values) in the underlying container which behaves like a ordered
            </summary>
            <param name="key">Input to the operation: int64</param>
            <param name="indices">Input to the operation. </param>
            <param name="values">Input to the operation: a list of tensors dtypes A list of data types that inserted values should adhere to.</param>
            <param name="dtypes"></param>
            <param name="capacity">Maximum number of elements in the Staging Area. If &gt; 0, inserts on the container will block when the capacity is reached.</param>
            <param name="memory_limit"></param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">It is necessary to match this name to the matching Unstage Op.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.MatrixDiagPart(Emgu.TF.Output,System.String)">
            <summary>
            Returns the batched diagonal part of a batched tensor.
            </summary>
            <param name="input">Input to the operation: Rank `k` tensor where `k &gt;= 2`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] diagonal(type: DtInvalid): The extracted diagonal(s) having shape `diagonal.shape = input.shape[:-2] + [min(input.shape[-2:])]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SpaceToBatchND(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            SpaceToBatch for N-D tensors of type T.
            </summary>
            <param name="input">Input to the operation: N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`, where spatial_shape has `M` dimensions.</param>
            <param name="block_shape">Input to the operation: 1-D with shape `[M]`, all values must be &gt;= 1.</param>
            <param name="paddings">Input to the operation: 2-D with shape `[M, 2]`, all values must be &gt;= 0.   `paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension   `i + 1`, which corresponds to spatial dimension `i`.  It is required that   `block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.  This operation is equivalent to the following steps:  1. Zero-pad the start and end of dimensions `[1, ..., M]` of the    input according to `paddings` to produce `padded` of shape `padded_shape`.  2. Reshape `padded` to `reshaped_padded` of shape:       [batch] +      [padded_shape[1] / block_shape[0],        block_shape[0],       ...,       padded_shape[M] / block_shape[M-1],       block_shape[M-1]] +      remaining_shape  3. Permute dimensions of `reshaped_padded` to produce    `permuted_reshaped_padded` of shape:       block_shape +      [batch] +      [padded_shape[1] / block_shape[0],       ...,       padded_shape[M] / block_shape[M-1]] +      remaining_shape  4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch    dimension, producing an output tensor of shape:       [batch * prod(block_shape)] +      [padded_shape[1] / block_shape[0],       ...,       padded_shape[M] / block_shape[M-1]] +      remaining_shape  Some examples:  (1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and     `paddings = [[0, 0], [0, 0]]`:  ``` x = [[[[1], [2]], [[3], [4]]]] ```  The output tensor has shape `[4, 1, 1, 1]` and value:  ``` [[[[1]]], [[[2]]], [[[3]]], [[[4]]]] ```  (2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and     `paddings = [[0, 0], [0, 0]]`:  ``` x = [[[[1, 2, 3], [4, 5, 6]],       [[7, 8, 9], [10, 11, 12]]]] ```  The output tensor has shape `[4, 1, 1, 3]` and value:  ``` [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]] ```  (3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and     `paddings = [[0, 0], [0, 0]]`:  ``` x = [[[[1],   [2],  [3],  [4]],       [[5],   [6],  [7],  [8]],       [[9],  [10], [11],  [12]],       [[13], [14], [15],  [16]]]] ```  The output tensor has shape `[4, 2, 2, 1]` and value:  ``` x = [[[[1], [3]], [[9], [11]]],      [[[2], [4]], [[10], [12]]],      [[[5], [7]], [[13], [15]]],      [[[6], [8]], [[14], [16]]]] ```  (4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and     paddings = `[[0, 0], [2, 0]]`:  ``` x = [[[[1],   [2],  [3],  [4]],       [[5],   [6],  [7],  [8]]],      [[[9],  [10], [11],  [12]],       [[13], [14], [15],  [16]]]] ```  The output tensor has shape `[8, 1, 3, 1]` and value:  ``` x = [[[[0], [1], [3]]], [[[0], [9], [11]]],      [[[0], [2], [4]]], [[[0], [10], [12]]],      [[[0], [5], [7]]], [[[0], [13], [15]]],      [[[0], [6], [8]]], [[[0], [14], [16]]]] ```  Among others, this operation is useful for reducing atrous convolution into regular convolution.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AccumulatorSetGlobalStep(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Updates the accumulator with a new value for global_step.
            </summary>
            <param name="handle">Input to the operation: The handle to an accumulator.</param>
            <param name="new_global_step">Input to the operation: The new global_step value to set.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.MergeV2Checkpoints(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            V2 format specific: merges the metadata files of sharded checkpoints.  The
            </summary>
            <param name="checkpoint_prefixes">Input to the operation: prefixes of V2 checkpoints to merge.</param>
            <param name="destination_prefix">Input to the operation: scalar.  The desired final prefix.  Allowed to be the same as one of the checkpoint_prefixes.</param>
            <param name="delete_old_dirs">see above.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ImageSummary(Emgu.TF.Output,Emgu.TF.Output,System.Int64,Emgu.TF.Tensor,System.String)">
            <summary>
            Outputs a `Summary` protocol buffer with images.
            </summary>
            <param name="tag">Input to the operation: Scalar. Used to build the `tag` attribute of the summary values.</param>
            <param name="tensor">Input to the operation: 4-D of shape `[batch_size, height, width, channels]` where `channels` is 1, 3, or 4.</param>
            <param name="max_images">Max number of batch elements to generate images for.</param>
            <param name="bad_color">Color to use for pixels with non-finite values.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] summary(type: DtString): Scalar. Serialized `Summary` protocol buffer.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatrixSolveLs(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Solves one or more linear least-squares problems.
            </summary>
            <param name="matrix">Input to the operation: Shape is `[..., M, N]`.</param>
            <param name="rhs">Input to the operation: Shape is `[..., M, K]`.</param>
            <param name="l2_regularizer">Input to the operation: Scalar tensor.  @compatibility(numpy) Equivalent to np.linalg.lstsq @end_compatibility</param>
            <param name="fast"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Shape is `[..., N, K]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedResizeBilinear(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Resize quantized `images` to `size` using quantized bilinear interpolation.
            </summary>
            <param name="images">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="size">Input to the operation: = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The new size for the images.</param>
            <param name="min">Input to the operation. </param>
            <param name="max">Input to the operation. </param>
            <param name="align_corners">If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] resized_images(type: DtInvalid): 4-D with shape `[batch, new_height, new_width, channels]`.
            [1] out_min(type: DtFloat).
            [2] out_max(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatrixBandPart(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Copy a tensor setting everything outside a central band in each innermost matrix
            </summary>
            <param name="input">Input to the operation: Rank `k` tensor.</param>
            <param name="num_lower">Input to the operation: 0-D tensor. Number of subdiagonals to keep. If negative, keep entire lower triangle.</param>
            <param name="num_upper">Input to the operation: 0-D tensor. Number of superdiagonals to keep. If negative, keep entire upper triangle.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] band(type: DtInvalid): Rank `k` tensor of the same shape as input. The extracted banded tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Reshape(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Reshapes a tensor.
            </summary>
            <param name="tensor">Input to the operation. </param>
            <param name="shape">Input to the operation: Defines the shape of the output tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyProximalGradientDescent(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' as FOBOS algorithm with fixed learning rate.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="alpha">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="delta">Input to the operation: The change.</param>
            <param name="use_locking">If True, the subtraction will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.PreventGradient(Emgu.TF.Output,System.String,System.String)">
            <summary>
            An identity op that triggers an error if a gradient is requested.
            </summary>
            <param name="input">Input to the operation: any tensor.</param>
            <param name="message">Will be printed in the error when anyone tries to differentiate this operation.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): the same input tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ParseTensor(Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Transforms a serialized tensorflow.TensorProto proto into a Tensor.
            </summary>
            <param name="serialized">Input to the operation: A scalar string containing a serialized TensorProto proto.</param>
            <param name="out_type">The type of the serialized tensor.  The provided type must match the type of the serialized tensor and no implicit conversion will take place.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A Tensor of type `out_type`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StopGradient(Emgu.TF.Output,System.String)">
            <summary>
            Stops gradient computation.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Softplus(Emgu.TF.Output,System.String)">
            <summary>
            Computes softplus: `log(exp(features) + 1)`.
            </summary>
            <param name="features">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] activations(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RestoreSlice(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Int64,System.String)">
            <summary>
            Restores a tensor from checkpoint files.
            </summary>
            <param name="file_pattern">Input to the operation: Must have a single element. The pattern of the files from which we read the tensor.</param>
            <param name="tensor_name">Input to the operation: Must have a single element. The name of the tensor to be restored.</param>
            <param name="shape_and_slice">Input to the operation: Scalar. The shapes and slice specifications to use when restoring a tensors.</param>
            <param name="dt">The type of the tensor to be restored.</param>
            <param name="preferred_shard">Index of file to open first if multiple files match `file_pattern`. See the documentation for `Restore`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] tensor(type: DtInvalid): The restored tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Reverse(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Reverses specific dimensions of a tensor.
            </summary>
            <param name="tensor">Input to the operation: Up to 8-D.</param>
            <param name="dims">Input to the operation: 1-D. The dimensions to reverse.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The same shape as `tensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchIFFT3D(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchFFT(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReverseV2(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Reverses specific dimensions of a tensor.
            </summary>
            <param name="tensor">Input to the operation: Up to 8-D.</param>
            <param name="axis">Input to the operation: 1-D. The indices of the dimensions to reverse.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The same shape as `tensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Ceil(Emgu.TF.Output,System.String)">
            <summary>
            Returns element-wise smallest integer in not less than x.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReverseSequence(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Reverses variable length slices.
            </summary>
            <param name="input">Input to the operation: The input to reverse.</param>
            <param name="seq_lengths">Input to the operation: 1-D with length `input.dims(batch_dim)` and `max(seq_lengths) &lt;= input.dims(seq_dim)`</param>
            <param name="seq_dim">The dimension which is partially reversed.</param>
            <param name="batch_dim">The dimension along which reversal is performed.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The partially reversed input. It has the same shape as `input`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceScatterAdd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Adds sparse updates to the variable referenced by `resource`.
            </summary>
            <param name="resource">Input to the operation: Should be from a `Variable` node.</param>
            <param name="indices">Input to the operation: A tensor of indices into the first dimension of `ref`.</param>
            <param name="updates">Input to the operation: A tensor of updated values to add to `ref`.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.SparseDenseCwiseAdd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Adds up a SparseTensor and a dense Tensor, using these special rules:
            </summary>
            <param name="sp_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, possibly not in canonical ordering.</param>
            <param name="sp_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `sp_indices`.</param>
            <param name="sp_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="dense">Input to the operation: `R`-D.  The dense Tensor operand.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 1-D.  The `N` values that are operated on.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Div(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns x / y element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Fill(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Creates a tensor filled with a scalar value.
            </summary>
            <param name="dims">Input to the operation: 1-D. Represents the shape of the output tensor.</param>
            <param name="value">Input to the operation: 0-D (scalar). Value to fill the returned tensor.  @compatibility(numpy) Equivalent to np.full @end_compatibility</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Conv3D(Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes a 3-D convolution given 5-D `input` and `filter` tensors.
            </summary>
            <param name="input">Input to the operation: Shape `[batch, in_depth, in_height, in_width, in_channels]`.</param>
            <param name="filter">Input to the operation: Shape `[filter_depth, filter_height, filter_width, in_channels, out_channels]`. `in_channels` must match between `input` and `filter`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">The data format of the input and output data. With the default format "NDHWC", the data is stored in the order of:     [batch, in_depth, in_height, in_width, in_channels]. Alternatively, the format could be "NCDHW", the data storage order is:     [batch, in_channels, in_depth, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Identity(Emgu.TF.Output,System.String)">
            <summary>
            Return a tensor with the same shape and contents as the input tensor or value.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Tan(Emgu.TF.Output,System.String)">
            <summary>
            Computes tan of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Inv(Emgu.TF.Output,System.String)">
            <summary>
            Computes the reciprocal of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ShapeN(Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Returns shape of tensors.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="out_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Conv3DBackpropFilter(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.String)">
            <summary>
            Computes the gradients of 3-D convolution with respect to the filter.
            </summary>
            <param name="input">Input to the operation: Shape `[batch, depth, rows, cols, in_channels]`.</param>
            <param name="filter">Input to the operation: Shape `[depth, rows, cols, in_channels, out_channels]`. `in_channels` must match between `input` and `filter`.</param>
            <param name="out_backprop">Input to the operation: Backprop signal of shape `[batch, out_depth, out_rows, out_cols, out_channels]`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatrixDiagPart(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] diagonal(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Gather(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Gather slices from `params` according to `indices`.
            </summary>
            <param name="parameters">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="validate_indices"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FusedBatchNorm(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Single,System.String,System.Boolean,System.String)">
            <summary>
            Batch normalization.
            </summary>
            <param name="x">Input to the operation: A 4D Tensor for input data.</param>
            <param name="scale">Input to the operation: A 1D Tensor for scaling factor, to scale the normalized x.</param>
            <param name="offset">Input to the operation: A 1D Tensor for offset, to shift to the normalized x.</param>
            <param name="mean">Input to the operation: A 1D Tensor for population mean. Used for inference only; must be empty for training.</param>
            <param name="variance">Input to the operation: A 1D Tensor for population variance. Used for inference only; must be empty for training.</param>
            <param name="epsilon">A small float number added to the variance of x.</param>
            <param name="data_format">The data format for x and y. Either "NHWC" (default) or "NCHW".</param>
            <param name="is_training">A bool value to indicate the operation is for training (default) or inference.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid): A 4D Tensor for output data.
            [1] batch_mean(type: DtInvalid): A 1D Tensor for the computed batch mean, to be used by TensorFlow to compute the running mean.
            [2] batch_variance(type: DtInvalid): A 1D Tensor for the computed batch variance, to be used by TensorFlow to compute the running variance.
            [3] reserve_space_1(type: DtInvalid): A 1D Tensor for the computed batch mean, to be reused in the gradient computation.
            [4] reserve_space_2(type: DtInvalid): A 1D Tensor for the computed batch variance (inverted variance in the cuDNN case), to be used in the gradient computation.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableFindV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Looks up keys in a table, outputs the corresponding values.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="keys">Input to the operation: Any shape.  Keys to look up.</param>
            <param name="default_value">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid): Same shape as `keys`.  Values found in the table, or `default_values` for missing keys.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Where(Emgu.TF.Output,System.String)">
            <summary>
            Returns locations of true values in a boolean tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] index(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RefIdentity(Emgu.TF.Output,System.String)">
            <summary>
            Return the same ref tensor as the input ref tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.GatherNd(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Gather slices from `params` into a Tensor with shape specified by `indices`.
            </summary>
            <param name="parameters">Input to the operation: The tensor from which to gather values.</param>
            <param name="indices">Input to the operation: Index tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Values from `params` gathered from indices given by `indices`, with shape `indices.shape[:-1] + params.shape[indices.shape[-1]:]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArraySplitV3(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Split the data from the input value into TensorArray elements.
            </summary>
            <param name="handle">Input to the operation: The handle to a TensorArray.</param>
            <param name="value">Input to the operation: The concatenated tensor to write to the TensorArray.</param>
            <param name="lengths">Input to the operation: The vector of lengths, how to split the rows of value into the TensorArray.</param>
            <param name="flow_in">Input to the operation: A float scalar that enforces proper chaining of operations.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat): A float scalar that enforces proper chaining of operations.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ExpandDims(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Inserts a dimension of 1 into a tensor's shape.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="dim">Input to the operation: 0-D (scalar). Specifies the dimension index at which to expand the shape of `input`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Contains the same data as `input`, but its shape has an additional dimension of size 1 added.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DebugGradientIdentity(Emgu.TF.Output,System.String)">
            <summary>
            Identity op for gradient debugging.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedConv2D(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Computes a 2D convolution given quantized 4D input and filter tensors.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="filter">Input to the operation: filter's input_depth dimension must match input's depth dimensions.</param>
            <param name="min_input">Input to the operation: The float value that the lowest quantized input value represents.</param>
            <param name="max_input">Input to the operation: The float value that the highest quantized input value represents.</param>
            <param name="min_filter">Input to the operation: The float value that the lowest quantized filter value represents.</param>
            <param name="max_filter">Input to the operation: The float value that the highest quantized filter value represents.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="out_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            [1] min_output(type: DtFloat): The float value that the lowest quantized output value represents.
            [2] max_output(type: DtFloat): The float value that the highest quantized output value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Pad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Pads a tensor with zeros.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="paddings">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FloorMod(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns element-wise remainder of division. When `x &lt; 0` xor `y &lt; 0` is
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Sigmoid(Emgu.TF.Output,System.String)">
            <summary>
            Computes sigmoid of `x` element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CheckNumerics(Emgu.TF.Output,System.String,System.String)">
            <summary>
            Checks a tensor for NaN and Inf values.
            </summary>
            <param name="tensor">Input to the operation. </param>
            <param name="message">Prefix of the error message.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScalarSummary(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Outputs a `Summary` protocol buffer with scalar values.
            </summary>
            <param name="tags">Input to the operation: Tags for the summary.</param>
            <param name="values">Input to the operation: Same shape as `tags.  Values for the summary.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] summary(type: DtString): Scalar.  Serialized `Summary` protocol buffer.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ApproximateEqual(Emgu.TF.Output,Emgu.TF.Output,System.Single,System.String)">
            <summary>
            Returns the truth value of abs(x-y) &lt; tolerance element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="tolerance"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.PlaceholderWithDefault(Emgu.TF.Output,System.Int64[],System.String)">
            <summary>
            A placeholder op that passes through `input` when its output is not fed.
            </summary>
            <param name="input">Input to the operation: The default value to produce when `output` is not fed.</param>
            <param name="shape">The (possibly partial) shape of the tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A placeholder tensor that defaults to `input` if it is not fed.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AllCandidateSampler(Emgu.TF.Output,System.Int64,System.Int64,System.Boolean,System.Int64,System.Int64,System.String)">
            <summary>
            Generates labels for candidate sampling with a learned unigram distribution.
            </summary>
            <param name="true_classes">Input to the operation: A batch_size * num_true matrix, in which each row contains the IDs of the num_true target_classes in the corresponding original label.</param>
            <param name="num_true">Number of true labels per context.</param>
            <param name="num_sampled">Number of candidates to produce.</param>
            <param name="unique">If unique is true, we sample with rejection, so that all sampled candidates in a batch are unique. This requires some approximation to estimate the post-rejection sampling probabilities.</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sampled_candidates(type: DtInt64): A vector of length num_sampled, in which each element is the ID of a sampled candidate.
            [1] true_expected_count(type: DtFloat): A batch_size * num_true matrix, representing the number of times each candidate is expected to occur in a batch of sampled candidates. If unique=true, then this is a probability.
            [2] sampled_expected_count(type: DtFloat): A vector of length num_sampled, for each sampled candidate representing the number of times the candidate is expected to occur in a batch of sampled candidates.  If unique=true, then this is a probability.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Squeeze(Emgu.TF.Output,System.Int64[],System.String)">
            <summary>
            Removes dimensions of size 1 from the shape of a tensor.
            </summary>
            <param name="input">Input to the operation: The `input` to squeeze.</param>
            <param name="squeeze_dims">If specified, only squeezes the dimensions listed. The dimension index starts at 0. It is an error to squeeze a dimension that is not 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Contains the same data as `input`, but has one or more dimensions of size 1 removed.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.InvertPermutation(Emgu.TF.Output,System.String)">
            <summary>
            Computes the inverse permutation of a tensor.
            </summary>
            <param name="x">Input to the operation: 1-D.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid): 1-D.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceStridedSliceAssign(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Assign `value` to the sliced l-value reference of `ref`.
            </summary>
            <param name="reference">Input to the operation. </param>
            <param name="begin">Input to the operation. </param>
            <param name="end">Input to the operation. </param>
            <param name="strides">Input to the operation. </param>
            <param name="value">Input to the operation. </param>
            <param name="begin_mask"></param>
            <param name="end_mask"></param>
            <param name="ellipsis_mask"></param>
            <param name="new_axis_mask"></param>
            <param name="shrink_axis_mask"></param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Shape(Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Returns the shape of a tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="out_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Unique(Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Finds unique elements in a 1-D tensor.
            </summary>
            <param name="x">Input to the operation: 1-D.</param>
            <param name="out_idx"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid): 1-D.
            [1] idx(type: DtInvalid): 1-D.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Size(Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Returns the size of a tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="out_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Slice(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Return a slice from 'input'.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="begin">Input to the operation: begin[i] specifies the offset into the 'i'th dimension of 'input' to slice from.</param>
            <param name="size">Input to the operation: size[i] specifies the number of elements of the 'i'th dimension of 'input' to slice. If size[i] is -1, all remaining elements in dimension i are included in the slice (i.e. this is equivalent to setting size[i] = input.dim_size(i) - begin[i]).</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.NonMaxSuppressionV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Greedily selects a subset of bounding boxes in descending order of score,
            </summary>
            <param name="boxes">Input to the operation: A 2-D float tensor of shape `[num_boxes, 4]`.</param>
            <param name="scores">Input to the operation: A 1-D float tensor of shape `[num_boxes]` representing a single score corresponding to each box (each row of boxes).</param>
            <param name="max_output_size">Input to the operation: A scalar integer tensor representing the maximum number of boxes to be selected by non max suppression.</param>
            <param name="iou_threshold">Input to the operation: A 0-D float tensor representing the threshold for deciding whether boxes overlap too much with respect to IOU.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] selected_indices(type: DtInt32): A 1-D integer tensor of shape `[M]` representing the selected indices from the boxes tensor, where `M &lt;= max_output_size`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AvgPool3D(Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Performs 3D average pooling on the input.
            </summary>
            <param name="input">Input to the operation: Shape `[batch, depth, rows, cols, channels]` tensor to pool over.</param>
            <param name="ksize">1-D tensor of length 5. The size of the window for each dimension of the input tensor. Must have `ksize[0] = ksize[4] = 1`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">The data format of the input and output data. With the default format "NDHWC", the data is stored in the order of:     [batch, in_depth, in_height, in_width, in_channels]. Alternatively, the format could be "NCDHW", the data storage order is:     [batch, in_channels, in_depth, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The average pooled output tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StridedSliceGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Returns the gradient of `StridedSlice`.
            </summary>
            <param name="shape">Input to the operation. </param>
            <param name="begin">Input to the operation. </param>
            <param name="end">Input to the operation. </param>
            <param name="strides">Input to the operation. </param>
            <param name="dy">Input to the operation. </param>
            <param name="begin_mask"></param>
            <param name="end_mask"></param>
            <param name="ellipsis_mask"></param>
            <param name="new_axis_mask"></param>
            <param name="shrink_axis_mask"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayClose(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Min(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the minimum of elements across dimensions of a tensor.
            </summary>
            <param name="input">Input to the operation: The tensor to reduce.</param>
            <param name="reduction_indices">Input to the operation: The dimensions to reduce.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The reduced tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StridedSliceAssign(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Assign `value` to the sliced l-value reference of `ref`.
            </summary>
            <param name="reference">Input to the operation. </param>
            <param name="begin">Input to the operation. </param>
            <param name="end">Input to the operation. </param>
            <param name="strides">Input to the operation. </param>
            <param name="value">Input to the operation. </param>
            <param name="begin_mask"></param>
            <param name="end_mask"></param>
            <param name="ellipsis_mask"></param>
            <param name="new_axis_mask"></param>
            <param name="shrink_axis_mask"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Tile(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Constructs a tensor by tiling a given tensor.
            </summary>
            <param name="input">Input to the operation: 1-D or higher.</param>
            <param name="multiples">Input to the operation: 1-D. Length must be the same as the number of dimensions in `input`</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DecodeJSONExample(Emgu.TF.Output,System.String)">
            <summary>
            Convert JSON-encoded Example records to binary protocol buffer strings.
            </summary>
            <param name="json_examples">Input to the operation: Each string is a JSON object serialized according to the JSON mapping of the Example proto.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] binary_examples(type: DtString): Each string is a binary Example protocol buffer corresponding to the respective element of `json_examples`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderRestoreStateV2(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Restore a reader to a previously saved state.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="state">Input to the operation: Result of a ReaderSerializeState of a Reader with type matching reader_handle.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.AssignSubVariableOp(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Subtracts a value from the current value of a variable.
            </summary>
            <param name="resource">Input to the operation: handle to the resource in which to store the variable.</param>
            <param name="value">Input to the operation: the value by which the variable will be incremented.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.TileGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the gradient of `Tile`.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="multiples">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ComplexAbs(Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Computes the complex absolute value of a tensor.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="Tout"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BroadcastArgs(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Return the shape of s0 op s1 with broadcast.
            </summary>
            <param name="s0">Input to the operation. </param>
            <param name="s1">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] r0(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BroadcastGradientArgs(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Return the reduction indices for computing gradients of s0 op s1 with broadcast.
            </summary>
            <param name="s0">Input to the operation. </param>
            <param name="s1">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] r0(type: DtInvalid).
            [1] r1(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.PadV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Pads a tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="paddings">Input to the operation. </param>
            <param name="constant_values">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FixedLengthRecordReader(System.Int64,System.Int64,System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            A Reader that outputs fixed-length records from a file.
            </summary>
            <param name="record_bytes">Number of bytes in the record.</param>
            <param name="header_bytes">Number of bytes in the header, defaults to 0.</param>
            <param name="footer_bytes">Number of bytes in the footer, defaults to 0.</param>
            <param name="hop_bytes">Number of bytes to hop before each read. Default of 0 means using record_bytes.</param>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtString): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MirrorPad(Emgu.TF.Output,Emgu.TF.Output,System.String,System.String)">
            <summary>
            Pads a tensor with mirrored values.
            </summary>
            <param name="input">Input to the operation: The input tensor to be padded.</param>
            <param name="paddings">Input to the operation: A two-column matrix specifying the padding sizes. The number of rows must be the same as the rank of `input`.</param>
            <param name="mode">Either `REFLECT` or `SYMMETRIC`. In reflect mode the padded regions do not include the borders, while in symmetric mode the padded regions do include the borders. For example, if `input` is `[1, 2, 3]` and `paddings` is `[0, 2]`, then the output is `[1, 2, 3, 2, 1]` in reflect mode, and it is `[1, 2, 3, 3, 2]` in symmetric mode.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The padded tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MirrorPadGrad(Emgu.TF.Output,Emgu.TF.Output,System.String,System.String)">
            <summary>
            Gradient op for `MirrorPad` op. This op folds a mirror-padded tensor.
            </summary>
            <param name="input">Input to the operation: The input tensor to be folded.</param>
            <param name="paddings">Input to the operation: A two-column matrix specifying the padding sizes. The number of rows must be the same as the rank of `input`.</param>
            <param name="mode">The mode used in the `MirrorPad` op.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The folded tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchIFFT(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.PlaceholderV2(Emgu.TF.DataType,System.Int64[],System.String)">
            <summary>
            A placeholder op for a value that will be fed into the computation.
            </summary>
            <param name="dtype">The type of elements in the tensor.</param>
            <param name="shape">The shape of the tensor. The shape can be any partially-specified shape.  To be unconstrained, pass in a shape with unknown rank.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A placeholder tensor that must be replaced using the feed mechanism.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ListDiff(Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Computes the difference between two lists of numbers or strings.
            </summary>
            <param name="x">Input to the operation: 1-D. Values to keep.</param>
            <param name="y">Input to the operation: 1-D. Values to remove.</param>
            <param name="out_idx"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): 1-D. Values present in `x` but not in `y`.
            [1] idx(type: DtInvalid): 1-D. Positions of `x` values preserved in `out`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FIFOQueue(Emgu.TF.DataType[],System.Int64[][],System.Int64,System.String,System.String,System.String)">
            <summary>
            A queue that produces elements in first-in first-out order.
            </summary>
            <param name="component_types">The type of each component in a value.</param>
            <param name="shapes">The shape of each component in a value. The length of this attr must be either 0 or the same as the length of component_types. If the length of this attr is 0, the shapes of queue elements are not constrained, and only one element may be dequeued at a time.</param>
            <param name="capacity">The upper bound on the number of elements in this queue. Negative numbers mean no limit.</param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this queue will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString): The handle to the queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SpaceToBatch(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            SpaceToBatch for 4-D tensors of type T.
            </summary>
            <param name="input">Input to the operation: 4-D with shape `[batch, height, width, depth]`.</param>
            <param name="paddings">Input to the operation: 2-D tensor of non-negative integers with shape `[2, 2]`. It specifies   the padding of the input with zeros across the spatial dimensions as follows:        paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]    The effective spatial dimensions of the zero-padded input tensor will be:        height_pad = pad_top + height + pad_bottom       width_pad = pad_left + width + pad_right  The attr `block_size` must be greater than one. It indicates the block size.    * Non-overlapping blocks of size `block_size x block size` in the height and     width dimensions are rearranged into the batch dimension at each location.   * The batch of the output tensor is `batch * block_size * block_size`.   * Both height_pad and width_pad must be divisible by block_size.  The shape of the output will be:      [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,      depth]  Some examples:  (1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:  ``` x = [[[[1], [2]], [[3], [4]]]] ```  The output tensor has shape `[4, 1, 1, 1]` and value:  ``` [[[[1]]], [[[2]]], [[[3]]], [[[4]]]] ```  (2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:  ``` x = [[[[1, 2, 3], [4, 5, 6]],       [[7, 8, 9], [10, 11, 12]]]] ```  The output tensor has shape `[4, 1, 1, 3]` and value:  ``` [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]] ```  (3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:  ``` x = [[[[1],   [2],  [3],  [4]],       [[5],   [6],  [7],  [8]],       [[9],  [10], [11],  [12]],       [[13], [14], [15],  [16]]]] ```  The output tensor has shape `[4, 2, 2, 1]` and value:  ``` x = [[[[1], [3]], [[9], [11]]],      [[[2], [4]], [[10], [12]]],      [[[5], [7]], [[13], [15]]],      [[[6], [8]], [[14], [16]]]] ```  (4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:  ``` x = [[[[1],   [2],  [3],  [4]],       [[5],   [6],  [7],  [8]]],      [[[9],  [10], [11],  [12]],       [[13], [14], [15],  [16]]]] ```  The output tensor has shape `[8, 1, 2, 1]` and value:  ``` x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],      [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]] ```  Among others, this operation is useful for reducing atrous convolution into regular convolution.</param>
            <param name="block_size"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.PriorityQueueV2(System.Int64[][],Emgu.TF.DataType[],System.Int64,System.String,System.String,System.String)">
            <summary>
            A queue that produces elements sorted by the first component value.
            </summary>
            <param name="shapes">The shape of each component in a value. The length of this attr must be either 0 or the same as the length of component_types. If the length of this attr is 0, the shapes of queue elements are not constrained, and only one element may be dequeued at a time.</param>
            <param name="component_types">The type of each component in a value.</param>
            <param name="capacity">The upper bound on the number of elements in this queue. Negative numbers mean no limit.</param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this queue will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource): The handle to the queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.InterleaveDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that applies `f` to the outputs of `input_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="other_arguments">Input to the operation. </param>
            <param name="cycle_length">Input to the operation. </param>
            <param name="block_length">Input to the operation. </param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchToSpaceND(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            BatchToSpace for N-D tensors of type T.
            </summary>
            <param name="input">Input to the operation: N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`, where spatial_shape has M dimensions.</param>
            <param name="block_shape">Input to the operation: 1-D with shape `[M]`, all values must be &gt;= 1.</param>
            <param name="crops">Input to the operation: 2-D with shape `[M, 2]`, all values must be &gt;= 0.   `crops[i] = [crop_start, crop_end]` specifies the amount to crop from input   dimension `i + 1`, which corresponds to spatial dimension `i`.  It is   required that   `crop_start[i] + crop_end[i] &lt;= block_shape[i] * input_shape[i + 1]`.  This operation is equivalent to the following steps:  1. Reshape `input` to `reshaped` of shape:      [block_shape[0], ..., block_shape[M-1],       batch / prod(block_shape),       input_shape[1], ..., input_shape[N-1]]  2. Permute dimensions of `reshaped` to produce `permuted` of shape      [batch / prod(block_shape),        input_shape[1], block_shape[0],       ...,       input_shape[M], block_shape[M-1],        input_shape[M+1], ..., input_shape[N-1]]  3. Reshape `permuted` to produce `reshaped_permuted` of shape      [batch / prod(block_shape),        input_shape[1] * block_shape[0],       ...,       input_shape[M] * block_shape[M-1],        input_shape[M+1],       ...,       input_shape[N-1]]  4. Crop the start and end of dimensions `[1, ..., M]` of    `reshaped_permuted` according to `crops` to produce the output of shape:      [batch / prod(block_shape),        input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],       ...,       input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],        input_shape[M+1], ..., input_shape[N-1]]  Some examples:  (1) For the following input of shape `[4, 1, 1, 1]`, `block_shape = [2, 2]`, and     `crops = [[0, 0], [0, 0]]`:  ``` [[[[1]]], [[[2]]], [[[3]]], [[[4]]]] ```  The output tensor has shape `[1, 2, 2, 1]` and value:  ``` x = [[[[1], [2]], [[3], [4]]]] ```  (2) For the following input of shape `[4, 1, 1, 3]`, `block_shape = [2, 2]`, and     `crops = [[0, 0], [0, 0]]`:  ``` [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]] ```  The output tensor has shape `[1, 2, 2, 3]` and value:  ``` x = [[[[1, 2, 3], [4, 5, 6]],       [[7, 8, 9], [10, 11, 12]]]] ```  (3) For the following input of shape `[4, 2, 2, 1]`, `block_shape = [2, 2]`, and     `crops = [[0, 0], [0, 0]]`:  ``` x = [[[[1], [3]], [[9], [11]]],      [[[2], [4]], [[10], [12]]],      [[[5], [7]], [[13], [15]]],      [[[6], [8]], [[14], [16]]]] ```  The output tensor has shape `[1, 4, 4, 1]` and value:  ``` x = [[[1],   [2],  [3],  [4]],      [[5],   [6],  [7],  [8]],      [[9],  [10], [11],  [12]],      [[13], [14], [15],  [16]]] ```  (4) For the following input of shape `[8, 1, 3, 1]`, `block_shape = [2, 2]`, and     `crops = [[0, 0], [2, 0]]`:  ``` x = [[[[0], [1], [3]]], [[[0], [9], [11]]],      [[[0], [2], [4]]], [[[0], [10], [12]]],      [[[0], [5], [7]]], [[[0], [13], [15]]],      [[[0], [6], [8]]], [[[0], [14], [16]]]] ```  The output tensor has shape `[2, 2, 4, 1]` and value:  ``` x = [[[[1],   [2],  [3],  [4]],       [[5],   [6],  [7],  [8]]],      [[[9],  [10], [11],  [12]],       [[13], [14], [15],  [16]]]] ```</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyAdam(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the Adam algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="m">Input to the operation: Should be from a Variable().</param>
            <param name="v">Input to the operation: Should be from a Variable().</param>
            <param name="beta1_power">Input to the operation: Must be a scalar.</param>
            <param name="beta2_power">Input to the operation: Must be a scalar.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="beta1">Input to the operation: Momentum factor. Must be a scalar.</param>
            <param name="beta2">Input to the operation: Momentum factor. Must be a scalar.</param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If `True`, updating of the var, m, and v tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="use_nesterov">If `True`, uses the nesterov update.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.BatchToSpace(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            BatchToSpace for 4-D tensors of type T.
            </summary>
            <param name="input">Input to the operation: 4-D tensor with shape `[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,   depth]`. Note that the batch size of the input tensor must be divisible by `block_size * block_size`.</param>
            <param name="crops">Input to the operation: 2-D tensor of non-negative integers with shape `[2, 2]`. It specifies how many elements to crop from the intermediate result across the spatial dimensions as follows:      crops = [[crop_top, crop_bottom], [crop_left, crop_right]]</param>
            <param name="block_size"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D with shape `[batch, height, width, depth]`, where:        height = height_pad - crop_top - crop_bottom       width = width_pad - crop_left - crop_right  The attr `block_size` must be greater than one. It indicates the block size.  Some examples:  (1) For the following input of shape `[4, 1, 1, 1]` and block_size of 2:  ``` [[[[1]]], [[[2]]], [[[3]]], [[[4]]]] ```  The output tensor has shape `[1, 2, 2, 1]` and value:  ``` x = [[[[1], [2]], [[3], [4]]]] ```  (2) For the following input of shape `[4, 1, 1, 3]` and block_size of 2:  ``` [[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]] ```  The output tensor has shape `[1, 2, 2, 3]` and value:  ``` x = [[[[1, 2, 3], [4, 5, 6]],       [[7, 8, 9], [10, 11, 12]]]] ```  (3) For the following input of shape `[4, 2, 2, 1]` and block_size of 2:  ``` x = [[[[1], [3]], [[9], [11]]],      [[[2], [4]], [[10], [12]]],      [[[5], [7]], [[13], [15]]],      [[[6], [8]], [[14], [16]]]] ```  The output tensor has shape `[1, 4, 4, 1]` and value:  ``` x = [[[1],   [2],  [3],  [4]],      [[5],   [6],  [7],  [8]],      [[9],  [10], [11],  [12]],      [[13], [14], [15],  [16]]] ```  (4) For the following input of shape `[8, 1, 2, 1]` and block_size of 2:  ``` x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],      [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]] ```  The output tensor has shape `[2, 2, 4, 1]` and value:  ``` x = [[[[1], [3]], [[5], [7]]],      [[[2], [4]], [[10], [12]]],      [[[5], [7]], [[13], [15]]],      [[[6], [8]], [[14], [16]]]] ```
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayWriteV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Deprecated. Use TensorArrayGradV3
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="index">Input to the operation. </param>
            <param name="value">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SpaceToDepth(Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            SpaceToDepth for tensors of type T.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="block_size">The size of the spatial block.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResizeBilinear(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Resize `images` to `size` using bilinear interpolation.
            </summary>
            <param name="images">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="size">Input to the operation: = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The new size for the images.</param>
            <param name="align_corners">If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] resized_images(type: DtFloat): 4-D with shape `[batch, new_height, new_width, channels]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DepthToSpace(Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            DepthToSpace for tensors of type T.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="block_size">The size of the spatial block, same as in Space2Depth.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseReduceMax(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the max of elements across dimensions of a SparseTensor.
            </summary>
            <param name="input_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, possibly not in canonical ordering.</param>
            <param name="input_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `input_indices`.</param>
            <param name="input_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="reduction_axes">Input to the operation: 1-D.  Length-`K` vector containing the reduction axes.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): `R-K`-D.  The reduced Tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ExtractImagePatches(Emgu.TF.Output,System.Int64[],System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
            Extract `patches` from `images` and put them in the "depth" output dimension.
            </summary>
            <param name="images">Input to the operation: 4-D Tensor with shape `[batch, in_rows, in_cols, depth]`.</param>
            <param name="ksizes">The size of the sliding window for each dimension of `images`.</param>
            <param name="strides">1-D of length 4. How far the centers of two consecutive patches are in the images. Must be: `[1, stride_rows, stride_cols, 1]`.</param>
            <param name="rates">1-D of length 4. Must be: `[1, rate_rows, rate_cols, 1]`. This is the input stride, specifying how far two consecutive patch samples are in the input. Equivalent to extracting patches with `patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)`, followed by subsampling them spatially by a factor of `rates`. This is equivalent to `rate` in dilated (a.k.a. Atrous) convolutions.</param>
            <param name="padding">The type of padding algorithm to use.  We specify the size-related attributes as:  ```python       ksizes = [1, ksize_rows, ksize_cols, 1]       strides = [1, strides_rows, strides_cols, 1]       rates = [1, rates_rows, rates_cols, 1] ```</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] patches(type: DtInvalid): 4-D Tensor with shape `[batch, out_rows, out_cols, ksize_rows * ksize_cols * depth]` containing image patches with size `ksize_rows x ksize_cols x depth` vectorized in the "depth" dimension. Note `out_rows` and `out_cols` are the dimensions of the output patches.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StringToHashBucket(Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Converts each string in the input Tensor to its hash mod by a number of buckets.
            </summary>
            <param name="string_tensor">Input to the operation. </param>
            <param name="num_buckets">The number of buckets.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInt64): A Tensor of the same shape as the input `string_tensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Sinh(Emgu.TF.Output,System.String)">
            <summary>
            Computes hyperbolic sine of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Bitcast(Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Bitcasts a tensor from one type to another without copying data.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.OrderedMapPeek(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op peeks at the values at the specified key.  If the
            </summary>
            <param name="key">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RandomUniform(Emgu.TF.Output,Emgu.TF.DataType,System.Int64,System.Int64,System.String)">
            <summary>
            Outputs random values from a uniform distribution.
            </summary>
            <param name="shape">Input to the operation: The shape of the output tensor.</param>
            <param name="dtype">The type of the output.</param>
            <param name="seed">If either `seed` or `seed2` are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A tensor of the specified shape filled with uniform random values.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FractionalMaxPool(Emgu.TF.Output,System.Single[],System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Int64,System.String)">
            <summary>
            Performs fractional max pooling on the input.
            </summary>
            <param name="value">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="pooling_ratio">Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be &gt;= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions respectively.</param>
            <param name="pseudo_random">When set to True, generates the pooling sequence in a pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for difference between pseudorandom and random.</param>
            <param name="overlapping">When set to True, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:  `index  0  1  2  3  4`  `value  20 5  16 3  7`  If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [20, 16] for fractional max pooling.</param>
            <param name="deterministic">When set to True, a fixed pooling region will be used when iterating over a FractionalMaxPool node in the computation graph. Mainly used in unit test to make FractionalMaxPool deterministic.</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): output tensor after fractional max pooling.
            [1] row_pooling_sequence(type: DtInt64): row pooling sequence, needed to calculate gradient.
            [2] col_pooling_sequence(type: DtInt64): column pooling sequence, needed to calculate gradient.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.OneHot(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Returns a one-hot tensor.
            </summary>
            <param name="indices">Input to the operation: A tensor of indices.</param>
            <param name="depth">Input to the operation: A scalar defining the depth of the one hot dimension.</param>
            <param name="on_value">Input to the operation: A scalar defining the value to fill in output when `indices[j] = i`.</param>
            <param name="off_value">Input to the operation: A scalar defining the value to fill in output when `indices[j] != i`.</param>
            <param name="axis">The axis to fill (default: -1, a new inner-most axis).</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The one-hot tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReluGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes rectified linear gradients for a Relu operation.
            </summary>
            <param name="gradients">Input to the operation: The backpropagated gradients to the corresponding Relu operation.</param>
            <param name="features">Input to the operation: The features passed as input to the corresponding Relu operation, OR the outputs of that operation (both work equivalently).</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] backprops(type: DtInvalid): `gradients * (features &gt; 0)`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizeAndDequantize(Emgu.TF.Output,System.Boolean,System.Int64,System.Boolean,System.Single,System.Single,System.String)">
            <summary>
            Use QuantizeAndDequantizeV2 instead.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="signed_input"></param>
            <param name="num_bits"></param>
            <param name="range_given"></param>
            <param name="input_min"></param>
            <param name="input_max"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizeAndDequantizeV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Int64,System.Boolean,System.String)">
            <summary>
            Quantizes then dequantizes a tensor.
            </summary>
            <param name="input">Input to the operation: Tensor to quantize and then dequantize.</param>
            <param name="input_min">Input to the operation: If range_given, this is the min of the range, otherwise this input will be ignored.</param>
            <param name="input_max">Input to the operation: If range_given, this is the max of the range, otherwise this input will be ignored.</param>
            <param name="signed_input">If the quantization is signed or unsigned.</param>
            <param name="num_bits">The bitwidth of the quantization.</param>
            <param name="range_given">If the range is given or should be computed from the tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizeAndDequantizeV3(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Quantizes then dequantizes a tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="input_min">Input to the operation. </param>
            <param name="input_max">Input to the operation. </param>
            <param name="num_bits">Input to the operation. </param>
            <param name="signed_input"></param>
            <param name="range_given"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizeV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String,System.String)">
            <summary>
            Quantize the 'input' tensor of type float to 'output' tensor of type 'T'.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="min_range">Input to the operation: The minimum scalar value possibly produced for the input.</param>
            <param name="max_range">Input to the operation: The maximum scalar value possibly produced for the input.</param>
            <param name="T"></param>
            <param name="mode"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The quantized data produced from the float input.
            [1] output_min(type: DtFloat): The actual minimum scalar value used for the output.
            [2] output_max(type: DtFloat): The actual maximum scalar value used for the output.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RandomPoisson(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Outputs random values from the Poisson distribution(s) described by rate.
            </summary>
            <param name="shape">Input to the operation: 1-D integer tensor. Shape of independent samples to draw from each distribution described by the shape parameters given in rate.</param>
            <param name="rate">Input to the operation: A tensor in which each scalar is a "rate" parameter describing the associated poisson distribution.</param>
            <param name="seed">If either `seed` or `seed2` are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A tensor with shape `shape + shape(rate)`. Each slice `[:, ..., :, i0, i1, ...iN]` contains the samples drawn for `rate[i0, i1, ...iN]`. The dtype of the output matches the dtype of rate.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.InitializeTable(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Table initializer that takes two tensors for keys and values respectively.
            </summary>
            <param name="table_handle">Input to the operation: Handle to a table which will be initialized.</param>
            <param name="keys">Input to the operation: Keys of type Tkey.</param>
            <param name="values">Input to the operation: Values of type Tval.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.DenseToDenseSetOperation(Emgu.TF.Output,Emgu.TF.Output,System.String,System.Boolean,System.String)">
            <summary>
            Applies set operation along last dimension of 2 `Tensor` inputs.
            </summary>
            <param name="set1">Input to the operation: `Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`. Dimension `n` contains values in a set, duplicates are allowed but ignored.</param>
            <param name="set2">Input to the operation: `Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set1`. Dimension `n` contains values in a set, duplicates are allowed but ignored.</param>
            <param name="set_operation"></param>
            <param name="validate_indices"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] result_indices(type: DtInt64): 2D indices of a `SparseTensor`.
            [1] result_values(type: DtInvalid): 1D values of a `SparseTensor`.
            [2] result_shape(type: DtInt64): 1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is the same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]` is the max result set size across all `0...n-1` dimensions.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BitwiseOr(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Elementwise computes the bitwise OR of `x` and `y`.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Dequantize(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.String)">
            <summary>
            Dequantize the 'input' tensor into a float Tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="min_range">Input to the operation: The minimum scalar value possibly produced for the input.</param>
            <param name="max_range">Input to the operation: The maximum scalar value possibly produced for the input.</param>
            <param name="mode"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayGrad(Emgu.TF.Output,Emgu.TF.Output,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="source"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] grad_handle(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedConcat(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Concatenates quantized tensors along one dimension.
            </summary>
            <param name="concat_dim">Input to the operation: 0-D.  The dimension along which to concatenate.  Must be in the range [0, rank(values)).</param>
            <param name="values">Input to the operation: The `N` Tensors to concatenate. Their ranks and types must match, and their sizes must match in all dimensions except `concat_dim`.</param>
            <param name="input_mins">Input to the operation: The minimum scalar values for each of the input tensors.</param>
            <param name="input_maxes">Input to the operation: The maximum scalar values for each of the input tensors.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A `Tensor` with the concatenation of values stacked along the `concat_dim` dimension.  This tensor's shape matches that of `values` except in `concat_dim` where it has the sum of the sizes.
            [1] output_min(type: DtFloat): The float value that the minimum quantized output value represents.
            [2] output_max(type: DtFloat): The float value that the maximum quantized output value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedReshape(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Reshapes a quantized tensor as per the Reshape op.
            </summary>
            <param name="tensor">Input to the operation. </param>
            <param name="shape">Input to the operation: Defines the shape of the output tensor.</param>
            <param name="input_min">Input to the operation: The minimum value of the input.</param>
            <param name="input_max">Input to the operation: The maximum value of the input.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            [1] output_min(type: DtFloat): This value is copied from input_min.
            [2] output_max(type: DtFloat): This value is copied from input_max.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArraySizeV3(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Get the current size of the TensorArray.
            </summary>
            <param name="handle">Input to the operation: The handle to a TensorArray (output of TensorArray or TensorArrayGrad).</param>
            <param name="flow_in">Input to the operation: A float scalar that enforces proper chaining of operations.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32): The current size of the TensorArray.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedInstanceNorm(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Single,System.Single,System.Single,System.Single,System.String)">
            <summary>
            Quantized Instance normalization.
            </summary>
            <param name="x">Input to the operation: A 4D input Tensor.</param>
            <param name="x_min">Input to the operation: The value represented by the lowest quantized input.</param>
            <param name="x_max">Input to the operation: The value represented by the highest quantized input.</param>
            <param name="output_range_given">If True, `given_y_min` and `given_y_min` and `given_y_max` are used as the output range. Otherwise, the implementation computes the output range.</param>
            <param name="given_y_min">Output in `y_min` if `output_range_given` is True.</param>
            <param name="given_y_max">Output in `y_max` if `output_range_given` is True.</param>
            <param name="variance_epsilon">A small float number to avoid dividing by 0.</param>
            <param name="min_separation">Minimum value of `y_max - y_min`</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid): A 4D Tensor.
            [1] y_min(type: DtFloat): The value represented by the lowest quantized output.
            [2] y_max(type: DtFloat): The value represented by the highest quantized output.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterNd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Scatter `updates` into a new (initially zero) tensor according to `indices`.
            </summary>
            <param name="indices">Input to the operation: Index tensor.</param>
            <param name="updates">Input to the operation: Updates to scatter into output.</param>
            <param name="shape">Input to the operation: 1-D. The shape of the resulting tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A new tensor with the given shape and updates applied according to the indices.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Relu6Grad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes rectified linear 6 gradients for a Relu6 operation.
            </summary>
            <param name="gradients">Input to the operation: The backpropagated gradients to the corresponding Relu6 operation.</param>
            <param name="features">Input to the operation: The features passed as input to the corresponding Relu6 operation.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] backprops(type: DtInvalid): The gradients: `gradients * (features &gt; 0) * (features &lt; 6)`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TextLineReaderV2(System.Int64,System.String,System.String,System.String)">
            <summary>
            A Reader that outputs the lines of a file delimited by '\n'.
            </summary>
            <param name="skip_header_lines">Number of lines to skip from the beginning of every file.</param>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtResource): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterNdNonAliasingAdd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Applies sparse addition to `input` using individual values or slices
            </summary>
            <param name="input">Input to the operation: A Tensor.</param>
            <param name="indices">Input to the operation: A Tensor. Must be one of the following types: `int32`, `int64`. A tensor of indices into `input`.</param>
            <param name="updates">Input to the operation: A Tensor. Must have the same type as ref. A tensor of updated values to add to `input`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A `Tensor` with the same shape as `input`, containing values of `input` updated with `updates`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueDequeueManyV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.String)">
            <summary>
            Dequeues `n` tuples of one or more tensors from the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="n">Input to the operation: The number of tuples to dequeue.</param>
            <param name="component_types">The type of each component in a tuple.</param>
            <param name="timeout_ms">If the queue has fewer than n elements, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] components(type: DtInvalid): One or more tensors that were dequeued as a tuple.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.All(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the "logical and" of elements across dimensions of a tensor.
            </summary>
            <param name="input">Input to the operation: The tensor to reduce.</param>
            <param name="reduction_indices">Input to the operation: The dimensions to reduce.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtBool): The reduced tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedBatchNormWithGlobalNormalization(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Single,System.Boolean,System.String)">
            <summary>
            Quantized Batch normalization.
            </summary>
            <param name="t">Input to the operation: A 4D input Tensor.</param>
            <param name="t_min">Input to the operation: The value represented by the lowest quantized input.</param>
            <param name="t_max">Input to the operation: The value represented by the highest quantized input.</param>
            <param name="m">Input to the operation: A 1D mean Tensor with size matching the last dimension of t. This is the first output from tf.nn.moments, or a saved moving average thereof.</param>
            <param name="m_min">Input to the operation: The value represented by the lowest quantized mean.</param>
            <param name="m_max">Input to the operation: The value represented by the highest quantized mean.</param>
            <param name="v">Input to the operation: A 1D variance Tensor with size matching the last dimension of t. This is the second output from tf.nn.moments, or a saved moving average thereof.</param>
            <param name="v_min">Input to the operation: The value represented by the lowest quantized variance.</param>
            <param name="v_max">Input to the operation: The value represented by the highest quantized variance.</param>
            <param name="beta">Input to the operation: A 1D beta Tensor with size matching the last dimension of t. An offset to be added to the normalized tensor.</param>
            <param name="beta_min">Input to the operation: The value represented by the lowest quantized offset.</param>
            <param name="beta_max">Input to the operation: The value represented by the highest quantized offset.</param>
            <param name="gamma">Input to the operation: A 1D gamma Tensor with size matching the last dimension of t. If "scale_after_normalization" is true, this tensor will be multiplied with the normalized tensor.</param>
            <param name="gamma_min">Input to the operation: The value represented by the lowest quantized gamma.</param>
            <param name="gamma_max">Input to the operation: The value represented by the highest quantized gamma.</param>
            <param name="out_type"></param>
            <param name="variance_epsilon">A small float number to avoid dividing by 0.</param>
            <param name="scale_after_normalization">A bool indicating whether the resulted tensor needs to be multiplied with gamma.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] result(type: DtInvalid).
            [1] result_min(type: DtFloat).
            [2] result_max(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FakeQuantWithMinMaxArgs(Emgu.TF.Output,System.Single,System.Single,System.Int64,System.Boolean,System.String)">
            <summary>
            Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same type.
            </summary>
            <param name="inputs">Input to the operation. </param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="num_bits"></param>
            <param name="narrow_range"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] outputs(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SampleDistortedBoundingBox(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Single,System.Single[],System.Single[],System.Int64,System.Boolean,System.String)">
            <summary>
            Generate a single randomly distorted bounding box for an image.
            </summary>
            <param name="image_size">Input to the operation: 1-D, containing `[height, width, channels]`.</param>
            <param name="bounding_boxes">Input to the operation: 3-D with shape `[batch, N, 4]` describing the N bounding boxes associated with the image.</param>
            <param name="seed">If either `seed` or `seed2` are set to non-zero, the random number generator is seeded by the given `seed`.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="min_object_covered">The cropped area of the image must contain at least this fraction of any bounding box supplied. The value of this parameter should be non-negative. In the case of 0, the cropped area does not need to overlap any of the bounding boxes supplied.</param>
            <param name="aspect_ratio_range">The cropped area of the image must have an aspect ratio = width / height within this range.</param>
            <param name="area_range">The cropped area of the image must contain a fraction of the supplied image within in this range.</param>
            <param name="max_attempts">Number of attempts at generating a cropped region of the image of the specified constraints. After `max_attempts` failures, return the entire image.</param>
            <param name="use_image_if_no_bounding_boxes">Controls behavior if no bounding boxes supplied. If true, assume an implicit bounding box covering the whole input. If false, raise an error.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] begin(type: DtInvalid): 1-D, containing `[offset_height, offset_width, 0]`. Provide as input to `tf.slice`.
            [1] size(type: DtInvalid): 1-D, containing `[target_height, target_width, -1]`. Provide as input to `tf.slice`.
            [2] bboxes(type: DtFloat): 3-D with shape `[1, 1, 4]` containing the distorted bounding box. Provide as input to `tf.image.draw_bounding_boxes`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FakeQuantWithMinMaxArgsGradient(Emgu.TF.Output,Emgu.TF.Output,System.Single,System.Single,System.Int64,System.Boolean,System.String)">
            <summary>
            Compute gradients for a FakeQuantWithMinMaxArgs operation.
            </summary>
            <param name="gradients">Input to the operation: Backpropagated gradients above the FakeQuantWithMinMaxArgs operation.</param>
            <param name="inputs">Input to the operation: Values passed as inputs to the FakeQuantWithMinMaxArgs operation.</param>
            <param name="min"></param>
            <param name="max"></param>
            <param name="num_bits"></param>
            <param name="narrow_range"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] backprops(type: DtFloat): Backpropagated gradients below the FakeQuantWithMinMaxArgs operation: `gradients * (inputs &gt;= min &amp;&amp; inputs &lt;= max)`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableExportV2(Emgu.TF.Output,Emgu.TF.DataType,Emgu.TF.DataType,System.String)">
            <summary>
            Outputs all keys and values in the table.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="Tkeys"></param>
            <param name="Tvalues"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] keys(type: DtInvalid): Vector of all keys present in the table.
            [1] values(type: DtInvalid): Tensor of all values in the table. Indexed in parallel with `keys`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Rsqrt(Emgu.TF.Output,System.String)">
            <summary>
            Computes reciprocal of square root of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FakeQuantWithMinMaxVars(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Boolean,System.String)">
            <summary>
            Fake-quantize the 'inputs' tensor of type float via global float scalars `min`
            </summary>
            <param name="inputs">Input to the operation. </param>
            <param name="min">Input to the operation. </param>
            <param name="max">Input to the operation. </param>
            <param name="num_bits"></param>
            <param name="narrow_range"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] outputs(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FakeQuantWithMinMaxVarsGradient(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Boolean,System.String)">
            <summary>
            Compute gradients for a FakeQuantWithMinMaxVars operation.
            </summary>
            <param name="gradients">Input to the operation: Backpropagated gradients above the FakeQuantWithMinMaxVars operation.</param>
            <param name="inputs">Input to the operation: Values passed as inputs to the FakeQuantWithMinMaxVars operation. min, max: Quantization interval, scalar floats.</param>
            <param name="min">Input to the operation. </param>
            <param name="max">Input to the operation. </param>
            <param name="num_bits">The bitwidth of the quantization; between 2 and 8, inclusive.</param>
            <param name="narrow_range">Whether to quantize into 2^num_bits - 1 distinct values.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] backprops_wrt_input(type: DtFloat): Backpropagated gradients w.r.t. inputs: `gradients * (inputs &gt;= min &amp;&amp; inputs &lt;= max)`.
            [1] backprop_wrt_min(type: DtFloat): Backpropagated gradients w.r.t. min parameter: `sum(gradients * (inputs &lt; min))`.
            [2] backprop_wrt_max(type: DtFloat): Backpropagated gradients w.r.t. max parameter: `sum(gradients * (inputs &gt; max))`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchCholesky(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FakeQuantWithMinMaxVarsPerChannel(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Boolean,System.String)">
            <summary>
            Fake-quantize the 'inputs' tensor of type float and one of the shapes: `[d]`,
            </summary>
            <param name="inputs">Input to the operation. </param>
            <param name="min">Input to the operation. </param>
            <param name="max">Input to the operation. </param>
            <param name="num_bits"></param>
            <param name="narrow_range"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] outputs(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyAdagrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.FakeQuantWithMinMaxVarsPerChannelGradient(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Boolean,System.String)">
            <summary>
            Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.
            </summary>
            <param name="gradients">Input to the operation: Backpropagated gradients above the FakeQuantWithMinMaxVars operation, shape one of: `[d]`, `[b, d]`,  `[b, h, w, d]`.</param>
            <param name="inputs">Input to the operation: Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape   same as `gradients`. min, max: Quantization interval, floats of shape `[d]`.</param>
            <param name="min">Input to the operation. </param>
            <param name="max">Input to the operation. </param>
            <param name="num_bits">The bitwidth of the quantization; between 2 and 8, inclusive.</param>
            <param name="narrow_range">Whether to quantize into 2^num_bits - 1 distinct values.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] backprops_wrt_input(type: DtFloat): Backpropagated gradients w.r.t. inputs, shape same as `inputs`:   `gradients * (inputs &gt;= min &amp;&amp; inputs &lt;= max)`.
            [1] backprop_wrt_min(type: DtFloat): Backpropagated gradients w.r.t. min parameter, shape `[d]`: `sum_per_d(gradients * (inputs &lt; min))`.
            [2] backprop_wrt_max(type: DtFloat): Backpropagated gradients w.r.t. max parameter, shape `[d]`: `sum_per_d(gradients * (inputs &gt; max))`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatrixDiag(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="diagonal">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayConcat(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Int64[],System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="element_shape_except0"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid).
            [1] lengths(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatrixSetDiag(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="diagonal">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatrixBandPart(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="num_lower">Input to the operation. </param>
            <param name="num_upper">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] band(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IteratorGetNext(Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Gets the next output from the given iterator.
            </summary>
            <param name="iterator">Input to the operation. </param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] components(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DecodeWav(Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Decode a 16-bit PCM WAV file to a float tensor.
            </summary>
            <param name="contents">Input to the operation: The WAV-encoded audio, usually from a file.</param>
            <param name="desired_channels">Number of sample channels wanted.</param>
            <param name="desired_samples">Length of audio requested.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] audio(type: DtFloat): 2-D with shape `[length, channels]`.
            [1] sample_rate(type: DtInt32): Scalar holding the sample rate found in the WAV header.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseToDense(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Converts a sparse representation into a dense tensor.
            </summary>
            <param name="sparse_indices">Input to the operation: 0-D, 1-D, or 2-D.  `sparse_indices[i]` contains the complete index where `sparse_values[i]` will be placed.</param>
            <param name="output_shape">Input to the operation: 1-D.  Shape of the dense output tensor.</param>
            <param name="sparse_values">Input to the operation: 1-D.  Values corresponding to each row of `sparse_indices`, or a scalar value to be used for all sparse indices.</param>
            <param name="default_value">Input to the operation: Scalar value to set for indices not specified in `sparse_indices`.</param>
            <param name="validate_indices">If true, indices are checked to make sure they are sorted in lexicographic order and that there are no repeats.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] dense(type: DtInvalid): Dense output tensor of shape `output_shape`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.EncodeWav(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Encode audio data using the WAV file format.
            </summary>
            <param name="audio">Input to the operation: 2-D with shape `[length, channels]`.</param>
            <param name="sample_rate">Input to the operation: Scalar containing the sample frequency.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] contents(type: DtString): 0-D. WAV-encoded file contents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AudioSpectrogram(Emgu.TF.Output,System.Int64,System.Int64,System.Boolean,System.String)">
            <summary>
            Produces a visualization of audio data over time.
            </summary>
            <param name="input">Input to the operation: Float representation of audio data.</param>
            <param name="window_size">How wide the input window is in samples. For the highest efficiency this should be a power of two, but other values are accepted.</param>
            <param name="stride">How widely apart the center of adjacent sample windows should be.</param>
            <param name="magnitude_squared">Whether to return the squared magnitude or just the magnitude. Using squared magnitude can avoid extra calculations.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] spectrogram(type: DtFloat): 3D representation of the audio frequencies as an image.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Mfcc(Emgu.TF.Output,Emgu.TF.Output,System.Single,System.Single,System.Int64,System.Int64,System.String)">
            <summary>
            Transforms a spectrogram into a form that's useful for speech recognition.
            </summary>
            <param name="spectrogram">Input to the operation: Typically produced by the Spectrogram op, with magnitude_squared set to true.</param>
            <param name="sample_rate">Input to the operation: How many samples per second the source audio used.</param>
            <param name="upper_frequency_limit">The highest frequency to use when calculating the ceptstrum.</param>
            <param name="lower_frequency_limit">The lowest frequency to use when calculating the ceptstrum.</param>
            <param name="filterbank_channel_count">Resolution of the Mel bank used internally.</param>
            <param name="dct_coefficient_count">How many output channels to produce per time slice.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SdcaShrinkL1(Emgu.TF.Output,System.Single,System.Single,System.String)">
            <summary>
            Applies L1 regularization shrink step on the parameters.
            </summary>
            <param name="weights">Input to the operation: a list of vectors where each value is the weight associated with a feature group.</param>
            <param name="l1">Symmetric l1 regularization strength.</param>
            <param name="l2">Symmetric l2 regularization strength. Should be a positive float.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.FractionalAvgPoolGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes gradient of the FractionalAvgPool function.
            </summary>
            <param name="orig_input_tensor_shape">Input to the operation: Original input tensor shape for `fractional_avg_pool`</param>
            <param name="out_backprop">Input to the operation: 4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the output of `fractional_avg_pool`.</param>
            <param name="row_pooling_sequence">Input to the operation: row pooling sequence, form pooling region with col_pooling_sequence.</param>
            <param name="col_pooling_sequence">Input to the operation: column pooling sequence, form pooling region with row_pooling sequence.</param>
            <param name="overlapping">When set to True, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:  `index  0  1  2  3  4`  `value  20 5  16 3  7`  If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [41/3, 26/3] for fractional avg pooling.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D.  Gradients w.r.t. the input of `fractional_avg_pool`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RFFT3D(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            3D real-valued fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A float32 tensor.</param>
            <param name="fft_length">Input to the operation: An int32 tensor of shape [3]. The FFT length for each dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64): A complex64 tensor of the same rank as `input`. The inner-most 3   dimensions of `input` are replaced with the their 3D Fourier transform. The   inner-most dimension contains `fft_length / 2 + 1` unique frequency   components.  @compatibility(numpy) Equivalent to np.fft.rfftn with 3 dimensions. @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.UniformCandidateSampler(Emgu.TF.Output,System.Int64,System.Int64,System.Boolean,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Generates labels for candidate sampling with a uniform distribution.
            </summary>
            <param name="true_classes">Input to the operation: A batch_size * num_true matrix, in which each row contains the IDs of the num_true target_classes in the corresponding original label.</param>
            <param name="num_true">Number of true labels per context.</param>
            <param name="num_sampled">Number of candidates to randomly sample.</param>
            <param name="unique">If unique is true, we sample with rejection, so that all sampled candidates in a batch are unique. This requires some approximation to estimate the post-rejection sampling probabilities.</param>
            <param name="range_max">The sampler will sample integers from the interval [0, range_max).</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sampled_candidates(type: DtInt64): A vector of length num_sampled, in which each element is the ID of a sampled candidate.
            [1] true_expected_count(type: DtFloat): A batch_size * num_true matrix, representing the number of times each candidate is expected to occur in a batch of sampled candidates. If unique=true, then this is a probability.
            [2] sampled_expected_count(type: DtFloat): A vector of length num_sampled, for each sampled candidate representing the number of times the candidate is expected to occur in a batch of sampled candidates.  If unique=true, then this is a probability.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyRMSProp(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the RMSProp algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="ms">Input to the operation: Should be from a Variable().</param>
            <param name="mom">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay rate. Must be a scalar.</param>
            <param name="momentum">Input to the operation. </param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var, ms and mom.</param>
            <param name="use_locking">If `True`, updating of the var, ms, and mom tensors is protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LearnedUnigramCandidateSampler(Emgu.TF.Output,System.Int64,System.Int64,System.Boolean,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Generates labels for candidate sampling with a learned unigram distribution.
            </summary>
            <param name="true_classes">Input to the operation: A batch_size * num_true matrix, in which each row contains the IDs of the num_true target_classes in the corresponding original label.</param>
            <param name="num_true">Number of true labels per context.</param>
            <param name="num_sampled">Number of candidates to randomly sample.</param>
            <param name="unique">If unique is true, we sample with rejection, so that all sampled candidates in a batch are unique. This requires some approximation to estimate the post-rejection sampling probabilities.</param>
            <param name="range_max">The sampler will sample integers from the interval [0, range_max).</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sampled_candidates(type: DtInt64): A vector of length num_sampled, in which each element is the ID of a sampled candidate.
            [1] true_expected_count(type: DtFloat): A batch_size * num_true matrix, representing the number of times each candidate is expected to occur in a batch of sampled candidates. If unique=true, then this is a probability.
            [2] sampled_expected_count(type: DtFloat): A vector of length num_sampled, for each sampled candidate representing the number of times the candidate is expected to occur in a batch of sampled candidates.  If unique=true, then this is a probability.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ConcatenateDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that concatenates `input_dataset` with `another_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="another_dataset">Input to the operation. </param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.VarHandleOp(Emgu.TF.DataType,System.Int64[],System.String,System.String,System.String)">
            <summary>
            Creates a handle to a Variable resource.
            </summary>
            <param name="dtype">the type of this variable. Must agree with the dtypes of all ops using this variable.</param>
            <param name="shape">The (possibly partially specified) shape of this variable.</param>
            <param name="container">the container this variable is placed in.</param>
            <param name="shared_name">the name by which this variable is referred to.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] resource(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ThreadUnsafeUnigramCandidateSampler(Emgu.TF.Output,System.Int64,System.Int64,System.Boolean,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Generates labels for candidate sampling with a learned unigram distribution.
            </summary>
            <param name="true_classes">Input to the operation: A batch_size * num_true matrix, in which each row contains the IDs of the num_true target_classes in the corresponding original label.</param>
            <param name="num_true">Number of true labels per context.</param>
            <param name="num_sampled">Number of candidates to randomly sample.</param>
            <param name="unique">If unique is true, we sample with rejection, so that all sampled candidates in a batch are unique. This requires some approximation to estimate the post-rejection sampling probabilities.</param>
            <param name="range_max">The sampler will sample integers from the interval [0, range_max).</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sampled_candidates(type: DtInt64): A vector of length num_sampled, in which each element is the ID of a sampled candidate.
            [1] true_expected_count(type: DtFloat): A batch_size * num_true matrix, representing the number of times each candidate is expected to occur in a batch of sampled candidates. If unique=true, then this is a probability.
            [2] sampled_expected_count(type: DtFloat): A vector of length num_sampled, for each sampled candidate representing the number of times the candidate is expected to occur in a batch of sampled candidates.  If unique=true, then this is a probability.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MutableHashTable(Emgu.TF.DataType,Emgu.TF.DataType,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Creates an empty hash table.
            </summary>
            <param name="key_dtype">Type of the table keys.</param>
            <param name="value_dtype">Type of the table values.</param>
            <param name="container">If non-empty, this table is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this table is shared under the given name across multiple sessions.</param>
            <param name="use_node_name_sharing">If true and shared_name is empty, the table is shared using the node name.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] table_handle(type: DtString): Handle to a table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Dilation2DBackpropInput(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
            Computes the gradient of morphological 2-D dilation with respect to the input.
            </summary>
            <param name="input">Input to the operation: 4-D with shape `[batch, in_height, in_width, depth]`.</param>
            <param name="filter">Input to the operation: 3-D with shape `[filter_height, filter_width, depth]`.</param>
            <param name="out_backprop">Input to the operation: 4-D with shape `[batch, out_height, out_width, depth]`.</param>
            <param name="strides">1-D of length 4. The stride of the sliding window for each dimension of the input tensor. Must be: `[1, stride_height, stride_width, 1]`.</param>
            <param name="rates">1-D of length 4. The input stride for atrous morphological dilation. Must be: `[1, rate_height, rate_width, 1]`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] in_backprop(type: DtInvalid): 4-D with shape `[batch, in_height, in_width, depth]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TakeManySparseFromTensorsMap(Emgu.TF.Output,Emgu.TF.DataType,System.String,System.String,System.String)">
            <summary>
            Read `SparseTensors` from a `SparseTensorsMap` and concatenate them.
            </summary>
            <param name="sparse_handles">Input to the operation: 1-D, The `N` serialized `SparseTensor` objects. Shape: `[N]`.</param>
            <param name="dtype">The `dtype` of the `SparseTensor` objects stored in the `SparseTensorsMap`.</param>
            <param name="container">The container name for the `SparseTensorsMap` read by this op.</param>
            <param name="shared_name">The shared name for the `SparseTensorsMap` read by this op. It should not be blank; rather the `shared_name` or unique Operation name of the Op that created the original `SparseTensorsMap` should be used.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sparse_indices(type: DtInt64): 2-D.  The `indices` of the minibatch `SparseTensor`.
            [1] sparse_values(type: DtInvalid): 1-D.  The `values` of the minibatch `SparseTensor`.
            [2] sparse_shape(type: DtInt64): 1-D.  The `shape` of the minibatch `SparseTensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FixedUnigramCandidateSampler(Emgu.TF.Output,System.Int64,System.Int64,System.Boolean,System.Int64,System.String,System.Single,System.Int64,System.Int64,System.Int64,System.Single[],System.Int64,System.Int64,System.String)">
            <summary>
            Generates labels for candidate sampling with a learned unigram distribution.
            </summary>
            <param name="true_classes">Input to the operation: A batch_size * num_true matrix, in which each row contains the IDs of the num_true target_classes in the corresponding original label.</param>
            <param name="num_true">Number of true labels per context.</param>
            <param name="num_sampled">Number of candidates to randomly sample.</param>
            <param name="unique">If unique is true, we sample with rejection, so that all sampled candidates in a batch are unique. This requires some approximation to estimate the post-rejection sampling probabilities.</param>
            <param name="range_max">The sampler will sample integers from the interval [0, range_max).</param>
            <param name="vocab_file">Each valid line in this file (which should have a CSV-like format) corresponds to a valid word ID. IDs are in sequential order, starting from num_reserved_ids. The last entry in each line is expected to be a value corresponding to the count or relative probability. Exactly one of vocab_file and unigrams needs to be passed to this op.</param>
            <param name="distortion">The distortion is used to skew the unigram probability distribution. Each weight is first raised to the distortion's power before adding to the internal unigram distribution. As a result, distortion = 1.0 gives regular unigram sampling (as defined by the vocab file), and distortion = 0.0 gives a uniform distribution.</param>
            <param name="num_reserved_ids">Optionally some reserved IDs can be added in the range [0, ..., num_reserved_ids) by the users. One use case is that a special unknown word token is used as ID 0. These IDs will have a sampling probability of 0.</param>
            <param name="num_shards">A sampler can be used to sample from a subset of the original range in order to speed up the whole computation through parallelism. This parameter (together with 'shard') indicates the number of partitions that are being used in the overall computation.</param>
            <param name="shard">A sampler can be used to sample from a subset of the original range in order to speed up the whole computation through parallelism. This parameter (together with 'num_shards') indicates the particular partition number of a sampler op, when partitioning is being used.</param>
            <param name="unigrams">A list of unigram counts or probabilities, one per ID in sequential order. Exactly one of vocab_file and unigrams should be passed to this op.</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sampled_candidates(type: DtInt64): A vector of length num_sampled, in which each element is the ID of a sampled candidate.
            [1] true_expected_count(type: DtFloat): A batch_size * num_true matrix, representing the number of times each candidate is expected to occur in a batch of sampled candidates. If unique=true, then this is a probability.
            [2] sampled_expected_count(type: DtFloat): A vector of length num_sampled, for each sampled candidate representing the number of times the candidate is expected to occur in a batch of sampled candidates.  If unique=true, then this is a probability.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Erf(Emgu.TF.Output,System.String)">
            <summary>
            Computes the Gauss error function of `x` element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MaxPool3D(Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Performs 3D max pooling on the input.
            </summary>
            <param name="input">Input to the operation: Shape `[batch, depth, rows, cols, channels]` tensor to pool over.</param>
            <param name="ksize">1-D tensor of length 5. The size of the window for each dimension of the input tensor. Must have `ksize[0] = ksize[4] = 1`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">The data format of the input and output data. With the default format "NDHWC", the data is stored in the order of:     [batch, in_depth, in_height, in_width, in_channels]. Alternatively, the format could be "NCDHW", the data storage order is:     [batch, in_channels, in_depth, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The max pooled output tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ComputeAccidentalHits(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Computes the ids of the positions in sampled_candidates that match true_labels.
            </summary>
            <param name="true_classes">Input to the operation: The true_classes output of UnpackSparseLabels.</param>
            <param name="sampled_candidates">Input to the operation: The sampled_candidates output of CandidateSampler.</param>
            <param name="num_true">Number of true labels per context.</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] indices(type: DtInt32): A vector of indices corresponding to rows of true_candidates.
            [1] ids(type: DtInt64): A vector of IDs of positions in sampled_candidates that match a true_label for the row with the corresponding index in indices.
            [2] weights(type: DtFloat): A vector of the same length as indices and ids, in which each element is -FLOAT_MAX.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Switch(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Forwards `data` to the output port determined by `pred`.
            </summary>
            <param name="data">Input to the operation: The tensor to be forwarded to the appropriate output.</param>
            <param name="pred">Input to the operation: A scalar that specifies which output port will receive data.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_false(type: DtInvalid): If `pred` is false, data will be forwarded to this output.
            [1] output_true(type: DtInvalid): If `pred` is true, data will be forwarded to this output.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Log(Emgu.TF.Output,System.String)">
            <summary>
            Computes natural logarithm of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RefSwitch(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Forwards the ref tensor `data` to the output port determined by `pred`.
            </summary>
            <param name="data">Input to the operation: The ref tensor to be forwarded to the appropriate output.</param>
            <param name="pred">Input to the operation: A scalar that specifies which output port will receive data.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_false(type: DtInvalid): If `pred` is false, data will be forwarded to this output.
            [1] output_true(type: DtInvalid): If `pred` is true, data will be forwarded to this output.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Qr(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the QR decompositions of one or more matrices.
            </summary>
            <param name="input">Input to the operation: A tensor of shape `[..., M, N]` whose inner-most 2 dimensions form matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.</param>
            <param name="full_matrices">If true, compute full-sized `q` and `r`. If false (the default), compute only the leading `P` columns of `q`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] q(type: DtInvalid): Orthonormal basis for range of `a`. If `full_matrices` is `False` then shape is `[..., M, P]`; if `full_matrices` is `True` then shape is `[..., M, M]`.
            [1] r(type: DtInvalid): Triangular factor. If `full_matrices` is `False` then shape is `[..., P, N]`. If `full_matrices` is `True` then shape is `[..., M, N]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RefSelect(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Forwards the `index`th element of `inputs` to `output`.
            </summary>
            <param name="index">Input to the operation: A scalar that determines the input that gets selected.</param>
            <param name="inputs">Input to the operation: A list of ref tensors, one of which will be forwarded to `output`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The forwarded tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FusedBatchNormGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Single,System.String,System.Boolean,System.String)">
            <summary>
            Gradient for batch normalization.
            </summary>
            <param name="y_backprop">Input to the operation: A 4D Tensor for the gradient with respect to y.</param>
            <param name="x">Input to the operation: A 4D Tensor for input data.</param>
            <param name="scale">Input to the operation: A 1D Tensor for scaling factor, to scale the normalized x.</param>
            <param name="reserve_space_1">Input to the operation: A 1D Tensor for the computed batch mean, to be reused in the gradient computation.</param>
            <param name="reserve_space_2">Input to the operation: A 1D Tensor for the computed batch variance (inverted variance in the cuDNN case), to be used in the gradient computation.</param>
            <param name="epsilon">A small float number added to the variance of x.</param>
            <param name="data_format">The data format for y_backprop, x, x_backprop. Either "NHWC" (default) or "NCHW".</param>
            <param name="is_training">A bool value to indicate the operation is for training (default) or inference.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] x_backprop(type: DtInvalid): A 4D Tensor for the gradient with respect to x.
            [1] scale_backprop(type: DtInvalid): A 1D Tensor for the gradient with respect to scale.
            [2] offset_backprop(type: DtInvalid): A 1D Tensor for the gradient with respect to offset.
            [3] reserve_space_3(type: DtInvalid): Unused placeholder to match the mean input in FusedBatchNorm.
            [4] reserve_space_4(type: DtInvalid): Unused placeholder to match the variance input in FusedBatchNorm.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Merge(Emgu.TF.Output,System.String)">
            <summary>
            Forwards the value of an available tensor from `inputs` to `output`.
            </summary>
            <param name="inputs">Input to the operation: The input tensors, exactly one of which will become available.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Will be set to the available input tensor.
            [1] value_index(type: DtInt32): The index of the chosen input tensor in `inputs`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayUnpack(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="value">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MapDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that applies `f` to the outputs of `input_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="other_arguments">Input to the operation. </param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MaxPoolGradGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes second-order gradients of the maxpooling function.
            </summary>
            <param name="orig_input">Input to the operation: The original input tensor.</param>
            <param name="orig_output">Input to the operation: The original output tensor.</param>
            <param name="grad">Input to the operation: 4-D.  Gradients of gradients w.r.t. the input of `max_pool`.</param>
            <param name="ksize">The size of the window for each dimension of the input tensor.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, in_height, in_width, in_channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, in_channels, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Gradients of gradients w.r.t. the input to `max_pool`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FixedLengthRecordReaderV2(System.Int64,System.Int64,System.Int64,System.Int64,System.String,System.String,System.String,System.String)">
            <summary>
            A Reader that outputs fixed-length records from a file.
            </summary>
            <param name="record_bytes">Number of bytes in the record.</param>
            <param name="header_bytes">Number of bytes in the header, defaults to 0.</param>
            <param name="footer_bytes">Number of bytes in the footer, defaults to 0.</param>
            <param name="hop_bytes">Number of bytes to hop before each read. Default of 0 means using record_bytes.</param>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="encoding">The type of encoding for the file. Currently ZLIB and GZIP are supported. Defaults to none.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtResource): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReadVariableOp(Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Reads the value of a variable.
            </summary>
            <param name="resource">Input to the operation: handle to the resource in which to store the variable.</param>
            <param name="dtype">the dtype of the value.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyAdagradDA(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the proximal adagrad scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="gradient_accumulator">Input to the operation: Should be from a Variable().</param>
            <param name="gradient_squared_accumulator">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="global_step">Input to the operation: Training step number. Must be a scalar.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.RefMerge(Emgu.TF.Output,System.String)">
            <summary>
            Forwards the value of an available tensor from `inputs` to `output`.
            </summary>
            <param name="inputs">Input to the operation: The input tensors, exactly one of which will become available.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Will be set to the available input tensor.
            [1] value_index(type: DtInt32): The index of the chosen input tensor in `inputs`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayConcatV3(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Int64[],System.String)">
            <summary>
            Concat the elements from the TensorArray into value `value`.
            </summary>
            <param name="handle">Input to the operation: The handle to a TensorArray.</param>
            <param name="flow_in">Input to the operation: A float scalar that enforces proper chaining of operations.</param>
            <param name="dtype">The type of the elem that is returned.</param>
            <param name="element_shape_except0">The expected shape of an element, if known, excluding the first dimension. Used to validate the shapes of TensorArray elements. If this shape is not fully specified, concatenating zero-size TensorArrays is an error.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid): All of the elements in the TensorArray, concatenated along the first axis.
            [1] lengths(type: DtInt64): A vector of the row sizes of the original T elements in the value output.  In the example above, this would be the values: `(n1, n2, ..., n(T-1))`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Sin(Emgu.TF.Output,System.String)">
            <summary>
            Computes sin of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Enter(Emgu.TF.Output,System.String,System.Boolean,System.Int64,System.String)">
            <summary>
            Creates or finds a child frame, and makes `data` available to the child frame.
            </summary>
            <param name="data">Input to the operation: The tensor to be made available to the child frame.</param>
            <param name="frame_name">The name of the child frame.</param>
            <param name="is_constant">If true, the output is constant within the child frame.</param>
            <param name="parallel_iterations">The number of iterations allowed to run in parallel.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The same tensor as `data`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Softsign(Emgu.TF.Output,System.String)">
            <summary>
            Computes softsign: `features / (abs(features) + 1)`.
            </summary>
            <param name="features">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] activations(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RefEnter(Emgu.TF.Output,System.String,System.Boolean,System.Int64,System.String)">
            <summary>
            Creates or finds a child frame, and makes `data` available to the child frame.
            </summary>
            <param name="data">Input to the operation: The tensor to be made available to the child frame.</param>
            <param name="frame_name">The name of the child frame.</param>
            <param name="is_constant">If true, the output is constant within the child frame.</param>
            <param name="parallel_iterations">The number of iterations allowed to run in parallel.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The same tensor as `data`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StackClose(Emgu.TF.Output,System.String)">
            <summary>
            Deprecated, use StackCloseV2.
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Exit(Emgu.TF.Output,System.String)">
            <summary>
            Exits the current frame to its parent frame.
            </summary>
            <param name="data">Input to the operation: The tensor to be made available to the parent frame.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The same tensor as `data`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RefExit(Emgu.TF.Output,System.String)">
            <summary>
            Exits the current frame to its parent frame.
            </summary>
            <param name="data">Input to the operation: The tensor to be made available to the parent frame.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The same tensor as `data`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DeleteSessionTensor(Emgu.TF.Output,System.String)">
            <summary>
            Delete the tensor specified by its handle in the session.
            </summary>
            <param name="handle">Input to the operation: The handle for a tensor stored in the session state.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.NextIteration(Emgu.TF.Output,System.String)">
            <summary>
            Makes its input available to the next iteration.
            </summary>
            <param name="data">Input to the operation: The tensor to be made available to the next iteration.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The same tensor as `data`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RefNextIteration(Emgu.TF.Output,System.String)">
            <summary>
            Makes its input available to the next iteration.
            </summary>
            <param name="data">Input to the operation: The tensor to be made available to the next iteration.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The same tensor as `data`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedMaxPool(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
            Produces the max pool of the input tensor for quantized types.
            </summary>
            <param name="input">Input to the operation: The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.</param>
            <param name="min_input">Input to the operation: The float value that the lowest quantized input value represents.</param>
            <param name="max_input">Input to the operation: The float value that the highest quantized input value represents.</param>
            <param name="ksize">The size of the window for each dimension of the input tensor. The length must be 4 to match the number of dimensions of the input.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor. The length must be 4 to match the number of dimensions of the input.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            [1] min_output(type: DtFloat): The float value that the lowest quantized output value represents.
            [2] max_output(type: DtFloat): The float value that the highest quantized output value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DecodeRaw(Emgu.TF.Output,Emgu.TF.DataType,System.Boolean,System.String)">
            <summary>
            Reinterpret the bytes of a string as a vector of numbers.
            </summary>
            <param name="bytes">Input to the operation: All the elements must have the same length.</param>
            <param name="out_type"></param>
            <param name="little_endian">Whether the input `bytes` are in little-endian order. Ignored for `out_type` values that are stored in a single byte like `uint8`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A Tensor with one more dimension than the input `bytes`.  The added dimension will have size equal to the length of the elements of `bytes` divided by the number of bytes to represent `out_type`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LoopCond(Emgu.TF.Output,System.String)">
            <summary>
            Forwards the input to the output.
            </summary>
            <param name="input">Input to the operation: A boolean scalar, representing the branch predicate of the Switch op.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtBool): The same tensor as `input`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseReduceSumSparse(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the sum of elements across dimensions of a SparseTensor.
            </summary>
            <param name="input_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, possibly not in canonical ordering.</param>
            <param name="input_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `input_indices`.</param>
            <param name="input_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="reduction_axes">Input to the operation: 1-D.  Length-`K` vector containing the reduction axes.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64).
            [1] output_values(type: DtInvalid).
            [2] output_shape(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ControlTrigger(System.String)">
            <summary>
            Does nothing. Serves as a control trigger for scheduling.
            </summary>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Dilation2DBackpropFilter(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
            Computes the gradient of morphological 2-D dilation with respect to the filter.
            </summary>
            <param name="input">Input to the operation: 4-D with shape `[batch, in_height, in_width, depth]`.</param>
            <param name="filter">Input to the operation: 3-D with shape `[filter_height, filter_width, depth]`.</param>
            <param name="out_backprop">Input to the operation: 4-D with shape `[batch, out_height, out_width, depth]`.</param>
            <param name="strides">1-D of length 4. The stride of the sliding window for each dimension of the input tensor. Must be: `[1, stride_height, stride_width, 1]`.</param>
            <param name="rates">1-D of length 4. The input stride for atrous morphological dilation. Must be: `[1, rate_height, rate_width, 1]`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] filter_backprop(type: DtInvalid): 3-D with shape `[filter_height, filter_width, depth]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Abort(System.String,System.Boolean,System.String)">
            <summary>
            Raise a exception to abort the process when called.
            </summary>
            <param name="error_msg">A string which is the message associated with the exception.</param>
            <param name="exit_without_error"></param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.DecodeCSV(Emgu.TF.Output,Emgu.TF.Output,System.String,System.Boolean,System.String)">
            <summary>
            Convert CSV records to tensors. Each column maps to one tensor.
            </summary>
            <param name="records">Input to the operation: Each string is a record/row in the csv and all records should have the same format.</param>
            <param name="record_defaults">Input to the operation: One tensor per column of the input record, with either a scalar default value for that column or empty if the column is required.</param>
            <param name="field_delim">char delimiter to separate fields in a record.</param>
            <param name="use_quote_delim">If false, treats double quotation marks as regular characters inside of the string fields (ignoring RFC 4180, Section 2, Bullet 5).</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Each tensor will have the same shape as records.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Sign(Emgu.TF.Output,System.String)">
            <summary>
            Returns an element-wise indication of the sign of a number.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CTCLoss(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            Calculates the CTC Loss (log probability) for each batch entry.  Also calculates
            </summary>
            <param name="inputs">Input to the operation: 3-D, shape: `(max_time x batch_size x num_classes)`, the logits.</param>
            <param name="labels_indices">Input to the operation: The indices of a `SparseTensor&lt;int32, 2&gt;`. `labels_indices(i, :) == [b, t]` means `labels_values(i)` stores the id for `(batch b, time t)`.</param>
            <param name="labels_values">Input to the operation: The values (labels) associated with the given batch and time.</param>
            <param name="sequence_length">Input to the operation: A vector containing sequence lengths (batch).</param>
            <param name="preprocess_collapse_repeated">Scalar, if true then repeated labels are collapsed prior to the CTC calculation.</param>
            <param name="ctc_merge_repeated">Scalar.  If set to false, *during* CTC calculation repeated non-blank labels will not be merged and are interpreted as individual labels.  This is a simplified version of CTC.</param>
            <param name="ignore_longer_outputs_than_inputs">Scalar. If set to true, during CTC calculation, items that have longer output sequences than input sequences are skipped: they don't contribute to the loss term and have zero-gradient.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] loss(type: DtFloat): A vector (batch) containing log-probabilities.
            [1] gradient(type: DtFloat): The gradient of `loss`.  3-D, shape: `(max_time x batch_size x num_classes)`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CTCGreedyDecoder(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Performs greedy decoding on the logits given in inputs.
            </summary>
            <param name="inputs">Input to the operation: 3-D, shape: `(max_time x batch_size x num_classes)`, the logits.</param>
            <param name="sequence_length">Input to the operation: A vector containing sequence lengths, size `(batch_size)`.</param>
            <param name="merge_repeated">If True, merge repeated classes in output.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] decoded_indices(type: DtInt64): Indices matrix, size `(total_decoded_outputs x 2)`, of a `SparseTensor&lt;int64, 2&gt;`.  The rows store: [batch, time].
            [1] decoded_values(type: DtInt64): Values vector, size: `(total_decoded_outputs)`, of a `SparseTensor&lt;int64, 2&gt;`.  The vector stores the decoded classes.
            [2] decoded_shape(type: DtInt64): Shape vector, size `(2)`, of the decoded SparseTensor. Values are: `[batch_size, max_decoded_length]`.
            [3] log_probability(type: DtFloat): Matrix, size `(batch_size x 1)`, containing sequence log-probabilities.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.WholeFileReaderV2(System.String,System.String,System.String)">
            <summary>
            A Reader that outputs the entire contents of a file as a value.
            </summary>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtResource): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DynamicPartition(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Partitions `data` into `num_partitions` tensors using indices from `partitions`.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="partitions">Input to the operation: Any shape.  Indices in the range `[0, num_partitions)`.</param>
            <param name="num_partitions">The number of partitions to output.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] outputs(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TextLineReader(System.Int64,System.String,System.String,System.String)">
            <summary>
            A Reader that outputs the lines of a file delimited by '\n'.
            </summary>
            <param name="skip_header_lines">Number of lines to skip from the beginning of every file.</param>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtString): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Relu6(Emgu.TF.Output,System.String)">
            <summary>
            Computes rectified linear 6: `min(max(features, 0), 6)`.
            </summary>
            <param name="features">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] activations(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Bucketize(Emgu.TF.Output,System.Single[],System.String)">
            <summary>
            Bucketizes 'input' based on 'boundaries'.
            </summary>
            <param name="input">Input to the operation: Any shape of Tensor contains with int or float type.</param>
            <param name="boundaries">A sorted list of floats gives the boundary of the buckets.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInt32): Same shape with 'input', each value of input replaced with bucket index.  @compatibility(numpy) Equivalent to np.digitize. @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DynamicStitch(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Interleave the values from the `data` tensors into a single tensor.
            </summary>
            <param name="indices">Input to the operation. </param>
            <param name="data">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] merged(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterNdUpdate(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Applies sparse `updates` to individual values or slices within a given
            </summary>
            <param name="reference">Input to the operation: A mutable Tensor. Should be from a Variable node.</param>
            <param name="indices">Input to the operation: A Tensor. Must be one of the following types: int32, int64. A tensor of indices into ref.</param>
            <param name="updates">Input to the operation: A Tensor. Must have the same type as ref. A tensor of updated values to add to ref.</param>
            <param name="use_locking">An optional bool. Defaults to True. If True, the assignment will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): Same as ref. Returned as a convenience for operations that want to use the updated values after the update is done.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RandomShuffleQueue(Emgu.TF.DataType[],System.Int64[][],System.Int64,System.Int64,System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            A queue that randomizes the order of elements.
            </summary>
            <param name="component_types">The type of each component in a value.</param>
            <param name="shapes">The shape of each component in a value. The length of this attr must be either 0 or the same as the length of component_types. If the length of this attr is 0, the shapes of queue elements are not constrained, and only one element may be dequeued at a time.</param>
            <param name="capacity">The upper bound on the number of elements in this queue. Negative numbers mean no limit.</param>
            <param name="min_after_dequeue">Dequeue will block unless there would be this many elements after the dequeue or the queue is closed. This ensures a minimum level of mixing of elements.</param>
            <param name="seed">If either seed or seed2 is set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, a random seed is used.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this queue will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString): The handle to the queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RandomShuffleQueueV2(Emgu.TF.DataType[],System.Int64[][],System.Int64,System.Int64,System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            A queue that randomizes the order of elements.
            </summary>
            <param name="component_types">The type of each component in a value.</param>
            <param name="shapes">The shape of each component in a value. The length of this attr must be either 0 or the same as the length of component_types. If the length of this attr is 0, the shapes of queue elements are not constrained, and only one element may be dequeued at a time.</param>
            <param name="capacity">The upper bound on the number of elements in this queue. Negative numbers mean no limit.</param>
            <param name="min_after_dequeue">Dequeue will block unless there would be this many elements after the dequeue or the queue is closed. This ensures a minimum level of mixing of elements.</param>
            <param name="seed">If either seed or seed2 is set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, a random seed is used.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this queue will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource): The handle to the queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SetSize(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Number of unique elements along last dimension of input `set`.
            </summary>
            <param name="set_indices">Input to the operation: 2D `Tensor`, indices of a `SparseTensor`.</param>
            <param name="set_values">Input to the operation: 1D `Tensor`, values of a `SparseTensor`.</param>
            <param name="set_shape">Input to the operation: 1D `Tensor`, shape of a `SparseTensor`.</param>
            <param name="validate_indices"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32): For `set` ranked `n`, this is a `Tensor` with rank `n-1`, and the same 1st `n-1` dimensions as `set`. Each value is the number of unique elements in the corresponding `[0...n-1]` dimension of `set`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AccumulatorTakeGradient(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Extracts the average gradient in the given ConditionalAccumulator.
            </summary>
            <param name="handle">Input to the operation: The handle to an accumulator.</param>
            <param name="num_required">Input to the operation: Number of gradients required before we return an aggregate.</param>
            <param name="dtype">The data type of accumulated gradients. Needs to correspond to the type of the accumulator.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] average(type: DtInvalid): The average of the accumulated gradients.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FIFOQueueV2(Emgu.TF.DataType[],System.Int64[][],System.Int64,System.String,System.String,System.String)">
            <summary>
            A queue that produces elements in first-in first-out order.
            </summary>
            <param name="component_types">The type of each component in a value.</param>
            <param name="shapes">The shape of each component in a value. The length of this attr must be either 0 or the same as the length of component_types. If the length of this attr is 0, the shapes of queue elements are not constrained, and only one element may be dequeued at a time.</param>
            <param name="capacity">The upper bound on the number of elements in this queue. Negative numbers mean no limit.</param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this queue will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource): The handle to the queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyFtrl(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="linear">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regulariation. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regulariation. Must be a scalar.</param>
            <param name="lr_power">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.PaddingFIFOQueue(Emgu.TF.DataType[],System.Int64[][],System.Int64,System.String,System.String,System.String)">
            <summary>
            A queue that produces elements in first-in first-out order.
            </summary>
            <param name="component_types">The type of each component in a value.</param>
            <param name="shapes">The shape of each component in a value. The length of this attr must be either 0 or the same as the length of component_types. Shapes of fixed rank but variable size are allowed by setting any shape dimension to -1.  In this case, the inputs' shape may vary along the given dimension, and DequeueMany will pad the given dimension with zeros up to the maximum shape of all elements in the given batch. If the length of this attr is 0, different queue elements may have different ranks and shapes, but only one element may be dequeued at a time.</param>
            <param name="capacity">The upper bound on the number of elements in this queue. Negative numbers mean no limit.</param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this queue will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString): The handle to the queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyFtrlV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="linear">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regulariation. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 shrinkage regulariation. Must be a scalar.</param>
            <param name="l2_shrinkage">Input to the operation. </param>
            <param name="lr_power">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.PaddingFIFOQueueV2(Emgu.TF.DataType[],System.Int64[][],System.Int64,System.String,System.String,System.String)">
            <summary>
            A queue that produces elements in first-in first-out order.
            </summary>
            <param name="component_types">The type of each component in a value.</param>
            <param name="shapes">The shape of each component in a value. The length of this attr must be either 0 or the same as the length of component_types. Shapes of fixed rank but variable size are allowed by setting any shape dimension to -1.  In this case, the inputs' shape may vary along the given dimension, and DequeueMany will pad the given dimension with zeros up to the maximum shape of all elements in the given batch. If the length of this attr is 0, different queue elements may have different ranks and shapes, but only one element may be dequeued at a time.</param>
            <param name="capacity">The upper bound on the number of elements in this queue. Negative numbers mean no limit.</param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this queue will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource): The handle to the queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.VarIsInitializedOp(Emgu.TF.Output,System.String)">
            <summary>
            Checks whether a resource handle-based variable has been initialized.
            </summary>
            <param name="resource">Input to the operation: the input resource handle.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] is_initialized(type: DtBool): a scalar boolean which is true if the variable has been initialized.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.PriorityQueue(System.Int64[][],Emgu.TF.DataType[],System.Int64,System.String,System.String,System.String)">
            <summary>
            A queue that produces elements sorted by the first component value.
            </summary>
            <param name="shapes">The shape of each component in a value. The length of this attr must be either 0 or the same as the length of component_types. If the length of this attr is 0, the shapes of queue elements are not constrained, and only one element may be dequeued at a time.</param>
            <param name="component_types">The type of each component in a value.</param>
            <param name="capacity">The upper bound on the number of elements in this queue. Negative numbers mean no limit.</param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this queue will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString): The handle to the queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Imag(Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Returns the imaginary part of a complex number.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="Tout"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FakeQueue(Emgu.TF.Output,System.String)">
            <summary>
            Deprecated. Do not use.
            </summary>
            <param name="resource">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StackV2(Emgu.TF.Output,Emgu.TF.DataType,System.String,System.String)">
            <summary>
            A stack that produces elements in first-in last-out order.
            </summary>
            <param name="max_size">Input to the operation: The maximum size of the stack if non-negative. If negative, the stack size is unlimited.</param>
            <param name="elem_type">The type of the elements on the stack.</param>
            <param name="stack_name">Overrides the name used for the temporary stack resource. Default value is the name of the 'Stack' op (which is guaranteed unique).</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource): The handle to the stack.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Round(Emgu.TF.Output,System.String)">
            <summary>
            Rounds the values of a tensor to the nearest integer, element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueEnqueue(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Enqueues a tuple of one or more tensors in the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="components">Input to the operation: One or more tensors from which the enqueued tensors should be taken.</param>
            <param name="timeout_ms">If the queue is full, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.QueueEnqueueV2(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Enqueues a tuple of one or more tensors in the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="components">Input to the operation: One or more tensors from which the enqueued tensors should be taken.</param>
            <param name="timeout_ms">If the queue is full, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.QueueEnqueueMany(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Enqueues zero or more tuples of one or more tensors in the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="components">Input to the operation: One or more tensors from which the enqueued tensors should be taken.</param>
            <param name="timeout_ms">If the queue is too full, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderResetV2(Emgu.TF.Output,System.String)">
            <summary>
            Restore a Reader to its initial clean state.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.QueueEnqueueManyV2(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Enqueues zero or more tuples of one or more tensors in the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="components">Input to the operation: One or more tensors from which the enqueued tensors should be taken.</param>
            <param name="timeout_ms">If the queue is too full, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.UnsortedSegmentMax(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the Max along segments of a tensor.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="segment_ids">Input to the operation: A 1-D tensor whose rank is equal to the rank of `data`'s first dimension.</param>
            <param name="num_segments">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for dimension 0 which has size `num_segments`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueDequeue(Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.String)">
            <summary>
            Dequeues a tuple of one or more tensors from the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="component_types">The type of each component in a tuple.</param>
            <param name="timeout_ms">If the queue is empty, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] components(type: DtInvalid): One or more tensors that were dequeued as a tuple.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueDequeueV2(Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.String)">
            <summary>
            Dequeues a tuple of one or more tensors from the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="component_types">The type of each component in a tuple.</param>
            <param name="timeout_ms">If the queue is empty, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] components(type: DtInvalid): One or more tensors that were dequeued as a tuple.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TruncateMod(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns element-wise remainder of division. This emulates C semantics in that
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DenseToSparseBatchDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that yields a SparseTensor for each element of the input.
            </summary>
            <param name="input_dataset">Input to the operation: A handle to an input dataset. Must have a single component.</param>
            <param name="batch_size">Input to the operation: A scalar representing the number of elements to accumulate in a batch.</param>
            <param name="row_shape">Input to the operation: A vector representing the dense shape of each row in the produced SparseTensor.</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueDequeueMany(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.String)">
            <summary>
            Dequeues `n` tuples of one or more tensors from the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="n">Input to the operation: The number of tuples to dequeue.</param>
            <param name="component_types">The type of each component in a tuple.</param>
            <param name="timeout_ms">If the queue has fewer than n elements, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] components(type: DtInvalid): One or more tensors that were dequeued as a tuple.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueDequeueUpTo(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.String)">
            <summary>
            Dequeues `n` tuples of one or more tensors from the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="n">Input to the operation: The number of tuples to dequeue.</param>
            <param name="component_types">The type of each component in a tuple.</param>
            <param name="timeout_ms">If the queue has fewer than n elements, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] components(type: DtInvalid): One or more tensors that were dequeued as a tuple.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DecodeBmp(Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Decode the first frame of a BMP-encoded image to a uint8 tensor.
            </summary>
            <param name="contents">Input to the operation: 0-D.  The BMP-encoded image.</param>
            <param name="channels"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] image(type: DtUint8): 3-D with shape `[height, width, channels]`. RGB order
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DecodePng(Emgu.TF.Output,System.Int64,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Decode a PNG-encoded image to a uint8 or uint16 tensor.
            </summary>
            <param name="contents">Input to the operation: 0-D.  The PNG-encoded image.</param>
            <param name="channels">Number of color channels for the decoded image.</param>
            <param name="dtype"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] image(type: DtInvalid): 3-D with shape `[height, width, channels]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueDequeueUpToV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.String)">
            <summary>
            Dequeues `n` tuples of one or more tensors from the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="n">Input to the operation: The number of tuples to dequeue.</param>
            <param name="component_types">The type of each component in a tuple.</param>
            <param name="timeout_ms">If the queue has fewer than n elements, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] components(type: DtInvalid): One or more tensors that were dequeued as a tuple.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueClose(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Closes the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="cancel_pending_enqueues">If true, all pending enqueue requests that are blocked on the given queue will be canceled.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ParallelMapDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that applies `f` to the outputs of `input_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="other_arguments">Input to the operation. </param>
            <param name="num_threads">Input to the operation: The number of threads to use to process elements from `input_dataset`.</param>
            <param name="output_buffer_size">Input to the operation: The maximum number of output elements to buffer in an iterator over this dataset.</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueCloseV2(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Closes the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="cancel_pending_enqueues">If true, all pending enqueue requests that are blocked on the given queue will be canceled.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.AdjustContrastv2(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Adjust the contrast of one or more images.
            </summary>
            <param name="images">Input to the operation: Images to adjust.  At least 3-D.</param>
            <param name="contrast_factor">Input to the operation: A float multiplier for adjusting contrast.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat): The contrast-adjusted image or images.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueIsClosed(Emgu.TF.Output,System.String)">
            <summary>
            Returns true if queue is closed.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] is_closed(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueIsClosedV2(Emgu.TF.Output,System.String)">
            <summary>
            Returns true if queue is closed.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] is_closed(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueSize(Emgu.TF.Output,System.String)">
            <summary>
            Computes the number of elements in the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32): The number of elements in the given queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QueueSizeV2(Emgu.TF.Output,System.String)">
            <summary>
            Computes the number of elements in the given queue.
            </summary>
            <param name="handle">Input to the operation: The handle to a queue.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32): The number of elements in the given queue.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SegmentProd(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the product along segments of a tensor.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="segment_ids">Input to the operation: A 1-D tensor whose rank is equal to the rank of `data`'s first dimension.  Values should be sorted and can be repeated.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for dimension 0 which has size `k`, the number of segments.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AccumulatorNumAccumulated(Emgu.TF.Output,System.String)">
            <summary>
            Returns the number of gradients aggregated in the given accumulators.
            </summary>
            <param name="handle">Input to the operation: The handle to an accumulator.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] num_accumulated(type: DtInt32): The number of gradients aggregated in the given accumulator.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SaveSlices(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Saves input tensors slices to disk.
            </summary>
            <param name="filename">Input to the operation: Must have a single element. The name of the file to which we write the tensor.</param>
            <param name="tensor_names">Input to the operation: Shape `[N]`. The names of the tensors to be saved.</param>
            <param name="shapes_and_slices">Input to the operation: Shape `[N]`.  The shapes and slice specifications to use when saving the tensors.</param>
            <param name="data">Input to the operation: `N` tensors to save.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ConditionalAccumulator(Emgu.TF.DataType,System.Int64[],System.String,System.String,System.String)">
            <summary>
            A conditional accumulator for aggregating gradients.
            </summary>
            <param name="dtype">The type of the value being accumulated.</param>
            <param name="shape">The shape of the values, can be [], in which case shape is unknown.</param>
            <param name="container">If non-empty, this accumulator is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this accumulator will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString): The handle to the accumulator.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AccumulatorApplyGradient(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Applies a gradient to a given accumulator.
            </summary>
            <param name="handle">Input to the operation: The handle to a accumulator.</param>
            <param name="local_step">Input to the operation: The local_step value at which the gradient was computed.</param>
            <param name="gradient">Input to the operation: A tensor of the gradient to be accumulated.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.FFT(Emgu.TF.Output,System.String)">
            <summary>
            Fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A complex64 tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64): A complex64 tensor of the same shape as `input`. The inner-most   dimension of `input` is replaced with its 1D Fourier transform.  @compatibility(numpy) Equivalent to np.fft.fft @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseConditionalAccumulator(Emgu.TF.DataType,System.Int64[],System.String,System.String,System.String)">
            <summary>
            A conditional accumulator for aggregating sparse gradients.
            </summary>
            <param name="dtype">The type of the value being accumulated.</param>
            <param name="shape">The shape of the values.</param>
            <param name="container">If non-empty, this accumulator is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this accumulator will be shared under the given name across multiple sessions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString): The handle to the accumulator.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.GreaterEqual(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the truth value of (x &gt;= y) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseAccumulatorApplyGradient(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Applies a sparse gradient to a given accumulator.
            </summary>
            <param name="handle">Input to the operation: The handle to a accumulator.</param>
            <param name="local_step">Input to the operation: The local_step value at which the sparse gradient was computed.</param>
            <param name="gradient_indices">Input to the operation: Indices of the sparse gradient to be accumulated. Must be a vector.</param>
            <param name="gradient_values">Input to the operation: Values are the non-zero slices of the gradient, and must have the same first dimension as indices, i.e., the nnz represented by indices and values must be consistent.</param>
            <param name="gradient_shape">Input to the operation: Shape of the sparse gradient to be accumulated.</param>
            <param name="has_known_shape">Boolean indicating whether gradient_shape is unknown, in which case the input is ignored during validation.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.SparseAccumulatorTakeGradient(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Extracts the average sparse gradient in a SparseConditionalAccumulator.
            </summary>
            <param name="handle">Input to the operation: The handle to a SparseConditionalAccumulator.</param>
            <param name="num_required">Input to the operation: Number of gradients required before we return an aggregate.</param>
            <param name="dtype">The data type of accumulated gradients. Needs to correspond to the type of the accumulator.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] indices(type: DtInt64): Indices of the average of the accumulated sparse gradients.
            [1] values(type: DtInvalid): Values of the average of the accumulated sparse gradients.
            [2] shape(type: DtInt64): Shape of the average of the accumulated sparse gradients.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StackPushV2(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Push an element onto the stack.
            </summary>
            <param name="handle">Input to the operation: The handle to a stack.</param>
            <param name="elem">Input to the operation: The tensor to be pushed onto the stack.</param>
            <param name="swap_memory">Swap `elem` to CPU. Default to false.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The same tensor as the input 'elem'.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.EluGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes gradients for the exponential linear (Elu) operation.
            </summary>
            <param name="gradients">Input to the operation: The backpropagated gradients to the corresponding Elu operation.</param>
            <param name="outputs">Input to the operation: The outputs of the corresponding Elu operation.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] backprops(type: DtInvalid): The gradients: `gradients * (outputs + 1)` if outputs &lt; 0, `gradients` otherwise.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StackPopV2(Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Pop the element at the top of the stack.
            </summary>
            <param name="handle">Input to the operation: The handle to a stack.</param>
            <param name="elem_type">The type of the elem that is popped.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] elem(type: DtInvalid): The tensor that is popped from the top of the stack.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RepeatDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that emits the outputs of `input_dataset` `count` times.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="count">Input to the operation: A scalar representing the number of times that `input_dataset` should be repeated. A value of `-1` indicates that it should be repeated infinitely.</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StackCloseV2(Emgu.TF.Output,System.String)">
            <summary>
            Delete the stack from its resource container.
            </summary>
            <param name="handle">Input to the operation: The handle to a stack.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Stack(Emgu.TF.DataType,System.String,System.String)">
            <summary>
            Deprecated, use StackV2.
            </summary>
            <param name="elem_type"></param>
            <param name="stack_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.GroupByWindowDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that computes a windowed group-by on `input_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="key_func_other_arguments">Input to the operation. </param>
            <param name="reduce_func_other_arguments">Input to the operation. </param>
            <param name="window_size">Input to the operation. </param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyCenteredRMSProp(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the centered RMSProp algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="mg">Input to the operation: Should be from a Variable().</param>
            <param name="ms">Input to the operation: Should be from a Variable().</param>
            <param name="mom">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay rate. Must be a scalar.</param>
            <param name="momentum">Input to the operation. </param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var, ms and mom.</param>
            <param name="use_locking">If `True`, updating of the var, mg, ms, and mom tensors is protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayV3(Emgu.TF.Output,Emgu.TF.DataType,System.Int64[],System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            An array of Tensors of given size.
            </summary>
            <param name="size">Input to the operation: The size of the array.</param>
            <param name="dtype">The type of the elements on the tensor_array.</param>
            <param name="element_shape">The expected shape of an element, if known. Used to validate the shapes of TensorArray elements. If this shape is not fully specified, gathering zero-size TensorArrays is an error.</param>
            <param name="dynamic_size">A boolean that determines whether writes to the TensorArray are allowed to grow the size.  By default, this is not allowed.</param>
            <param name="clear_after_read">If true (default), Tensors in the TensorArray are cleared after being read.  This disables multiple read semantics but allows early release of memory.</param>
            <param name="tensor_array_name">Overrides the name used for the temporary tensor_array resource. Default value is the name of the 'TensorArray' op (which is guaranteed unique).</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource): The handle to the TensorArray.
            [1] flow(type: DtFloat): A scalar used to control gradient flow.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayGradV3(Emgu.TF.Output,Emgu.TF.Output,System.String,System.String)">
            <summary>
            Creates a TensorArray for storing the gradients of values in the given handle.
            </summary>
            <param name="handle">Input to the operation: The handle to the forward TensorArray.</param>
            <param name="flow_in">Input to the operation: A float scalar that enforces proper chaining of operations.</param>
            <param name="source">The gradient source string, used to decide which gradient TensorArray to return.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] grad_handle(type: DtResource).
            [1] flow_out(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayWriteV3(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Push an element onto the tensor_array.
            </summary>
            <param name="handle">Input to the operation: The handle to a TensorArray.</param>
            <param name="index">Input to the operation: The position to write to inside the TensorArray.</param>
            <param name="value">Input to the operation: The tensor to write to the TensorArray.</param>
            <param name="flow_in">Input to the operation: A float scalar that enforces proper chaining of operations.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat): A float scalar that enforces proper chaining of operations.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayReadV3(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Read an element from the TensorArray into output `value`.
            </summary>
            <param name="handle">Input to the operation: The handle to a TensorArray.</param>
            <param name="index">Input to the operation. </param>
            <param name="flow_in">Input to the operation: A float scalar that enforces proper chaining of operations.</param>
            <param name="dtype">The type of the elem that is returned.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid): The tensor that is read from the TensorArray.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayGatherV3(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Int64[],System.String)">
            <summary>
            Gather specific elements from the TensorArray into output `value`.
            </summary>
            <param name="handle">Input to the operation: The handle to a TensorArray.</param>
            <param name="indices">Input to the operation: The locations in the TensorArray from which to read tensor elements.</param>
            <param name="flow_in">Input to the operation: A float scalar that enforces proper chaining of operations.</param>
            <param name="dtype">The type of the elem that is returned.</param>
            <param name="element_shape">The expected shape of an element, if known. Used to validate the shapes of TensorArray elements. If this shape is not fully specified, gathering zero-size TensorArrays is an error.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid): All of the elements in the TensorArray, concatenated along a new axis (the new dimension 0).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayScatterV3(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Scatter the data from the input value into specific TensorArray elements.
            </summary>
            <param name="handle">Input to the operation: The handle to a TensorArray.</param>
            <param name="indices">Input to the operation: The locations at which to write the tensor elements.</param>
            <param name="value">Input to the operation: The concatenated tensor to write to the TensorArray.</param>
            <param name="flow_in">Input to the operation: A float scalar that enforces proper chaining of operations.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat): A float scalar that enforces proper chaining of operations.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FractionalMaxPoolGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes gradient of the FractionalMaxPool function.
            </summary>
            <param name="orig_input">Input to the operation: Original input for `fractional_max_pool`</param>
            <param name="orig_output">Input to the operation: Original output for `fractional_max_pool`</param>
            <param name="out_backprop">Input to the operation: 4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the output of `fractional_max_pool`.</param>
            <param name="row_pooling_sequence">Input to the operation: row pooling sequence, form pooling region with col_pooling_sequence.</param>
            <param name="col_pooling_sequence">Input to the operation: column pooling sequence, form pooling region with row_pooling sequence.</param>
            <param name="overlapping">When set to True, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:  `index  0  1  2  3  4`  `value  20 5  16 3  7`  If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [20, 16] for fractional max pooling.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D.  Gradients w.r.t. the input of `fractional_max_pool`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BarrierReadySize(Emgu.TF.Output,System.String)">
            <summary>
            Computes the number of complete elements in the given barrier.
            </summary>
            <param name="handle">Input to the operation: The handle to a barrier.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32): The number of complete elements (i.e. those with all of their value components set) in the barrier.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RealDiv(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns x / y element-wise for real types.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayCloseV3(Emgu.TF.Output,System.String)">
            <summary>
            Delete the TensorArray from its resource container.
            </summary>
            <param name="handle">Input to the operation: The handle to a TensorArray (output of TensorArray or TensorArrayGrad).</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArray(Emgu.TF.Output,Emgu.TF.DataType,System.Boolean,System.Boolean,System.String,System.Int64[],System.String)">
            <summary>
            
            </summary>
            <param name="size">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="dynamic_size"></param>
            <param name="clear_after_read"></param>
            <param name="tensor_array_name"></param>
            <param name="element_shape"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayV2(Emgu.TF.Output,Emgu.TF.DataType,System.Int64[],System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            Deprecated. Use TensorArrayV3
            </summary>
            <param name="size">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="element_shape"></param>
            <param name="dynamic_size"></param>
            <param name="clear_after_read"></param>
            <param name="tensor_array_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AvgPoolGrad(Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes gradients of the average pooling function.
            </summary>
            <param name="orig_input_shape">Input to the operation: 1-D.  Shape of the original input to `avg_pool`.</param>
            <param name="grad">Input to the operation: 4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the output of `avg_pool`.</param>
            <param name="ksize">The size of the sliding window for each dimension of the input.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, in_height, in_width, in_channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, in_channels, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D.  Gradients w.r.t. the input of `avg_pool`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseMatMul(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            Multiply matrix "a" by matrix "b".
            </summary>
            <param name="a">Input to the operation. </param>
            <param name="b">Input to the operation. </param>
            <param name="transpose_a"></param>
            <param name="transpose_b"></param>
            <param name="a_is_sparse"></param>
            <param name="b_is_sparse"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] product(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.InitializeTableV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Table initializer that takes two tensors for keys and values respectively.
            </summary>
            <param name="table_handle">Input to the operation: Handle to a table which will be initialized.</param>
            <param name="keys">Input to the operation: Keys of type Tkey.</param>
            <param name="values">Input to the operation: Values of type Tval.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayGradV2(Emgu.TF.Output,Emgu.TF.Output,System.String,System.String)">
            <summary>
            Deprecated. Use TensorArrayGradV3
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="source"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] grad_handle(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RecordInput(System.String,System.Int64,System.Single,System.Int64,System.Int64,System.Int64,System.String)">
            <summary>
            Emits randomized records.
            </summary>
            <param name="file_pattern">Glob pattern for the data files.</param>
            <param name="file_random_seed">Random seeds used to produce randomized records.</param>
            <param name="file_shuffle_shift_ratio">Shifts the list of files after the list is randomly shuffled.</param>
            <param name="file_buffer_size">The randomization shuffling buffer.</param>
            <param name="file_parallelism">How many sstables are opened and concurrently iterated over.</param>
            <param name="batch_size">The batch size.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] records(type: DtString): A tensor of shape [batch_size].
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayWrite(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="index">Input to the operation. </param>
            <param name="value">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SoftplusGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes softplus gradients for a softplus operation.
            </summary>
            <param name="gradients">Input to the operation: The backpropagated gradients to the corresponding softplus operation.</param>
            <param name="features">Input to the operation: The features passed as input to the corresponding softplus operation.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] backprops(type: DtInvalid): The gradients: `gradients / (1 + exp(-features))`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SegmentSum(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the sum along segments of a tensor.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="segment_ids">Input to the operation: A 1-D tensor whose rank is equal to the rank of `data`'s first dimension.  Values should be sorted and can be repeated.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for dimension 0 which has size `k`, the number of segments.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayRead(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="index">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Floor(Emgu.TF.Output,System.String)">
            <summary>
            Returns element-wise largest integer not greater than x.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayReadV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Deprecated. Use TensorArrayReadV3
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="index">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayPack(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Int64[],System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="element_shape"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayGather(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Int64[],System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="element_shape"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ShuffleDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that shuffles elements from `input_dataset` pseudorandomly.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="buffer_size">Input to the operation: The number of output elements to buffer in an iterator over this dataset. Compare with the `min_after_dequeue` attr when creating a `RandomShuffleQueue`.</param>
            <param name="seed">Input to the operation: A scalar seed for the random number generator. If either seed or seed2 is set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, a random seed is used.</param>
            <param name="seed2">Input to the operation: A second scalar seed to avoid seed collision.</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayGatherV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Int64[],System.String)">
            <summary>
            Deprecated. Use TensorArrayGatherV3
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="element_shape"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IteratorToStringHandle(Emgu.TF.Output,System.String)">
            <summary>
            Converts the given `resource_handle` representing an iterator to a string.
            </summary>
            <param name="resource_handle">Input to the operation: A handle to an iterator resource.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] string_handle(type: DtString): A string representation of the given handle.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseReshape(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Reshapes a SparseTensor to represent values in a new dense shape.
            </summary>
            <param name="input_indices">Input to the operation: 2-D.  `N x R_in` matrix with the indices of non-empty values in a SparseTensor.</param>
            <param name="input_shape">Input to the operation: 1-D.  `R_in` vector with the input SparseTensor's dense shape.</param>
            <param name="new_shape">Input to the operation: 1-D.  `R_out` vector with the requested new dense shape.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64): 2-D.  `N x R_out` matrix with the updated indices of non-empty values in the output SparseTensor.
            [1] output_shape(type: DtInt64): 1-D.  `R_out` vector with the full dense shape of the output SparseTensor.  This is the same as `new_shape` but with any -1 dimensions filled in.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayScatter(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="value">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayScatterV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Deprecated. Use TensorArrayScatterV3
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="value">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Betainc(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Compute the regularized incomplete beta integral \\(I_x(a, b)\\).
            </summary>
            <param name="a">Input to the operation. </param>
            <param name="b">Input to the operation. </param>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatchingFiles(Emgu.TF.Output,System.String)">
            <summary>
            Returns the set of files matching one or more glob patterns.
            </summary>
            <param name="pattern">Input to the operation: Shell wildcard pattern(s). Scalar or vector of type string.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] filenames(type: DtString): A vector of matching filenames.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Conv2DBackpropInput(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.Boolean,System.String,System.String)">
            <summary>
            Computes the gradients of convolution with respect to the input.
            </summary>
            <param name="input_sizes">Input to the operation: An integer vector representing the shape of `input`, where `input` is a 4-D `[batch, height, width, channels]` tensor.</param>
            <param name="filter">Input to the operation: 4-D with shape `[filter_height, filter_width, in_channels, out_channels]`.</param>
            <param name="out_backprop">Input to the operation: 4-D with shape `[batch, out_height, out_width, out_channels]`. Gradients w.r.t. the output of the convolution.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input of the convolution. Must be in the same order as the dimension specified with format.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="use_cudnn_on_gpu"></param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, in_height, in_width, in_channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, in_channels, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D with shape `[batch, in_height, in_width, in_channels]`.  Gradient w.r.t. the input of the convolution.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayConcatV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Int64[],System.String)">
            <summary>
            Deprecated. Use TensorArrayConcatV3
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="dtype"></param>
            <param name="element_shape_except0"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid).
            [1] lengths(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.OrderedMapClear(Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op removes all elements in the underlying container.
            </summary>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArraySplitV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Deprecated. Use TensorArraySplitV3
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="value">Input to the operation. </param>
            <param name="lengths">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] flow_out(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SqrtGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the gradient for the sqrt of `x` wrt its input.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArraySize(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArraySizeV2(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Deprecated. Use TensorArraySizeV3
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="flow_in">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorArrayCloseV2(Emgu.TF.Output,System.String)">
            <summary>
            Deprecated. Use TensorArrayCloseV3
            </summary>
            <param name="handle">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.BarrierInsertMany(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            For each key, assigns the respective value to the specified component.
            </summary>
            <param name="handle">Input to the operation: The handle to a barrier.</param>
            <param name="keys">Input to the operation: A one-dimensional tensor of keys, with length n.</param>
            <param name="values">Input to the operation: An any-dimensional tensor of values, which are associated with the respective keys. The 0th dimension must have length n.</param>
            <param name="component_index">The component of the barrier elements that is being assigned.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.BarrierTakeMany(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Boolean,System.Boolean,System.Int64,System.String)">
            <summary>
            Takes the given number of completed elements from a barrier.
            </summary>
            <param name="handle">Input to the operation: The handle to a barrier.</param>
            <param name="num_elements">Input to the operation: A single-element tensor containing the number of elements to take.</param>
            <param name="component_types">The type of each component in a value.</param>
            <param name="allow_small_batch">Allow to return less than num_elements items if barrier is already closed.</param>
            <param name="wait_for_incomplete"></param>
            <param name="timeout_ms">If the queue is empty, this operation will block for up to timeout_ms milliseconds. Note: This option is not supported yet.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] indices(type: DtInt64): A one-dimensional tensor of indices, with length num_elems. These indices refer to the batch in which the values were placed into the barrier (starting with MIN_LONG and increasing with each BarrierInsertMany).
            [1] keys(type: DtString): A one-dimensional tensor of keys, with length num_elements.
            [2] values(type: DtInvalid): One any-dimensional tensor per component in a barrier element. All values have length num_elements in the 0th dimension.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BarrierClose(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Closes the given barrier.
            </summary>
            <param name="handle">Input to the operation: The handle to a barrier.</param>
            <param name="cancel_pending_enqueues">If true, all pending enqueue requests that are blocked on the barrier's queue will be canceled. InsertMany will fail, even if no new key is introduced.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.BarrierIncompleteSize(Emgu.TF.Output,System.String)">
            <summary>
            Computes the number of incomplete elements in the given barrier.
            </summary>
            <param name="handle">Input to the operation: The handle to a barrier.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32): The number of incomplete elements (i.e. those with some of their value components not set) in the barrier.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.GetSessionHandle(Emgu.TF.Output,System.String)">
            <summary>
            Store the input tensor in the state of the current session.
            </summary>
            <param name="value">Input to the operation: The tensor to be stored.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtString): The handle for the tensor stored in the session state, represented as a string.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.GetSessionHandleV2(Emgu.TF.Output,System.String)">
            <summary>
            Store the input tensor in the state of the current session.
            </summary>
            <param name="value">Input to the operation: The tensor to be stored.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource): The handle for the tensor stored in the session state, represented as a ResourceHandle object.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatrixInverse(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the inverse of one or more square invertible matrices or their
            </summary>
            <param name="input">Input to the operation: Shape is `[..., M, M]`.</param>
            <param name="adjoint"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Shape is `[..., M, M]`.  @compatibility(numpy) Equivalent to np.linalg.inv @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.GetSessionTensor(Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Get the value of the tensor specified by its handle.
            </summary>
            <param name="handle">Input to the operation: The handle for a tensor stored in the session state.</param>
            <param name="dtype">The type of the output value.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid): The tensor for the given handle.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseToSparseSetOperation(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.Boolean,System.String)">
            <summary>
            Applies set operation along last dimension of 2 `SparseTensor` inputs.
            </summary>
            <param name="set1_indices">Input to the operation: 2D `Tensor`, indices of a `SparseTensor`. Must be in row-major order.</param>
            <param name="set1_values">Input to the operation: 1D `Tensor`, values of a `SparseTensor`. Must be in row-major order.</param>
            <param name="set1_shape">Input to the operation: 1D `Tensor`, shape of a `SparseTensor`. `set1_shape[0...n-1]` must be the same as `set2_shape[0...n-1]`, `set1_shape[n]` is the max set size across `0...n-1` dimensions.</param>
            <param name="set2_indices">Input to the operation: 2D `Tensor`, indices of a `SparseTensor`. Must be in row-major order.</param>
            <param name="set2_values">Input to the operation: 1D `Tensor`, values of a `SparseTensor`. Must be in row-major order.</param>
            <param name="set2_shape">Input to the operation: 1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must be the same as `set1_shape[0...n-1]`, `set2_shape[n]` is the max set size across `0...n-1` dimensions.</param>
            <param name="set_operation"></param>
            <param name="validate_indices"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] result_indices(type: DtInt64): 2D indices of a `SparseTensor`.
            [1] result_values(type: DtInvalid): 1D values of a `SparseTensor`.
            [2] result_shape(type: DtInt64): 1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is the same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]` is the max result set size across all `0...n-1` dimensions.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Select(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Selects elements from `t` or `e`, depending on `condition`.
            </summary>
            <param name="condition">Input to the operation. </param>
            <param name="t">Input to the operation: = A `Tensor` which may have the same shape as `condition`. If `condition` is rank 1, `t` may have higher rank, but its first dimension must match the size of `condition`.</param>
            <param name="e">Input to the operation: = A `Tensor` with the same type and shape as `t`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): = A `Tensor` with the same type and shape as `t` and `e`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Stage(Emgu.TF.Output,System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Stage values similar to a lightweight Enqueue.
            </summary>
            <param name="values">Input to the operation: a list of tensors dtypes A list of data types that inserted values should adhere to.</param>
            <param name="capacity">Maximum number of elements in the Staging Area. If &gt; 0, inserts on the container will block when the capacity is reached.</param>
            <param name="memory_limit">The maximum number of bytes allowed for Tensors in the Staging Area. If &gt; 0, inserts will block until sufficient space is available.</param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">It is necessary to match this name to the matching Unstage Op.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Unstage(Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op is similar to a lightweight Dequeue.
            </summary>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StagePeek(Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op peeks at the values at the specified index.  If the
            </summary>
            <param name="index">Input to the operation. </param>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StageSize(Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op returns the number of elements in the underlying container.
            </summary>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StageClear(Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op removes all elements in the underlying container.
            </summary>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.MapPeek(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op peeks at the values at the specified key.  If the
            </summary>
            <param name="key">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Asinh(Emgu.TF.Output,System.String)">
            <summary>
            Computes inverse hyperbolic sine of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SerializeSparse(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Serialize a `SparseTensor` into a string 3-vector (1-D `Tensor`) object.
            </summary>
            <param name="sparse_indices">Input to the operation: 2-D.  The `indices` of the `SparseTensor`.</param>
            <param name="sparse_values">Input to the operation: 1-D.  The `values` of the `SparseTensor`.</param>
            <param name="sparse_shape">Input to the operation: 1-D.  The `shape` of the `SparseTensor`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] serialized_sparse(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SelfAdjointEigV2(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the eigen decomposition of one or more square self-adjoint matrices.
            </summary>
            <param name="input">Input to the operation: `Tensor` input of shape `[N, N]`.</param>
            <param name="compute_v">If `True` then eigenvectors will be computed and returned in `v`. Otherwise, only the eigenvalues will be computed.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] e(type: DtInvalid): Eigenvalues. Shape is `[N]`.
            [1] v(type: DtInvalid): Eigenvectors. Shape is `[N, N]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MapStage(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Stage (key, values) in the underlying container which behaves like a hashtable.
            </summary>
            <param name="key">Input to the operation: int64</param>
            <param name="indices">Input to the operation. </param>
            <param name="values">Input to the operation: a list of tensors dtypes A list of data types that inserted values should adhere to.</param>
            <param name="dtypes"></param>
            <param name="capacity">Maximum number of elements in the Staging Area. If &gt; 0, inserts on the container will block when the capacity is reached.</param>
            <param name="memory_limit"></param>
            <param name="container">If non-empty, this queue is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">It is necessary to match this name to the matching Unstage Op.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableInsertV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Updates the table to associates keys with values.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="keys">Input to the operation: Any shape.  Keys to look up.</param>
            <param name="values">Input to the operation: Values to associate with keys.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.InvGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the gradient for the inverse of `x` wrt its input.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MapUnstage(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op removes and returns the values associated with the key
            </summary>
            <param name="key">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MapUnstageNoKey(Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op removes and returns a random (key, value)
            </summary>
            <param name="indices">Input to the operation. </param>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] key(type: DtInt64).
            [1] values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IteratorFromStringHandle(Emgu.TF.Output,System.String)">
            <summary>
            Converts the given string representing a handle to an iterator to a resource.
            </summary>
            <param name="string_handle">Input to the operation: A string representation of the given handle.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] resource_handle(type: DtResource): A handle to an iterator resource.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MapSize(Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op returns the number of elements in the underlying container.
            </summary>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MapIncompleteSize(Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op returns the number of incomplete elements in the underlying container.
            </summary>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Square(Emgu.TF.Output,System.String)">
            <summary>
            Computes square of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MapClear(Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op removes all elements in the underlying container.
            </summary>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterNdSub(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Applies sparse subtraction between `updates` and individual values or slices
            </summary>
            <param name="reference">Input to the operation: A mutable Tensor. Should be from a Variable node.</param>
            <param name="indices">Input to the operation: A Tensor. Must be one of the following types: int32, int64. A tensor of indices into ref.</param>
            <param name="updates">Input to the operation: A Tensor. Must have the same type as ref. A tensor of updated values to subtract from ref.</param>
            <param name="use_locking">An optional bool. Defaults to True. If True, the assignment will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): Same as ref. Returned as a convenience for operations that want to use the updated values after the update is done.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.OrderedMapUnstage(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op removes and returns the values associated with the key
            </summary>
            <param name="key">Input to the operation. </param>
            <param name="indices">Input to the operation. </param>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatrixSolve(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="matrix">Input to the operation. </param>
            <param name="rhs">Input to the operation. </param>
            <param name="adjoint"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ParseSingleSequenceExample(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],Emgu.TF.DataType[],System.Int64[][],Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors.
            </summary>
            <param name="serialized">Input to the operation: A scalar containing a binary serialized SequenceExample proto.</param>
            <param name="feature_list_dense_missing_assumed_empty">Input to the operation: A vector listing the FeatureList keys which may be missing from the SequenceExample.  If the associated FeatureList is missing, it is treated as empty.  By default, any FeatureList not listed in this vector must exist in the SequenceExample.</param>
            <param name="context_sparse_keys">Input to the operation: A list of Ncontext_sparse string Tensors (scalars). The keys expected in the Examples' features associated with context_sparse values.</param>
            <param name="context_dense_keys">Input to the operation: A list of Ncontext_dense string Tensors (scalars). The keys expected in the SequenceExamples' context features associated with dense values.</param>
            <param name="feature_list_sparse_keys">Input to the operation: A list of Nfeature_list_sparse string Tensors (scalars).  The keys expected in the FeatureLists associated with sparse values.</param>
            <param name="feature_list_dense_keys">Input to the operation: A list of Nfeature_list_dense string Tensors (scalars). The keys expected in the SequenceExamples' feature_lists associated with lists of dense values.</param>
            <param name="context_dense_defaults">Input to the operation: A list of Ncontext_dense Tensors (some may be empty). context_dense_defaults[j] provides default values when the SequenceExample's context map lacks context_dense_key[j]. If an empty Tensor is provided for context_dense_defaults[j], then the Feature context_dense_keys[j] is required. The input type is inferred from context_dense_defaults[j], even when it's empty.  If context_dense_defaults[j] is not empty, its shape must match context_dense_shapes[j].</param>
            <param name="debug_name">Input to the operation: A scalar containing the name of the serialized proto. May contain, for example, table key (descriptive) name for the corresponding serialized proto.  This is purely useful for debugging purposes, and the presence of values here has no effect on the output. May also be an empty scalar if no name is available.</param>
            <param name="context_sparse_types">A list of Ncontext_sparse types; the data types of data in each context Feature given in context_sparse_keys. Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList), DT_INT64 (Int64List), and DT_STRING (BytesList).</param>
            <param name="feature_list_dense_types"></param>
            <param name="context_dense_shapes">A list of Ncontext_dense shapes; the shapes of data in each context Feature given in context_dense_keys. The number of elements in the Feature corresponding to context_dense_key[j] must always equal context_dense_shapes[j].NumEntries(). The shape of context_dense_values[j] will match context_dense_shapes[j].</param>
            <param name="feature_list_sparse_types">A list of Nfeature_list_sparse types; the data types of data in each FeatureList given in feature_list_sparse_keys. Currently the ParseSingleSequenceExample supports DT_FLOAT (FloatList), DT_INT64 (Int64List), and DT_STRING (BytesList).</param>
            <param name="feature_list_dense_shapes">A list of Nfeature_list_dense shapes; the shapes of data in each FeatureList given in feature_list_dense_keys. The shape of each Feature in the FeatureList corresponding to feature_list_dense_key[j] must always equal feature_list_dense_shapes[j].NumEntries().</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] context_sparse_indices(type: DtInt64).
            [1] context_sparse_values(type: DtInvalid).
            [2] context_sparse_shapes(type: DtInt64).
            [3] context_dense_values(type: DtInvalid).
            [4] feature_list_sparse_indices(type: DtInt64).
            [5] feature_list_sparse_values(type: DtInvalid).
            [6] feature_list_sparse_shapes(type: DtInt64).
            [7] feature_list_dense_values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSparseMaximum(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the element-wise max of two SparseTensors.
            </summary>
            <param name="a_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, in the canonical lexicographic ordering.</param>
            <param name="a_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `a_indices`.</param>
            <param name="a_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="b_indices">Input to the operation: counterpart to `a_indices` for the other operand.</param>
            <param name="b_values">Input to the operation: counterpart to `a_values` for the other operand; must be of the same dtype.</param>
            <param name="b_shape">Input to the operation: counterpart to `a_shape` for the other operand; the two shapes must be equal.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64): 2-D.  The indices of the output SparseTensor.
            [1] output_values(type: DtInvalid): 1-D.  The values of the output SparseTensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.OrderedMapSize(Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op returns the number of elements in the underlying container.
            </summary>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MakeIterator(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Makes a new iterator from the given `dataset` and stores it in `iterator`.
            </summary>
            <param name="dataset">Input to the operation. </param>
            <param name="iterator">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyProximalGradientDescent(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Sparse update '*var' as FOBOS algorithm with fixed learning rate.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="alpha">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="use_locking">If True, the subtraction will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.OrderedMapIncompleteSize(Emgu.TF.DataType[],System.Int64,System.Int64,System.String,System.String,System.String)">
            <summary>
            Op returns the number of incomplete elements in the underlying container.
            </summary>
            <param name="dtypes"></param>
            <param name="capacity"></param>
            <param name="memory_limit"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt32).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IdentityReader(System.String,System.String,System.String)">
            <summary>
            A Reader that outputs the queued work as both the key and value.
            </summary>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtString): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorDataset(Emgu.TF.Output,System.Int64[][],System.String)">
            <summary>
            Creates a dataset that emits `components` as a tuple of tensors once.
            </summary>
            <param name="components">Input to the operation. </param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorSliceDataset(Emgu.TF.Output,System.Int64[][],System.String)">
            <summary>
            Creates a dataset that emits each dim-0 slice of `components` once.
            </summary>
            <param name="components">Input to the operation. </param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseTensorSliceDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Creates a dataset that splits a SparseTensor into elements row-wise.
            </summary>
            <param name="indices">Input to the operation. </param>
            <param name="values">Input to the operation. </param>
            <param name="dense_shape">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.InTopK(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Says whether the targets are in the top `K` predictions.
            </summary>
            <param name="predictions">Input to the operation: A `batch_size` x `classes` tensor.</param>
            <param name="targets">Input to the operation: A `batch_size` vector of class ids.</param>
            <param name="k">Number of top elements to look at for computing precision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] precision(type: DtBool): Computed Precision at `k` as a `bool Tensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ZipDataset(Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that zips together `input_datasets`.
            </summary>
            <param name="input_datasets">Input to the operation. </param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Igammac(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Compute the upper regularized incomplete Gamma function `Q(a, x)`.
            </summary>
            <param name="a">Input to the operation. </param>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SkipDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that skips `count` elements from the `input_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="count">Input to the operation: A scalar representing the number of elements from the `input_dataset` that should be skipped.  If count is -1, skips everything.</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyAdam(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the Adam algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="m">Input to the operation: Should be from a Variable().</param>
            <param name="v">Input to the operation: Should be from a Variable().</param>
            <param name="beta1_power">Input to the operation: Must be a scalar.</param>
            <param name="beta2_power">Input to the operation: Must be a scalar.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="beta1">Input to the operation: Momentum factor. Must be a scalar.</param>
            <param name="beta2">Input to the operation: Momentum factor. Must be a scalar.</param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If `True`, updating of the var, m, and v tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="use_nesterov">If `True`, uses the nesterov update.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.InitializeTableFromTextFile(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Int64,System.String,System.String)">
            <summary>
            Initializes a table from a text file.
            </summary>
            <param name="table_handle">Input to the operation: Handle to a table which will be initialized.</param>
            <param name="filename">Input to the operation: Filename of a vocabulary text file.</param>
            <param name="key_index">Column index in a line to get the table `key` values from.</param>
            <param name="value_index">Column index that represents information of a line to get the table `value` values from.</param>
            <param name="vocab_size">Number of elements of the file, use -1 if unknown.</param>
            <param name="delimiter">Delimiter to separate fields in a line.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.IgnoreErrorsDataset(Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that contains the elements of `input_dataset` ignoring errors.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FlatMapDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that applies `f` to the outputs of `input_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="other_arguments">Input to the operation. </param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyProximalGradientDescent(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Sparse update '*var' as FOBOS algorithm with fixed learning rate.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="alpha">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="use_locking">If True, the subtraction will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FilterDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset containing elements of `input_dataset` matching `predicate`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="other_arguments">Input to the operation: A list of tensors, typically values that were captured when building a closure for `predicate`.</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyAdagrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the adagrad scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that batches `batch_size` elements from `input_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="batch_size">Input to the operation: A scalar representing the number of elements to accumulate in a batch.</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IFFT3D(Emgu.TF.Output,System.String)">
            <summary>
            Inverse 3D fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A complex64 tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64): A complex64 tensor of the same shape as `input`. The inner-most 3   dimensions of `input` are replaced with their inverse 3D Fourier transform.  @compatibility(numpy) Equivalent to np.fft.ifftn with 3 dimensions. @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.PaddedBatchDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[][],System.String)">
            <summary>
            Creates a dataset that batches and pads `batch_size` elements from the input.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="batch_size">Input to the operation: A scalar representing the number of elements to accumulate in a batch.</param>
            <param name="padded_shapes">Input to the operation: A list of int64 tensors representing the desired padded shapes of the corresponding output components. These shapes may be partially specified, using `-1` to indicate that a particular dimension should be padded to the maximum size of all batch elements.</param>
            <param name="padding_values">Input to the operation: A list of scalars containing the padding value to use for each of the outputs.</param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RangeDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset with a range of values. Corresponds to python's xrange.
            </summary>
            <param name="start">Input to the operation: corresponds to start in python's xrange().</param>
            <param name="stop">Input to the operation: corresponds to stop in python's xrange().</param>
            <param name="step">Input to the operation: corresponds to step in python's xrange().</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CacheDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Creates a dataset that caches elements from `input_dataset`.
            </summary>
            <param name="input_dataset">Input to the operation. </param>
            <param name="filename">Input to the operation: A path on the filesystem where we should cache the dataset. Note: this will be a directory.</param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorSummaryV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Outputs a `Summary` protocol buffer with a tensor and per-plugin data.
            </summary>
            <param name="tag">Input to the operation: A string attached to this summary. Used for organization in TensorBoard.</param>
            <param name="tensor">Input to the operation: A tensor to serialize.</param>
            <param name="serialized_summary_metadata">Input to the operation: A serialized SummaryMetadata proto. Contains plugin data.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] summary(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TextLineDataset(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Creates a dataset that emits the lines of one or more text files.
            </summary>
            <param name="filenames">Input to the operation: A scalar or a vector containing the name(s) of the file(s) to be read.</param>
            <param name="compression_type">Input to the operation: A scalar containing either (i) the empty string (no compression), (ii) "ZLIB", or (iii) "GZIP".</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FixedLengthRecordDataset(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Creates a dataset that emits the records from one or more binary files.
            </summary>
            <param name="filenames">Input to the operation: A scalar or a vector containing the name(s) of the file(s) to be read.</param>
            <param name="header_bytes">Input to the operation: A scalar representing the number of bytes to skip at the beginning of a file.</param>
            <param name="record_bytes">Input to the operation: A scalar representing the number of bytes in each record.</param>
            <param name="footer_bytes">Input to the operation: A scalar representing the number of bytes to skip at the end of a file.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TFRecordDataset(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Creates a dataset that emits the records from one or more TFRecord files.
            </summary>
            <param name="filenames">Input to the operation: A scalar or vector containing the name(s) of the file(s) to be read.</param>
            <param name="compression_type">Input to the operation: A scalar containing either (i) the empty string (no compression), (ii) "ZLIB", or (iii) "GZIP".</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderReadUpTo(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns up to `num_records` (key, value) pairs produced by a Reader.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a `Reader`.</param>
            <param name="queue_handle">Input to the operation: Handle to a `Queue`, with string work items.</param>
            <param name="num_records">Input to the operation: number of records to read from `Reader`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] keys(type: DtString): A 1-D tensor.
            [1] values(type: DtString): A 1-D tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Iterator(System.String,System.String,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            A container for an iterator resource.
            </summary>
            <param name="shared_name"></param>
            <param name="container"></param>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource): A handle to the iterator that can be passed to a "MakeIterator" or "IteratorGetNext" op.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.OneShotIterator(Emgu.TF.DataType[],System.Int64[][],System.String,System.String,System.String)">
            <summary>
            Makes a "one-shot" iterator that can be iterated only once.
            </summary>
            <param name="output_types"></param>
            <param name="output_shapes"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] handle(type: DtResource): A handle to the iterator that can be passed to an "IteratorGetNext" op.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MaxPoolGradWithArgmax(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
            Computes gradients of the maxpooling function.
            </summary>
            <param name="input">Input to the operation: The original input.</param>
            <param name="grad">Input to the operation: 4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the output of `max_pool`.</param>
            <param name="argmax">Input to the operation: The indices of the maximum values chosen for each output of `max_pool`.</param>
            <param name="ksize">The size of the window for each dimension of the input tensor.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Gradients w.r.t. the input of `max_pool`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SdcaOptimizer(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.Single,System.Single,System.Int64,System.Int64,System.Boolean,System.String)">
            <summary>
            Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for
            </summary>
            <param name="sparse_example_indices">Input to the operation: a list of vectors which contain example indices.</param>
            <param name="sparse_feature_indices">Input to the operation: a list of vectors which contain feature indices.</param>
            <param name="sparse_feature_values">Input to the operation: a list of vectors which contains feature value associated with each feature group.</param>
            <param name="dense_features">Input to the operation: a list of matrices which contains the dense feature values.</param>
            <param name="example_weights">Input to the operation: a vector which contains the weight associated with each example.</param>
            <param name="example_labels">Input to the operation: a vector which contains the label/target associated with each example.</param>
            <param name="sparse_indices">Input to the operation: a list of vectors where each value is the indices which has corresponding weights in sparse_weights. This field maybe omitted for the dense approach.</param>
            <param name="sparse_weights">Input to the operation: a list of vectors where each value is the weight associated with a sparse feature group.</param>
            <param name="dense_weights">Input to the operation: a list of vectors where the values are the weights associated with a dense feature group.</param>
            <param name="example_state_data">Input to the operation: a list of vectors containing the example state data.</param>
            <param name="loss_type">Type of the primal loss. Currently SdcaSolver supports logistic, squared and hinge losses.</param>
            <param name="l1">Symmetric l1 regularization strength.</param>
            <param name="l2">Symmetric l2 regularization strength.</param>
            <param name="num_loss_partitions">Number of partitions of the global loss function.</param>
            <param name="num_inner_iterations">Number of iterations per mini-batch.</param>
            <param name="adaptative">Whether to use Adapative SDCA for the inner loop.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out_example_state_data(type: DtFloat): a list of vectors containing the updated example state data.
            [1] out_delta_sparse_weights(type: DtFloat): a list of vectors where each value is the delta weights associated with a sparse feature group.
            [2] out_delta_dense_weights(type: DtFloat): a list of vectors where the values are the delta weights associated with a dense feature group.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IteratorDispose(Emgu.TF.Output,System.String)">
            <summary>
            Releases any resources used by the given iterator.
            </summary>
            <param name="iterator">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedReluX(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Computes Quantized Rectified Linear X: `min(max(features, 0), max_value)`
            </summary>
            <param name="features">Input to the operation. </param>
            <param name="max_value">Input to the operation. </param>
            <param name="min_features">Input to the operation: The float value that the lowest quantized value represents.</param>
            <param name="max_features">Input to the operation: The float value that the highest quantized value represents.</param>
            <param name="out_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] activations(type: DtInvalid): Has the same output shape as "features".
            [1] min_activations(type: DtFloat): The float value that the lowest quantized value represents.
            [2] max_activations(type: DtFloat): The float value that the highest quantized value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResizeArea(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Resize `images` to `size` using area interpolation.
            </summary>
            <param name="images">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="size">Input to the operation: = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The new size for the images.</param>
            <param name="align_corners">If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] resized_images(type: DtFloat): 4-D with shape `[batch, new_height, new_width, channels]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResizeBicubic(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Resize `images` to `size` using bicubic interpolation.
            </summary>
            <param name="images">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="size">Input to the operation: = A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The new size for the images.</param>
            <param name="align_corners">If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] resized_images(type: DtFloat): 4-D with shape `[batch, new_height, new_width, channels]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResizeBilinearGrad(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the gradient of bilinear interpolation.
            </summary>
            <param name="grads">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="original_image">Input to the operation: 4-D with shape `[batch, orig_height, orig_width, channels]`, The image tensor that was resized.</param>
            <param name="align_corners">If true, rescale grads by (orig_height - 1) / (height - 1), which exactly aligns the 4 corners of grads and original_image. If false, rescale by orig_height / height. Treat similarly the width dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D with shape `[batch, orig_height, orig_width, channels]`. Gradients with respect to the input image. Input image must have been float or double.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RandomCrop(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Randomly crop `image`.
            </summary>
            <param name="image">Input to the operation: 3-D of shape `[height, width, channels]`.</param>
            <param name="size">Input to the operation: 1-D of length 2 containing: `crop_height`, `crop_width`..</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 3-D of shape `[crop_height, crop_width, channels].`
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Real(Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Returns the real part of a complex number.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="Tout"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DecodeJpeg(Emgu.TF.Output,System.Int64,System.Int64,System.Boolean,System.Boolean,System.Single,System.String,System.String)">
            <summary>
            Decode a JPEG-encoded image to a uint8 tensor.
            </summary>
            <param name="contents">Input to the operation: 0-D.  The JPEG-encoded image.</param>
            <param name="channels">Number of color channels for the decoded image.</param>
            <param name="ratio">Downscaling ratio.</param>
            <param name="fancy_upscaling">If true use a slower but nicer upscaling of the chroma planes (yuv420/422 only).</param>
            <param name="try_recover_truncated">If true try to recover an image from truncated input.</param>
            <param name="acceptable_fraction">The minimum required fraction of lines before a truncated input is accepted.</param>
            <param name="dct_method">string specifying a hint about the algorithm used for decompression.  Defaults to "" which maps to a system-specific default.  Currently valid values are ["INTEGER_FAST", "INTEGER_ACCURATE"].  The hint may be ignored (e.g., the internal jpeg library changes to a version that does not have that specific option.)</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] image(type: DtUint8): 3-D with shape `[height, width, channels]`..
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DepthwiseConv2dNativeBackpropInput(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes the gradients of depthwise convolution with respect to the input.
            </summary>
            <param name="input_sizes">Input to the operation: An integer vector representing the shape of `input`, based on `data_format`.  For example, if `data_format` is 'NHWC' then  `input` is a 4-D `[batch, height, width, channels]` tensor.</param>
            <param name="filter">Input to the operation: 4-D with shape `[filter_height, filter_width, in_channels, depthwise_multiplier]`.</param>
            <param name="out_backprop">Input to the operation: 4-D with shape  based on `data_format`. For example, if `data_format` is 'NHWC' then out_backprop shape is `[batch, out_height, out_width, out_channels]`. Gradients w.r.t. the output of the convolution.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input of the convolution.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, height, width, channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, channels, height, width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D with shape according to `data_format`.  For example, if `data_format` is 'NHWC', output shape is `[batch, in_height, in_width, in_channels]`.  Gradient w.r.t. the input of the convolution.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.EncodeJpeg(Emgu.TF.Output,System.String,System.Int64,System.Boolean,System.Boolean,System.Boolean,System.String,System.Int64,System.Int64,System.String,System.String)">
            <summary>
            JPEG-encode an image.
            </summary>
            <param name="image">Input to the operation: 3-D with shape `[height, width, channels]`.</param>
            <param name="format">Per pixel image format.</param>
            <param name="quality">Quality of the compression from 0 to 100 (higher is better and slower).</param>
            <param name="progressive">If True, create a JPEG that loads progressively (coarse to fine).</param>
            <param name="optimize_size">If True, spend CPU/RAM to reduce size with no quality change.</param>
            <param name="chroma_downsampling">See http://en.wikipedia.org/wiki/Chroma_subsampling.</param>
            <param name="density_unit">Unit used to specify `x_density` and `y_density`: pixels per inch (`'in'`) or centimeter (`'cm'`).</param>
            <param name="x_density">Horizontal pixels per density unit.</param>
            <param name="y_density">Vertical pixels per density unit.</param>
            <param name="xmp_metadata">If not empty, embed this XMP metadata in the image header.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] contents(type: DtString): 0-D. JPEG-encoded image.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AdjustContrast(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Deprecated. Disallowed in GraphDef version &gt;= 2.
            </summary>
            <param name="images">Input to the operation. </param>
            <param name="contrast_factor">Input to the operation. </param>
            <param name="min_value">Input to the operation. </param>
            <param name="max_value">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AdjustHue(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Adjust the hue of one or more images.
            </summary>
            <param name="images">Input to the operation: Images to adjust.  At least 3-D.</param>
            <param name="delta">Input to the operation: A float delta to add to the hue.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat): The hue-adjusted image or images.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AdjustSaturation(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Adjust the saturation of one or more images.
            </summary>
            <param name="images">Input to the operation: Images to adjust.  At least 3-D.</param>
            <param name="scale">Input to the operation: A float scale to add to the saturation.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat): The hue-adjusted image or images.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.EncodePng(Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            PNG-encode an image.
            </summary>
            <param name="image">Input to the operation: 3-D with shape `[height, width, channels]`.</param>
            <param name="compression">Compression level.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] contents(type: DtString): 0-D. PNG-encoded image.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DecodeGif(Emgu.TF.Output,System.String)">
            <summary>
            Decode the first frame of a GIF-encoded image to a uint8 tensor.
            </summary>
            <param name="contents">Input to the operation: 0-D.  The GIF-encoded image.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] image(type: DtUint8): 4-D with shape `[num_frames, height, width, 3]`. RGB order
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RGBToHSV(Emgu.TF.Output,System.String)">
            <summary>
            Converts one or more images from RGB to HSV.
            </summary>
            <param name="images">Input to the operation: 1-D or higher rank. RGB data to convert. Last dimension must be size 3.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): `images` converted to HSV.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.HSVToRGB(Emgu.TF.Output,System.String)">
            <summary>
            Convert one or more images from HSV to RGB.
            </summary>
            <param name="images">Input to the operation: 1-D or higher rank. HSV data to convert. Last dimension must be size 3.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): `images` converted to RGB.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DrawBoundingBoxes(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Draw bounding boxes on a batch of images.
            </summary>
            <param name="images">Input to the operation: 4-D with shape `[batch, height, width, depth]`. A batch of images.</param>
            <param name="boxes">Input to the operation: 3-D with shape `[batch, num_bounding_boxes, 4]` containing bounding boxes.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D with the same shape as `images`. The batch of input images with bounding boxes drawn on the images.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IdentityReaderV2(System.String,System.String,System.String)">
            <summary>
            A Reader that outputs the queued work as both the key and value.
            </summary>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtResource): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SampleDistortedBoundingBoxV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Single[],System.Single[],System.Int64,System.Boolean,System.String)">
            <summary>
            Generate a single randomly distorted bounding box for an image.
            </summary>
            <param name="image_size">Input to the operation: 1-D, containing `[height, width, channels]`.</param>
            <param name="bounding_boxes">Input to the operation: 3-D with shape `[batch, N, 4]` describing the N bounding boxes associated with the image.</param>
            <param name="min_object_covered">Input to the operation: The cropped area of the image must contain at least this fraction of any bounding box supplied. The value of this parameter should be non-negative. In the case of 0, the cropped area does not need to overlap any of the bounding boxes supplied.</param>
            <param name="seed">If either `seed` or `seed2` are set to non-zero, the random number generator is seeded by the given `seed`.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="aspect_ratio_range">The cropped area of the image must have an aspect ratio = width / height within this range.</param>
            <param name="area_range">The cropped area of the image must contain a fraction of the supplied image within in this range.</param>
            <param name="max_attempts">Number of attempts at generating a cropped region of the image of the specified constraints. After `max_attempts` failures, return the entire image.</param>
            <param name="use_image_if_no_bounding_boxes">Controls behavior if no bounding boxes supplied. If true, assume an implicit bounding box covering the whole input. If false, raise an error.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] begin(type: DtInvalid): 1-D, containing `[offset_height, offset_width, 0]`. Provide as input to `tf.slice`.
            [1] size(type: DtInvalid): 1-D, containing `[target_height, target_width, -1]`. Provide as input to `tf.slice`.
            [2] bboxes(type: DtFloat): 3-D with shape `[1, 1, 4]` containing the distorted bounding box. Provide as input to `tf.image.draw_bounding_boxes`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderSerializeState(Emgu.TF.Output,System.String)">
            <summary>
            Produce a string tensor that encodes the state of a Reader.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] state(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ExtractGlimpse(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            Extracts a glimpse from the input tensor.
            </summary>
            <param name="input">Input to the operation: A 4-D float tensor of shape `[batch_size, height, width, channels]`.</param>
            <param name="size">Input to the operation: A 1-D tensor of 2 elements containing the size of the glimpses to extract.  The glimpse height must be specified first, following by the glimpse width.</param>
            <param name="offsets">Input to the operation: A 2-D integer tensor of shape `[batch_size, 2]` containing the y, x locations of the center of each window.</param>
            <param name="centered">indicates if the offset coordinates are centered relative to the image, in which case the (0, 0) offset is relative to the center of the input images. If false, the (0,0) offset corresponds to the upper left corner of the input images.</param>
            <param name="normalized">indicates if the offset coordinates are normalized.</param>
            <param name="uniform_noise">indicates if the noise should be generated using a uniform distribution or a Gaussian distribution.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] glimpse(type: DtFloat): A tensor representing the glimpses `[batch_size, glimpse_height, glimpse_width, channels]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IsInf(Emgu.TF.Output,System.String)">
            <summary>
            Returns which elements of x are Inf.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CropAndResize(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.Single,System.String)">
            <summary>
            Extracts crops from the input image tensor and bilinearly resizes them (possibly
            </summary>
            <param name="image">Input to the operation: A 4-D tensor of shape `[batch, image_height, image_width, depth]`. Both `image_height` and `image_width` need to be positive.</param>
            <param name="boxes">Input to the operation: A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor specifies the coordinates of a box in the `box_ind[i]` image and is specified in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the `[0, 1]` interval of normalized image height is mapped to `[0, image_height - 1]` in image height coordinates. We do allow `y1` &gt; `y2`, in which case the sampled crop is an up-down flipped version of the original image. The width dimension is treated similarly. Normalized coordinates outside the `[0, 1]` range are allowed, in which case we use `extrapolation_value` to extrapolate the input image values.</param>
            <param name="box_ind">Input to the operation: A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`. The value of `box_ind[i]` specifies the image that the `i`-th box refers to.</param>
            <param name="crop_size">Input to the operation: A 1-D tensor of 2 elements, `size = [crop_height, crop_width]`. All cropped image patches are resized to this size. The aspect ratio of the image content is not preserved. Both `crop_height` and `crop_width` need to be positive.</param>
            <param name="method">A string specifying the interpolation method. Only 'bilinear' is supported for now.</param>
            <param name="extrapolation_value">Value used for extrapolation, when applicable.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] crops(type: DtFloat): A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SaveV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Saves tensors in V2 checkpoint format.
            </summary>
            <param name="prefix">Input to the operation: Must have a single element. The prefix of the V2 checkpoint to which we write the tensors.</param>
            <param name="tensor_names">Input to the operation: shape {N}. The names of the tensors to be saved.</param>
            <param name="shape_and_slices">Input to the operation: shape {N}.  The slice specs of the tensors to be saved. Empty strings indicate that they are non-partitioned tensors.</param>
            <param name="tensors">Input to the operation: `N` tensors to save.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.MutableHashTableOfTensorsV2(Emgu.TF.DataType,Emgu.TF.DataType,System.String,System.String,System.Boolean,System.Int64[],System.String)">
            <summary>
            Creates an empty hash table.
            </summary>
            <param name="key_dtype">Type of the table keys.</param>
            <param name="value_dtype">Type of the table values.</param>
            <param name="container">If non-empty, this table is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this table is shared under the given name across multiple sessions.</param>
            <param name="use_node_name_sharing"></param>
            <param name="value_shape"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] table_handle(type: DtResource): Handle to a table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CropAndResizeGradImage(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String,System.String)">
            <summary>
            Computes the gradient of the crop_and_resize op wrt the input image tensor.
            </summary>
            <param name="grads">Input to the operation: A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.</param>
            <param name="boxes">Input to the operation: A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor specifies the coordinates of a box in the `box_ind[i]` image and is specified in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the `[0, 1]` interval of normalized image height is mapped to `[0, image_height - 1] in image height coordinates. We do allow y1 &gt; y2, in which case the sampled crop is an up-down flipped version of the original image. The width dimension is treated similarly. Normalized coordinates outside the `[0, 1]` range are allowed, in which case we use `extrapolation_value` to extrapolate the input image values.</param>
            <param name="box_ind">Input to the operation: A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`. The value of `box_ind[i]` specifies the image that the `i`-th box refers to.</param>
            <param name="image_size">Input to the operation: A 1-D tensor with value `[batch, image_height, image_width, depth]` containing the original image size. Both `image_height` and `image_width` need to be positive.</param>
            <param name="T"></param>
            <param name="method">A string specifying the interpolation method. Only 'bilinear' is supported for now.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A 4-D tensor of shape `[batch, image_height, image_width, depth]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TFRecordReaderV2(System.String,System.String,System.String,System.String)">
            <summary>
            A Reader that outputs the records from a TensorFlow Records file.
            </summary>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="compression_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtResource): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.NonMaxSuppression(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Single,System.String)">
            <summary>
            Greedily selects a subset of bounding boxes in descending order of score,
            </summary>
            <param name="boxes">Input to the operation: A 2-D float tensor of shape `[num_boxes, 4]`.</param>
            <param name="scores">Input to the operation: A 1-D float tensor of shape `[num_boxes]` representing a single score corresponding to each box (each row of boxes).</param>
            <param name="max_output_size">Input to the operation: A scalar integer tensor representing the maximum number of boxes to be selected by non max suppression.</param>
            <param name="iou_threshold">A float representing the threshold for deciding whether boxes overlap too much with respect to IOU.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] selected_indices(type: DtInt32): A 1-D integer tensor of shape `[M]` representing the selected indices from the boxes tensor, where `M &lt;= max_output_size`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Atanh(Emgu.TF.Output,System.String)">
            <summary>
            Computes inverse hyperbolic tangent of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CropAndResizeGradBoxes(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.String)">
            <summary>
            Computes the gradient of the crop_and_resize op wrt the input boxes tensor.
            </summary>
            <param name="grads">Input to the operation: A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.</param>
            <param name="image">Input to the operation: A 4-D tensor of shape `[batch, image_height, image_width, depth]`. Both `image_height` and `image_width` need to be positive.</param>
            <param name="boxes">Input to the operation: A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor specifies the coordinates of a box in the `box_ind[i]` image and is specified in normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the `[0, 1]` interval of normalized image height is mapped to `[0, image_height - 1] in image height coordinates. We do allow y1 &gt; y2, in which case the sampled crop is an up-down flipped version of the original image. The width dimension is treated similarly. Normalized coordinates outside the `[0, 1]` range are allowed, in which case we use `extrapolation_value` to extrapolate the input image values.</param>
            <param name="box_ind">Input to the operation: A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`. The value of `box_ind[i]` specifies the image that the `i`-th box refers to.</param>
            <param name="method">A string specifying the interpolation method. Only 'bilinear' is supported for now.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat): A 2-D tensor of shape `[num_boxes, 4]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SquaredDifference(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns (x - y)(x - y) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RestoreV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.String)">
            <summary>
            Restores tensors from a V2 checkpoint.
            </summary>
            <param name="prefix">Input to the operation: Must have a single element.  The prefix of a V2 checkpoint.</param>
            <param name="tensor_names">Input to the operation: shape {N}.  The names of the tensors to be restored.</param>
            <param name="shape_and_slices">Input to the operation: shape {N}.  The slice specs of the tensors to be restored. Empty strings indicate that they are non-partitioned tensors.</param>
            <param name="dtypes">shape {N}.  The list of expected dtype for the tensors.  Must match those stored in the checkpoint.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] tensors(type: DtInvalid): shape {N}.  The restored tensors, whose shapes are read from the checkpoint directly.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Save(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Saves the input tensors to disk.
            </summary>
            <param name="filename">Input to the operation: Must have a single element. The name of the file to which we write the tensor.</param>
            <param name="tensor_names">Input to the operation: Shape `[N]`. The names of the tensors to be saved.</param>
            <param name="data">Input to the operation: `N` tensors to save.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.MutableHashTableOfTensors(Emgu.TF.DataType,Emgu.TF.DataType,System.String,System.String,System.Boolean,System.Int64[],System.String)">
            <summary>
            Creates an empty hash table.
            </summary>
            <param name="key_dtype">Type of the table keys.</param>
            <param name="value_dtype">Type of the table values.</param>
            <param name="container">If non-empty, this table is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this table is shared under the given name across multiple sessions.</param>
            <param name="use_node_name_sharing"></param>
            <param name="value_shape"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] table_handle(type: DtString): Handle to a table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Conv3DBackpropFilterV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes the gradients of 3-D convolution with respect to the filter.
            </summary>
            <param name="input">Input to the operation: Shape `[batch, depth, rows, cols, in_channels]`.</param>
            <param name="filter_sizes">Input to the operation: An integer vector representing the tensor shape of `filter`, where `filter` is a 5-D `[filter_depth, filter_height, filter_width, in_channels, out_channels]` tensor.</param>
            <param name="out_backprop">Input to the operation: Backprop signal of shape `[batch, out_depth, out_rows, out_cols, out_channels]`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">The data format of the input and output data. With the default format "NDHWC", the data is stored in the order of:     [batch, in_depth, in_height, in_width, in_channels]. Alternatively, the format could be "NCDHW", the data storage order is:     [batch, in_channels, in_depth, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Restore(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.Int64,System.String)">
            <summary>
            Restores a tensor from checkpoint files.
            </summary>
            <param name="file_pattern">Input to the operation: Must have a single element. The pattern of the files from which we read the tensor.</param>
            <param name="tensor_name">Input to the operation: Must have a single element. The name of the tensor to be restored.</param>
            <param name="dt">The type of the tensor to be restored.</param>
            <param name="preferred_shard">Index of file to open first if multiple files match `file_pattern`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] tensor(type: DtInvalid): The restored tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TopKV2(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Finds values and indices of the `k` largest elements for the last dimension.
            </summary>
            <param name="input">Input to the operation: 1-D or higher with last dimension at least `k`.</param>
            <param name="k">Input to the operation: 0-D.  Number of top elements to look for along the last dimension (along each row for matrices).</param>
            <param name="sorted">If true the resulting `k` elements will be sorted by the values in descending order.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid): The `k` largest elements along each last dimensional slice.
            [1] indices(type: DtInt32): The indices of `values` within the last dimension of `input`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ShardedFilename(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Generate a sharded filename. The filename is printf formatted as
            </summary>
            <param name="basename">Input to the operation. </param>
            <param name="shard">Input to the operation. </param>
            <param name="num_shards">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] filename(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ShardedFilespec(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Generate a glob pattern matching all sharded file names.
            </summary>
            <param name="basename">Input to the operation. </param>
            <param name="num_shards">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] filename(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BiasAdd(Emgu.TF.Output,Emgu.TF.Output,System.String,System.String)">
            <summary>
            Adds `bias` to `value`.
            </summary>
            <param name="value">Input to the operation: Any number of dimensions.</param>
            <param name="bias">Input to the operation: 1-D with size the last dimension of `value`.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the bias tensor will be added to the last dimension of the value tensor. Alternatively, the format could be "NCHW", the data storage order of:     [batch, in_channels, in_height, in_width]. The tensor will be added to "in_channels", the third-to-the-last     dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Broadcasted sum of `value` and `bias`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterMul(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Multiplies sparse updates into a variable reference.
            </summary>
            <param name="reference">Input to the operation: Should be from a `Variable` node.</param>
            <param name="indices">Input to the operation: A tensor of indices into the first dimension of `ref`.</param>
            <param name="updates">Input to the operation: A tensor of updated values to multiply to `ref`.</param>
            <param name="use_locking">If True, the operation will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): = Same as `ref`.  Returned as a convenience for operations that want to use the updated values after the update is done.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.WholeFileReader(System.String,System.String,System.String)">
            <summary>
            A Reader that outputs the entire contents of a file as a value.
            </summary>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtString): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSplit(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Split a `SparseTensor` into `num_split` tensors along one dimension.
            </summary>
            <param name="split_dim">Input to the operation: 0-D.  The dimension along which to split.  Must be in the range `[0, rank(shape))`.</param>
            <param name="indices">Input to the operation: 2-D tensor represents the indices of the sparse tensor.</param>
            <param name="values">Input to the operation: 1-D tensor represents the values of the sparse tensor.</param>
            <param name="shape">Input to the operation: 1-D. tensor represents the shape of the sparse tensor. output indices: A list of 1-D tensors represents the indices of the output sparse tensors.</param>
            <param name="num_split">The number of ways to split.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64).
            [1] output_values(type: DtInvalid): A list of 1-D tensors represents the values of the output sparse tensors.
            [2] output_shape(type: DtInt64): A list of 1-D tensors represents the shape of the output sparse tensors.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LMDBReader(System.String,System.String,System.String)">
            <summary>
            A Reader that outputs the records from a LMDB file.
            </summary>
            <param name="container">If non-empty, this reader is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this reader is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] reader_handle(type: DtString): The handle to reference the Reader.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderRead(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the next record (key, value pair) produced by a Reader.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="queue_handle">Input to the operation: Handle to a Queue, with string work items.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] key(type: DtString): A scalar.
            [1] value(type: DtString): A scalar.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderReadUpToV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns up to `num_records` (key, value) pairs produced by a Reader.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a `Reader`.</param>
            <param name="queue_handle">Input to the operation: Handle to a `Queue`, with string work items.</param>
            <param name="num_records">Input to the operation: number of records to read from `Reader`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] keys(type: DtString): A 1-D tensor.
            [1] values(type: DtString): A 1-D tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderNumRecordsProduced(Emgu.TF.Output,System.String)">
            <summary>
            Returns the number of records this Reader has produced.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] records_produced(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderNumWorkUnitsCompleted(Emgu.TF.Output,System.String)">
            <summary>
            Returns the number of work units this Reader has finished processing.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] units_completed(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderNumWorkUnitsCompletedV2(Emgu.TF.Output,System.String)">
            <summary>
            Returns the number of work units this Reader has finished processing.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] units_completed(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderSerializeStateV2(Emgu.TF.Output,System.String)">
            <summary>
            Produce a string tensor that encodes the state of a Reader.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] state(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderRestoreState(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Restore a reader to a previously saved state.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="state">Input to the operation: Result of a ReaderSerializeState of a Reader with type matching reader_handle.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ReaderReset(Emgu.TF.Output,System.String)">
            <summary>
            Restore a Reader to its initial clean state.
            </summary>
            <param name="reader_handle">Input to the operation: Handle to a Reader.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ReadFile(Emgu.TF.Output,System.String)">
            <summary>
            Reads and outputs the entire contents of the input filename.
            </summary>
            <param name="filename">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] contents(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Multinomial(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Draws samples from a multinomial distribution.
            </summary>
            <param name="logits">Input to the operation: 2-D Tensor with shape `[batch_size, num_classes]`.  Each slice `[i, :]` represents the unnormalized log probabilities for all classes.</param>
            <param name="num_samples">Input to the operation: 0-D.  Number of independent samples to draw for each row slice.</param>
            <param name="seed">If either seed or seed2 is set to be non-zero, the internal random number generator is seeded by the given seed.  Otherwise, a random seed is used.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInt64): 2-D Tensor with shape `[batch_size, num_samples]`.  Each slice `[i, :]` contains the drawn class labels with range `[0, num_classes)`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.WriteFile(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Writes contents to the file at input filename. Creates file and recursively
            </summary>
            <param name="filename">Input to the operation: scalar. The name of the file to which we write the contents.</param>
            <param name="contents">Input to the operation: scalar. The content to be written to the output file.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.IFFT2D(Emgu.TF.Output,System.String)">
            <summary>
            Inverse 2D fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A complex64 tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64): A complex64 tensor of the same shape as `input`. The inner-most 2   dimensions of `input` are replaced with their inverse 2D Fourier transform.  @compatibility(numpy) Equivalent to np.fft.ifft2 @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Cholesky(Emgu.TF.Output,System.String)">
            <summary>
            Computes the Cholesky decomposition of one or more square matrices.
            </summary>
            <param name="input">Input to the operation: Shape is `[..., M, M]`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Shape is `[..., M, M]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TopK(Emgu.TF.Output,System.Int64,System.Boolean,System.String)">
            <summary>
            Finds values and indices of the `k` largest elements for the last dimension.
            </summary>
            <param name="input">Input to the operation: 1-D or higher with last dimension at least `k`.</param>
            <param name="k">Number of top elements to look for along the last dimension (along each row for matrices).</param>
            <param name="sorted">If true the resulting `k` elements will be sorted by the values in descending order.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid): The `k` largest elements along each last dimensional slice.
            [1] indices(type: DtInt32): The indices of `values` within the last dimension of `input`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyAdadelta(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            var: Should be from a Variable().
            </summary>
            <param name="var">Input to the operation. </param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="accum_update">Input to the operation: : Should be from a Variable().</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay factor. Must be a scalar.</param>
            <param name="epsilon">Input to the operation: Constant factor. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DepthwiseConv2dNativeBackpropFilter(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes the gradients of depthwise convolution with respect to the filter.
            </summary>
            <param name="input">Input to the operation: 4-D with shape based on `data_format`.  For example, if `data_format` is 'NHWC' then `input` is a 4-D `[batch, in_height, in_width, in_channels]` tensor.</param>
            <param name="filter_sizes">Input to the operation: An integer vector representing the tensor shape of `filter`, where `filter` is a 4-D `[filter_height, filter_width, in_channels, depthwise_multiplier]` tensor.</param>
            <param name="out_backprop">Input to the operation: 4-D with shape  based on `data_format`. For example, if `data_format` is 'NHWC' then out_backprop shape is `[batch, out_height, out_width, out_channels]`. Gradients w.r.t. the output of the convolution.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input of the convolution.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, height, width, channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, channels, height, width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D with shape `[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t. the `filter` input of the convolution.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CholeskyGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the reverse mode backpropagated gradient of the Cholesky algorithm.
            </summary>
            <param name="l">Input to the operation: Output of batch Cholesky algorithm l = cholesky(A). Shape is `[..., M, M]`. Algorithm depends only on lower triangular part of the innermost matrices of this tensor.</param>
            <param name="grad">Input to the operation: df/dl where f is some scalar function. Shape is `[..., M, M]`. Algorithm depends only on lower triangular part of the innermost matrices of this tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Symmetrized version of df/dA . Shape is `[..., M, M]`
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SelfAdjointEig(Emgu.TF.Output,System.String)">
            <summary>
            Computes the Eigen Decomposition of a batch of square self-adjoint matrices.
            </summary>
            <param name="input">Input to the operation: Shape is `[..., M, M]`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Shape is `[..., M+1, M]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatrixSolve(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Solves systems of linear equations.
            </summary>
            <param name="matrix">Input to the operation: Shape is `[..., M, M]`.</param>
            <param name="rhs">Input to the operation: Shape is `[..., M, K]`.</param>
            <param name="adjoint">Boolean indicating whether to solve with `matrix` or its (block-wise) adjoint.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Shape is `[..., M, K]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatrixTriangularSolve(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Solves systems of linear equations with upper or lower triangular matrices by
            </summary>
            <param name="matrix">Input to the operation: Shape is `[..., M, M]`.</param>
            <param name="rhs">Input to the operation: Shape is `[..., M, K]`.</param>
            <param name="lower">Boolean indicating whether the innermost matrices in `matrix` are lower or upper triangular.</param>
            <param name="adjoint">Boolean indicating whether to solve with `matrix` or its (block-wise)          adjoint.  @compatibility(numpy) Equivalent to np.linalg.triangular_solve @end_compatibility</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Shape is `[..., M, K]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.CountUpTo(Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Increments 'ref' until it reaches 'limit'.
            </summary>
            <param name="reference">Input to the operation: Should be from a scalar `Variable` node.</param>
            <param name="limit">If incrementing ref would bring it above limit, instead generates an 'OutOfRange' error.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A copy of the input before increment. If nothing else modifies the input, the values produced will all be distinct.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Svd(Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Computes the singular value decompositions of one or more matrices.
            </summary>
            <param name="input">Input to the operation: A tensor of shape `[..., M, N]` whose inner-most 2 dimensions form matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.</param>
            <param name="compute_uv">If true, left and right singular vectors will be computed and returned in `u` and `v`, respectively. If false, `u` and `v` are not set and should never referenced.</param>
            <param name="full_matrices">If true, compute full-sized `u` and `v`. If false (the default), compute only the leading `P` singular vectors. Ignored if `compute_uv` is `False`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] s(type: DtInvalid): Singular values. Shape is `[..., P]`.
            [1] u(type: DtInvalid): Left singular vectors. If `full_matrices` is `False` then shape is `[..., M, P]`; if `full_matrices` is `True` then shape is `[..., M, M]`. Undefined if `compute_uv` is `False`.
            [2] v(type: DtInvalid): Left singular vectors. If `full_matrices` is `False` then shape is `[..., N, P]`. If `full_matrices` is `True` then shape is `[..., N, N]`. Undefined if `compute_uv` is false.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Exp(Emgu.TF.Output,System.String)">
            <summary>
            Computes exponential of x element-wise.  \\(y = e^x\\).
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RandomShuffle(Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Randomly shuffles a tensor along its first dimension.
            </summary>
            <param name="value">Input to the operation: The tensor to be shuffled.</param>
            <param name="seed">If either `seed` or `seed2` are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A tensor of same shape and type as `value`, shuffled along its first dimension.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Requantize(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Convert the quantized 'input' tensor into a lower-precision 'output', using the
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="input_min">Input to the operation: The float value that the minimum quantized input value represents.</param>
            <param name="input_max">Input to the operation: The float value that the maximum quantized input value represents.</param>
            <param name="requested_output_min">Input to the operation: The float value that the minimum quantized output value represents.</param>
            <param name="requested_output_max">Input to the operation: The float value that the maximum quantized output value represents.</param>
            <param name="out_type">The type of the output. Should be a lower bit depth than Tinput.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            [1] output_min(type: DtFloat): The requested_output_min value is copied into this output.
            [2] output_max(type: DtFloat): The requested_output_max value is copied into this output.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchSelfAdjointEig(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatrixDeterminant(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchCholeskyGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="l">Input to the operation. </param>
            <param name="grad">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatrixTriangularSolve(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="matrix">Input to the operation. </param>
            <param name="rhs">Input to the operation. </param>
            <param name="lower"></param>
            <param name="adjoint"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SoftsignGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes softsign gradients for a softsign operation.
            </summary>
            <param name="gradients">Input to the operation: The backpropagated gradients to the corresponding softsign operation.</param>
            <param name="features">Input to the operation: The features passed as input to the corresponding softsign operation.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] backprops(type: DtInvalid): The gradients: `gradients / (1 + abs(-features)) ** 2`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatrixSolveLs(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="matrix">Input to the operation. </param>
            <param name="rhs">Input to the operation. </param>
            <param name="l2_regularizer">Input to the operation. </param>
            <param name="fast"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableImport(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Replaces the contents of the table with the specified keys and values.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="keys">Input to the operation: Any shape.  Keys to look up.</param>
            <param name="values">Input to the operation: Values to associate with keys.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.IsNan(Emgu.TF.Output,System.String)">
            <summary>
            Returns which elements of x are NaN.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchSvd(Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="compute_uv"></param>
            <param name="full_matrices"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] s(type: DtInvalid).
            [1] u(type: DtInvalid).
            [2] v(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableFind(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Looks up keys in a table, outputs the corresponding values.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="keys">Input to the operation: Any shape.  Keys to look up.</param>
            <param name="default_value">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] values(type: DtInvalid): Same shape as `keys`.  Values found in the table, or `default_values` for missing keys.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableInsert(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Updates the table to associates keys with values.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="keys">Input to the operation: Any shape.  Keys to look up.</param>
            <param name="values">Input to the operation: Values to associate with keys.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableSize(Emgu.TF.Output,System.String)">
            <summary>
            Computes the number of elements in the given table.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt64): Scalar that contains number of elements in the table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableSizeV2(Emgu.TF.Output,System.String)">
            <summary>
            Computes the number of elements in the given table.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] size(type: DtInt64): Scalar that contains number of elements in the table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableExport(Emgu.TF.Output,Emgu.TF.DataType,Emgu.TF.DataType,System.String)">
            <summary>
            Outputs all keys and values in the table.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="Tkeys"></param>
            <param name="Tvalues"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] keys(type: DtInvalid): Vector of all keys present in the table.
            [1] values(type: DtInvalid): Tensor of all values in the table. Indexed in parallel with `keys`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LookupTableImportV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Replaces the contents of the table with the specified keys and values.
            </summary>
            <param name="table_handle">Input to the operation: Handle to the table.</param>
            <param name="keys">Input to the operation: Any shape.  Keys to look up.</param>
            <param name="values">Input to the operation: Values to associate with keys.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.AssignAddVariableOp(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Adds a value to the current value of a variable.
            </summary>
            <param name="resource">Input to the operation: handle to the resource in which to store the variable.</param>
            <param name="value">Input to the operation: the value by which the variable will be incremented.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.HashTable(Emgu.TF.DataType,Emgu.TF.DataType,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Creates a non-initialized hash table.
            </summary>
            <param name="key_dtype">Type of the table keys.</param>
            <param name="value_dtype">Type of the table values.</param>
            <param name="container">If non-empty, this table is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this table is shared under the given name across multiple sessions.</param>
            <param name="use_node_name_sharing">If true and shared_name is empty, the table is shared using the node name.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] table_handle(type: DtString): Handle to a table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Sqrt(Emgu.TF.Output,System.String)">
            <summary>
            Computes square root of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.HashTableV2(Emgu.TF.DataType,Emgu.TF.DataType,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Creates a non-initialized hash table.
            </summary>
            <param name="key_dtype">Type of the table keys.</param>
            <param name="value_dtype">Type of the table values.</param>
            <param name="container">If non-empty, this table is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this table is shared under the given name across multiple sessions.</param>
            <param name="use_node_name_sharing">If true and shared_name is empty, the table is shared using the node name.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] table_handle(type: DtResource): Handle to a table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MutableHashTableV2(Emgu.TF.DataType,Emgu.TF.DataType,System.String,System.String,System.Boolean,System.String)">
            <summary>
            Creates an empty hash table.
            </summary>
            <param name="key_dtype">Type of the table keys.</param>
            <param name="value_dtype">Type of the table values.</param>
            <param name="container">If non-empty, this table is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this table is shared under the given name across multiple sessions.</param>
            <param name="use_node_name_sharing">If true and shared_name is empty, the table is shared using the node name.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] table_handle(type: DtResource): Handle to a table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MutableDenseHashTable(Emgu.TF.Output,Emgu.TF.DataType,System.String,System.String,System.Boolean,System.Int64[],System.Int64,System.Single,System.String)">
            <summary>
            Creates an empty hash table that uses tensors as the backing store.
            </summary>
            <param name="empty_key">Input to the operation: The key used to represent empty key buckets internally. Must not be used in insert or lookup operations.</param>
            <param name="value_dtype">Type of the table values.</param>
            <param name="container">If non-empty, this table is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this table is shared under the given name across multiple sessions.</param>
            <param name="use_node_name_sharing"></param>
            <param name="value_shape">The shape of each value.</param>
            <param name="initial_num_buckets">The initial number of hash table buckets. Must be a power to 2.</param>
            <param name="max_load_factor">The maximum ratio between number of entries and number of buckets before growing the table. Must be between 0 and 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] table_handle(type: DtString): Handle to a table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MutableDenseHashTableV2(Emgu.TF.Output,Emgu.TF.DataType,System.String,System.String,System.Boolean,System.Int64[],System.Int64,System.Single,System.String)">
            <summary>
            Creates an empty hash table that uses tensors as the backing store.
            </summary>
            <param name="empty_key">Input to the operation: The key used to represent empty key buckets internally. Must not be used in insert or lookup operations.</param>
            <param name="value_dtype">Type of the table values.</param>
            <param name="container">If non-empty, this table is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this table is shared under the given name across multiple sessions.</param>
            <param name="use_node_name_sharing"></param>
            <param name="value_shape">The shape of each value.</param>
            <param name="initial_num_buckets">The initial number of hash table buckets. Must be a power to 2.</param>
            <param name="max_load_factor">The maximum ratio between number of entries and number of buckets before growing the table. Must be between 0 and 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] table_handle(type: DtResource): Handle to a table.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.InitializeTableFromTextFileV2(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.Int64,System.String,System.String)">
            <summary>
            Initializes a table from a text file.
            </summary>
            <param name="table_handle">Input to the operation: Handle to a table which will be initialized.</param>
            <param name="filename">Input to the operation: Filename of a vocabulary text file.</param>
            <param name="key_index">Column index in a line to get the table `key` values from.</param>
            <param name="value_index">Column index that represents information of a line to get the table `value` values from.</param>
            <param name="vocab_size">Number of elements of the file, use -1 if unknown.</param>
            <param name="delimiter">Delimiter to separate fields in a line.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Tanh(Emgu.TF.Output,System.String)">
            <summary>
            Computes hyperbolic tangent of `x` element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Assert(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Asserts that the given condition is true.
            </summary>
            <param name="condition">Input to the operation: The condition to evaluate.</param>
            <param name="data">Input to the operation: The tensors to print out when condition is false.</param>
            <param name="summarize">Print this many entries of each tensor.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Print(Emgu.TF.Output,Emgu.TF.Output,System.String,System.Int64,System.Int64,System.String)">
            <summary>
            Prints a list of tensors.
            </summary>
            <param name="input">Input to the operation: The tensor passed to `output`</param>
            <param name="data">Input to the operation: A list of tensors to print out when op is evaluated.</param>
            <param name="message">A string, prefix of the error message.</param>
            <param name="first_n">Only log `first_n` number of times. -1 disables logging.</param>
            <param name="summarize">Only print this many entries of each tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): = The unmodified `input` tensor
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TensorSummary(Emgu.TF.Output,System.String,System.String,System.String)">
            <summary>
            Outputs a `Summary` protocol buffer with a tensor.
            </summary>
            <param name="tensor">Input to the operation: A tensor to serialize.</param>
            <param name="description">A json-encoded SummaryDescription proto.</param>
            <param name="display_name">An unused string.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] summary(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.HistogramSummary(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Outputs a `Summary` protocol buffer with a histogram.
            </summary>
            <param name="tag">Input to the operation: Scalar.  Tag to use for the `Summary.Value`.</param>
            <param name="values">Input to the operation: Any shape. Values to use to build the histogram.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] summary(type: DtString): Scalar. Serialized `Summary` protocol buffer.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AudioSummaryV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Outputs a `Summary` protocol buffer with audio.
            </summary>
            <param name="tag">Input to the operation: Scalar. Used to build the `tag` attribute of the summary values.</param>
            <param name="tensor">Input to the operation: 2-D of shape `[batch_size, frames]`.</param>
            <param name="sample_rate">Input to the operation: The sample rate of the signal in hertz.</param>
            <param name="max_outputs">Max number of batch elements to generate audio for.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] summary(type: DtString): Scalar. Serialized `Summary` protocol buffer.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AudioSummary(Emgu.TF.Output,Emgu.TF.Output,System.Single,System.Int64,System.String)">
            <summary>
            Outputs a `Summary` protocol buffer with audio.
            </summary>
            <param name="tag">Input to the operation: Scalar. Used to build the `tag` attribute of the summary values.</param>
            <param name="tensor">Input to the operation: 2-D of shape `[batch_size, frames]`.</param>
            <param name="sample_rate">The sample rate of the signal in hertz.</param>
            <param name="max_outputs">Max number of batch elements to generate audio for.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] summary(type: DtString): Scalar. Serialized `Summary` protocol buffer.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MergeSummary(Emgu.TF.Output,System.String)">
            <summary>
            Merges summaries.
            </summary>
            <param name="inputs">Input to the operation: Can be of any shape.  Each must contain serialized `Summary` protocol buffers.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] summary(type: DtString): Scalar. Serialized `Summary` protocol buffer.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IFFT(Emgu.TF.Output,System.String)">
            <summary>
            Inverse fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A complex64 tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64): A complex64 tensor of the same shape as `input`. The inner-most   dimension of `input` is replaced with its inverse 1D Fourier transform.  @compatibility(numpy) Equivalent to np.fft.ifft @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FFT2D(Emgu.TF.Output,System.String)">
            <summary>
            2D fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A complex64 tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64): A complex64 tensor of the same shape as `input`. The inner-most 2   dimensions of `input` are replaced with their 2D Fourier transform.  @compatibility(numpy) Equivalent to np.fft.fft2 @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FFT3D(Emgu.TF.Output,System.String)">
            <summary>
            3D fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A complex64 tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64): A complex64 tensor of the same shape as `input`. The inner-most 3   dimensions of `input` are replaced with their 3D Fourier transform.  @compatibility(numpy) Equivalent to np.fft.fftn with 3 dimensions. @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RFFT(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Real-valued fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A float32 tensor.</param>
            <param name="fft_length">Input to the operation: An int32 tensor of shape [1]. The FFT length.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64): A complex64 tensor of the same rank as `input`. The inner-most   dimension of `input` is replaced with the `fft_length / 2 + 1` unique   frequency components of its 1D Fourier transform.  @compatibility(numpy) Equivalent to np.fft.rfft @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IRFFT(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Inverse real-valued fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A complex64 tensor.</param>
            <param name="fft_length">Input to the operation: An int32 tensor of shape [1]. The FFT length.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat): A float32 tensor of the same rank as `input`. The inner-most   dimension of `input` is replaced with the `fft_length` samples of its inverse   1D Fourier transform.  @compatibility(numpy) Equivalent to np.fft.irfft @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RFFT2D(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            2D real-valued fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A float32 tensor.</param>
            <param name="fft_length">Input to the operation: An int32 tensor of shape [2]. The FFT length for each dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64): A complex64 tensor of the same rank as `input`. The inner-most 2   dimensions of `input` are replaced with their 2D Fourier transform. The   inner-most dimension contains `fft_length / 2 + 1` unique frequency   components.  @compatibility(numpy) Equivalent to np.fft.rfft2 @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IRFFT3D(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Inverse 3D real-valued fast Fourier transform.
            </summary>
            <param name="input">Input to the operation: A complex64 tensor.</param>
            <param name="fft_length">Input to the operation: An int32 tensor of shape [3]. The FFT length for each dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtFloat): A float32 tensor of the same rank as `input`. The inner-most 3   dimensions of `input` are replaced with the `fft_length` samples of their   inverse 3D real Fourier transform.  @compatibility(numpy) Equivalent to np.irfftn with 3 dimensions. @end_compatibility
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MaxPoolWithArgmax(Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Performs max pooling on the input and outputs both max values and indices.
            </summary>
            <param name="input">Input to the operation: 4-D with shape `[batch, height, width, channels]`.  Input to pool over.</param>
            <param name="ksize">The size of the window for each dimension of the input tensor.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="Targmax"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The max pooled output tensor.
            [1] argmax(type: DtInvalid): 4-D.  The flattened indices of the max values chosen for each output.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchFFT2D(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchIFFT2D(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchFFT3D(Emgu.TF.Output,System.String)">
            <summary>
            
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtComplex64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ParseExample(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType[],System.Int64[][],System.String)">
            <summary>
            Transforms a vector of brain.Example protos (as strings) into typed tensors.
            </summary>
            <param name="serialized">Input to the operation: A vector containing a batch of binary serialized Example protos.</param>
            <param name="names">Input to the operation: A vector containing the names of the serialized protos. May contain, for example, table key (descriptive) names for the corresponding serialized protos.  These are purely useful for debugging purposes, and the presence of values here has no effect on the output. May also be an empty vector if no names are available. If non-empty, this vector must be the same length as "serialized".</param>
            <param name="sparse_keys">Input to the operation: A list of Nsparse string Tensors (scalars). The keys expected in the Examples' features associated with sparse values.</param>
            <param name="dense_keys">Input to the operation: A list of Ndense string Tensors (scalars). The keys expected in the Examples' features associated with dense values.</param>
            <param name="dense_defaults">Input to the operation: A list of Ndense Tensors (some may be empty). dense_defaults[j] provides default values when the example's feature_map lacks dense_key[j].  If an empty Tensor is provided for dense_defaults[j], then the Feature dense_keys[j] is required. The input type is inferred from dense_defaults[j], even when it's empty. If dense_defaults[j] is not empty, and dense_shapes[j] is fully defined, then the shape of dense_defaults[j] must match that of dense_shapes[j]. If dense_shapes[j] has an undefined major dimension (variable strides dense feature), dense_defaults[j] must contain a single element: the padding element.</param>
            <param name="sparse_types">A list of Nsparse types; the data types of data in each Feature given in sparse_keys. Currently the ParseExample supports DT_FLOAT (FloatList), DT_INT64 (Int64List), and DT_STRING (BytesList).</param>
            <param name="dense_shapes">A list of Ndense shapes; the shapes of data in each Feature given in dense_keys. The number of elements in the Feature corresponding to dense_key[j] must always equal dense_shapes[j].NumEntries(). If dense_shapes[j] == (D0, D1, ..., DN) then the shape of output Tensor dense_values[j] will be (|serialized|, D0, D1, ..., DN): The dense outputs are just the inputs row-stacked by batch. This works for dense_shapes[j] = (-1, D1, ..., DN).  In this case the shape of the output Tensor dense_values[j] will be (|serialized|, M, D1, .., DN), where M is the maximum number of blocks of elements of length D1 * .... * DN, across all minibatch entries in the input.  Any minibatch entry with less than M blocks of elements of length D1 * ... * DN will be padded with the corresponding default_value scalar element along the second dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sparse_indices(type: DtInt64).
            [1] sparse_values(type: DtInvalid).
            [2] sparse_shapes(type: DtInt64).
            [3] dense_values(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StringToNumber(Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Converts each string in the input Tensor to the specified numeric type.
            </summary>
            <param name="string_tensor">Input to the operation. </param>
            <param name="out_type">The numeric type to interpret each string in `string_tensor` as.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A Tensor of the same shape as the input `string_tensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RemoteFusedGraphExecute(Emgu.TF.Output,Emgu.TF.DataType[],System.String,System.String)">
            <summary>
            Execute a sub graph on a remote processor.
            </summary>
            <param name="inputs">Input to the operation: Arbitrary number of tensors with arbitrary data types</param>
            <param name="Toutputs"></param>
            <param name="serialized_remote_fused_graph_execute_info">Serialized protocol buffer of RemoteFusedGraphExecuteInfo which contains graph specifications.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] outputs(type: DtInvalid): Arbitrary number of tensors with arbitrary data types
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterDiv(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Divides a variable reference by sparse updates.
            </summary>
            <param name="reference">Input to the operation: Should be from a `Variable` node.</param>
            <param name="indices">Input to the operation: A tensor of indices into the first dimension of `ref`.</param>
            <param name="updates">Input to the operation: A tensor of values that `ref` is divided by.</param>
            <param name="use_locking">If True, the operation will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): = Same as `ref`.  Returned as a convenience for operations that want to use the updated values after the update is done.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.L2Loss(Emgu.TF.Output,System.String)">
            <summary>
            L2 Loss.
            </summary>
            <param name="t">Input to the operation: Typically 2-D, but may have any dimensions.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 0-D.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DestroyResourceOp(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Deletes the resource specified by the handle.
            </summary>
            <param name="resource">Input to the operation: handle to the resource to delete.</param>
            <param name="ignore_lookup_error">whether to ignore the error when the resource doesn't exist.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyFtrlV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update relevant entries in '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="linear">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 shrinkage regulariation. Must be a scalar.</param>
            <param name="l2_shrinkage">Input to the operation. </param>
            <param name="lr_power">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Cumsum(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Compute the cumulative sum of the tensor `x` along `axis`.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="axis">Input to the operation. </param>
            <param name="exclusive"></param>
            <param name="reverse"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchNormWithGlobalNormalization(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Single,System.Boolean,System.String)">
            <summary>
            Batch normalization.
            </summary>
            <param name="t">Input to the operation: A 4D input Tensor.</param>
            <param name="m">Input to the operation: A 1D mean Tensor with size matching the last dimension of t. This is the first output from tf.nn.moments, or a saved moving average thereof.</param>
            <param name="v">Input to the operation: A 1D variance Tensor with size matching the last dimension of t. This is the second output from tf.nn.moments, or a saved moving average thereof.</param>
            <param name="beta">Input to the operation: A 1D beta Tensor with size matching the last dimension of t. An offset to be added to the normalized tensor.</param>
            <param name="gamma">Input to the operation: A 1D gamma Tensor with size matching the last dimension of t. If "scale_after_normalization" is true, this tensor will be multiplied with the normalized tensor.</param>
            <param name="variance_epsilon">A small float number to avoid dividing by 0.</param>
            <param name="scale_after_normalization">A bool indicating whether the resulted tensor needs to be multiplied with gamma.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] result(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Conj(Emgu.TF.Output,System.String)">
            <summary>
            Returns the complex conjugate of a complex number.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AssignVariableOp(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Assigns a new value to a variable.
            </summary>
            <param name="resource">Input to the operation: handle to the resource in which to store the variable.</param>
            <param name="value">Input to the operation: the value to set the new tensor to use.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ReduceJoin(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String,System.String)">
            <summary>
            Joins a string Tensor across the given dimensions.
            </summary>
            <param name="inputs">Input to the operation: The input to be joined.  All reduced indices must have non-zero size.</param>
            <param name="reduction_indices">Input to the operation: The dimensions to reduce over.  Dimensions are reduced in the order specified.  Omitting `reduction_indices` is equivalent to passing `[n-1, n-2, ..., 0]`.  Negative indices from `-n` to `-1` are supported.</param>
            <param name="keep_dims">If `True`, retain reduced dimensions with length `1`.</param>
            <param name="separator">The separator to use when joining.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtString): Has shape equal to that of the input with reduced dimensions removed or set to `1` depending on `keep_dims`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SdcaFprint(Emgu.TF.Output,System.String)">
            <summary>
            Computes fingerprints of the input strings.
            </summary>
            <param name="input">Input to the operation: vector of strings to compute fingerprints on.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInt64): a (N,2) shaped matrix where N is the number of elements in the input vector. Each row contains the low and high parts of the fingerprint.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DenseToSparseSetOperation(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.Boolean,System.String)">
            <summary>
            Applies set operation along last dimension of `Tensor` and `SparseTensor`.
            </summary>
            <param name="set1">Input to the operation: `Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`. Dimension `n` contains values in a set, duplicates are allowed but ignored.</param>
            <param name="set2_indices">Input to the operation: 2D `Tensor`, indices of a `SparseTensor`. Must be in row-major order.</param>
            <param name="set2_values">Input to the operation: 1D `Tensor`, values of a `SparseTensor`. Must be in row-major order.</param>
            <param name="set2_shape">Input to the operation: 1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must be the same as the 1st `n-1` dimensions of `set1`, `result_shape[n]` is the max set size across `n-1` dimensions.</param>
            <param name="set_operation"></param>
            <param name="validate_indices"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] result_indices(type: DtInt64): 2D indices of a `SparseTensor`.
            [1] result_values(type: DtInvalid): 1D values of a `SparseTensor`.
            [2] result_shape(type: DtInt64): 1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is the same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]` is the max result set size across all `0...n-1` dimensions.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AvgPool(Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Performs average pooling on the input.
            </summary>
            <param name="value">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="ksize">The size of the sliding window for each dimension of `value`.</param>
            <param name="strides">The stride of the sliding window for each dimension of `value`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, in_height, in_width, in_channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, in_channels, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The average pooled output tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchNormWithGlobalNormalizationGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Single,System.Boolean,System.String)">
            <summary>
            Gradients for batch normalization.
            </summary>
            <param name="t">Input to the operation: A 4D input Tensor.</param>
            <param name="m">Input to the operation: A 1D mean Tensor with size matching the last dimension of t. This is the first output from tf.nn.moments, or a saved moving average thereof.</param>
            <param name="v">Input to the operation: A 1D variance Tensor with size matching the last dimension of t. This is the second output from tf.nn.moments, or a saved moving average thereof.</param>
            <param name="gamma">Input to the operation: A 1D gamma Tensor with size matching the last dimension of t. If "scale_after_normalization" is true, this Tensor will be multiplied with the normalized Tensor.</param>
            <param name="backprop">Input to the operation: 4D backprop Tensor.</param>
            <param name="variance_epsilon">A small float number to avoid dividing by 0.</param>
            <param name="scale_after_normalization">A bool indicating whether the resulted tensor needs to be multiplied with gamma.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] dx(type: DtInvalid): 4D backprop tensor for input.
            [1] dm(type: DtInvalid): 1D backprop tensor for mean.
            [2] dv(type: DtInvalid): 1D backprop tensor for variance.
            [3] db(type: DtInvalid): 1D backprop tensor for beta.
            [4] dg(type: DtInvalid): 1D backprop tensor for gamma.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BiasAddGrad(Emgu.TF.Output,System.String,System.String)">
            <summary>
            The backward operation for "BiasAdd" on the "bias" tensor.
            </summary>
            <param name="out_backprop">Input to the operation: Any number of dimensions.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the bias tensor will be added to the last dimension of the value tensor. Alternatively, the format could be "NCHW", the data storage order of:     [batch, in_channels, in_height, in_width]. The tensor will be added to "in_channels", the third-to-the-last     dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 1-D with size the feature dimension of `out_backprop`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BiasAddV1(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Adds `bias` to `value`.
            </summary>
            <param name="value">Input to the operation: Any number of dimensions.</param>
            <param name="bias">Input to the operation: 1-D with size the last dimension of `value`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Broadcasted sum of `value` and `bias`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Conv2D(Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.Boolean,System.String,System.String)">
            <summary>
            Computes a 2-D convolution given 4-D `input` and `filter` tensors.
            </summary>
            <param name="input">Input to the operation: A 4-D tensor. The dimension order is interpreted according to the value of `data_format`, see below for details.</param>
            <param name="filter">Input to the operation: A 4-D tensor of shape `[filter_height, filter_width, in_channels, out_channels]`</param>
            <param name="strides">1-D tensor of length 4.  The stride of the sliding window for each dimension of `input`. The dimension order is determined by the value of   `data_format`, see below for details.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="use_cudnn_on_gpu"></param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, height, width, channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, channels, height, width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A 4-D tensor. The dimension order is determined by the value of `data_format`, see below for details.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSoftmax(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Applies softmax to a batched N-D `SparseTensor`.
            </summary>
            <param name="sp_indices">Input to the operation: 2-D.  `NNZ x R` matrix with the indices of non-empty values in a SparseTensor, in canonical ordering.</param>
            <param name="sp_values">Input to the operation: 1-D.  `NNZ` non-empty values corresponding to `sp_indices`.</param>
            <param name="sp_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 1-D.  The `NNZ` values for the result `SparseTensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Conv2DBackpropFilter(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.Boolean,System.String,System.String)">
            <summary>
            Computes the gradients of convolution with respect to the filter.
            </summary>
            <param name="input">Input to the operation: 4-D with shape `[batch, in_height, in_width, in_channels]`.</param>
            <param name="filter_sizes">Input to the operation: An integer vector representing the tensor shape of `filter`, where `filter` is a 4-D `[filter_height, filter_width, in_channels, out_channels]` tensor.</param>
            <param name="out_backprop">Input to the operation: 4-D with shape `[batch, out_height, out_width, out_channels]`. Gradients w.r.t. the output of the convolution.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input of the convolution. Must be in the same order as the dimension specified with format.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="use_cudnn_on_gpu"></param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, in_height, in_width, in_channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, in_channels, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D with shape `[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t. the `filter` input of the convolution.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FusedResizeAndPadConv2D(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.Int64[],System.String,System.Boolean,System.String)">
            <summary>
            Performs a resize and padding as a preprocess during a convolution.
            </summary>
            <param name="input">Input to the operation: 4-D with shape `[batch, in_height, in_width, in_channels]`.</param>
            <param name="size">Input to the operation: A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The new size for the images.</param>
            <param name="paddings">Input to the operation: A two-column matrix specifying the padding sizes. The number of rows must be the same as the rank of `input`.</param>
            <param name="filter">Input to the operation: 4-D with shape `[filter_height, filter_width, in_channels, out_channels]`.</param>
            <param name="mode"></param>
            <param name="strides">1-D of length 4.  The stride of the sliding window for each dimension of `input`. Must be in the same order as the dimension specified with format.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="resize_align_corners">If true, rescale input by (new_height - 1) / (height - 1), which exactly aligns the 4 corners of images and resized images. If false, rescale by new_height / height. Treat similarly the width dimension.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseDenseCwiseMul(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Component-wise multiplies a SparseTensor by a dense Tensor.
            </summary>
            <param name="sp_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, possibly not in canonical ordering.</param>
            <param name="sp_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `sp_indices`.</param>
            <param name="sp_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="dense">Input to the operation: `R`-D.  The dense Tensor operand.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 1-D.  The `N` values that are operated on.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FusedPadConv2D(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.Int64[],System.String,System.String)">
            <summary>
            Performs a padding as a preprocess during a convolution.
            </summary>
            <param name="input">Input to the operation: 4-D with shape `[batch, in_height, in_width, in_channels]`.</param>
            <param name="paddings">Input to the operation: A two-column matrix specifying the padding sizes. The number of rows must be the same as the rank of `input`.</param>
            <param name="filter">Input to the operation: 4-D with shape `[filter_height, filter_width, in_channels, out_channels]`.</param>
            <param name="mode"></param>
            <param name="strides">1-D of length 4.  The stride of the sliding window for each dimension of `input`. Must be in the same order as the dimension specified with format.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LogSoftmax(Emgu.TF.Output,System.String)">
            <summary>
            Computes log softmax activations.
            </summary>
            <param name="logits">Input to the operation: 2-D with shape `[batch_size, num_classes]`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] logsoftmax(type: DtInvalid): Same shape as `logits`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DepthwiseConv2dNative(Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="filter">Input to the operation. </param>
            <param name="strides">1-D of length 4.  The stride of the sliding window for each dimension of `input`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, height, width, channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, channels, height, width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TruncateDiv(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns x / y element-wise for integer types.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Conv3DBackpropInput(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.String)">
            <summary>
            Computes the gradients of 3-D convolution with respect to the input.
            </summary>
            <param name="input">Input to the operation: Shape `[batch, depth, rows, cols, in_channels]`.</param>
            <param name="filter">Input to the operation: Shape `[depth, rows, cols, in_channels, out_channels]`. `in_channels` must match between `input` and `filter`.</param>
            <param name="out_backprop">Input to the operation: Backprop signal of shape `[batch, out_depth, out_rows, out_cols, out_channels]`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyAdagradDA(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update entries in '*var' and '*accum' according to the proximal adagrad scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="gradient_accumulator">Input to the operation: Should be from a Variable().</param>
            <param name="gradient_squared_accumulator">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="global_step">Input to the operation: Training step number. Must be a scalar.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Conv3DBackpropInputV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes the gradients of 3-D convolution with respect to the input.
            </summary>
            <param name="input_sizes">Input to the operation: An integer vector representing the tensor shape of `input`, where `input` is a 5-D `[batch, depth, rows, cols, in_channels]` tensor.</param>
            <param name="filter">Input to the operation: Shape `[depth, rows, cols, in_channels, out_channels]`. `in_channels` must match between `input` and `filter`.</param>
            <param name="out_backprop">Input to the operation: Backprop signal of shape `[batch, out_depth, out_rows, out_cols, out_channels]`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">The data format of the input and output data. With the default format "NDHWC", the data is stored in the order of:     [batch, in_depth, in_height, in_width, in_channels]. Alternatively, the format could be "NCDHW", the data storage order is:     [batch, in_channels, in_depth, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Expm1(Emgu.TF.Output,System.String)">
            <summary>
            Computes exponential of x - 1 element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MaxPool3DGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes gradients of max pooling function.
            </summary>
            <param name="orig_input">Input to the operation: The original input tensor.</param>
            <param name="orig_output">Input to the operation: The original output tensor.</param>
            <param name="grad">Input to the operation: Output backprop of shape `[batch, depth, rows, cols, channels]`.</param>
            <param name="ksize">1-D tensor of length 5. The size of the window for each dimension of the input tensor. Must have `ksize[0] = ksize[4] = 1`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">The data format of the input and output data. With the default format "NDHWC", the data is stored in the order of:     [batch, in_depth, in_height, in_width, in_channels]. Alternatively, the format could be "NCDHW", the data storage order is:     [batch, in_channels, in_depth, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MaxPool3DGradGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes second-order gradients of the maxpooling function.
            </summary>
            <param name="orig_input">Input to the operation: The original input tensor.</param>
            <param name="orig_output">Input to the operation: The original output tensor.</param>
            <param name="grad">Input to the operation: Output backprop of shape `[batch, depth, rows, cols, channels]`.</param>
            <param name="ksize">1-D tensor of length 5. The size of the window for each dimension of the input tensor. Must have `ksize[0] = ksize[4] = 1`.</param>
            <param name="strides">1-D tensor of length 5. The stride of the sliding window for each dimension of `input`. Must have `strides[0] = strides[4] = 1`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">The data format of the input and output data. With the default format "NDHWC", the data is stored in the order of:     [batch, in_depth, in_height, in_width, in_channels]. Alternatively, the format could be "NCDHW", the data storage order is:     [batch, in_channels, in_depth, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Gradients of gradients w.r.t. the input to `max_pool`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LRN(Emgu.TF.Output,System.Int64,System.Single,System.Single,System.Single,System.String)">
            <summary>
            Local Response Normalization.
            </summary>
            <param name="input">Input to the operation: 4-D.</param>
            <param name="depth_radius">0-D.  Half-width of the 1-D normalization window.</param>
            <param name="bias">An offset (usually positive to avoid dividing by 0).</param>
            <param name="alpha">A scale factor, usually positive.</param>
            <param name="beta">An exponent.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SegmentMean(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the mean along segments of a tensor.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="segment_ids">Input to the operation: A 1-D tensor whose rank is equal to the rank of `data`'s first dimension.  Values should be sorted and can be repeated.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for dimension 0 which has size `k`, the number of segments.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LRNGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Single,System.Single,System.Single,System.String)">
            <summary>
            Gradients for Local Response Normalization.
            </summary>
            <param name="input_grads">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="input_image">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="output_image">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="depth_radius">A depth radius.</param>
            <param name="bias">An offset (usually &gt; 0 to avoid dividing by 0).</param>
            <param name="alpha">A scale factor, usually positive.</param>
            <param name="beta">An exponent.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The gradients for LRN.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MaxPoolGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String,System.String)">
            <summary>
            Computes gradients of the maxpooling function.
            </summary>
            <param name="orig_input">Input to the operation: The original input tensor.</param>
            <param name="orig_output">Input to the operation: The original output tensor.</param>
            <param name="grad">Input to the operation: 4-D.  Gradients w.r.t. the output of `max_pool`.</param>
            <param name="ksize">The size of the window for each dimension of the input tensor.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="data_format">Specify the data format of the input and output data. With the default format "NHWC", the data is stored in the order of:     [batch, in_height, in_width, in_channels]. Alternatively, the format could be "NCHW", the data storage order of:     [batch, in_channels, in_height, in_width].</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Gradients w.r.t. the input to `max_pool`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MaxPoolGradGradWithArgmax(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
            Computes second-order gradients of the maxpooling function.
            </summary>
            <param name="input">Input to the operation: The original input.</param>
            <param name="grad">Input to the operation: 4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the input of `max_pool`.</param>
            <param name="argmax">Input to the operation: The indices of the maximum values chosen for each output of `max_pool`.</param>
            <param name="ksize">The size of the window for each dimension of the input tensor.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Gradients of gradients w.r.t. the input of `max_pool`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Dilation2D(Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
            Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.
            </summary>
            <param name="input">Input to the operation: 4-D with shape `[batch, in_height, in_width, depth]`.</param>
            <param name="filter">Input to the operation: 3-D with shape `[filter_height, filter_width, depth]`.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor. Must be: `[1, stride_height, stride_width, 1]`.</param>
            <param name="rates">The input stride for atrous morphological dilation. Must be: `[1, rate_height, rate_width, 1]`.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 4-D with shape `[batch, out_height, out_width, depth]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Neg(Emgu.TF.Output,System.String)">
            <summary>
            Computes numerical negative value element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Relu(Emgu.TF.Output,System.String)">
            <summary>
            Computes rectified linear: `max(features, 0)`.
            </summary>
            <param name="features">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] activations(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Elu(Emgu.TF.Output,System.String)">
            <summary>
            Computes exponential linear: `exp(features) - 1` if &lt; 0, `features` otherwise.
            </summary>
            <param name="features">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] activations(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Erfc(Emgu.TF.Output,System.String)">
            <summary>
            Computes the complementary error function of `x` element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Softmax(Emgu.TF.Output,System.String)">
            <summary>
            Computes softmax activations.
            </summary>
            <param name="logits">Input to the operation: 2-D with shape `[batch_size, num_classes]`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] softmax(type: DtInvalid): Same shape as `logits`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ReciprocalGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the gradient for the inverse of `x` wrt its input.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedRelu(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Computes Quantized Rectified Linear: `max(features, 0)`
            </summary>
            <param name="features">Input to the operation. </param>
            <param name="min_features">Input to the operation: The float value that the lowest quantized value represents.</param>
            <param name="max_features">Input to the operation: The float value that the highest quantized value represents.</param>
            <param name="out_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] activations(type: DtInvalid): Has the same output shape as "features".
            [1] min_activations(type: DtFloat): The float value that the lowest quantized value represents.
            [2] max_activations(type: DtFloat): The float value that the highest quantized value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedMul(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Returns x * y element-wise, working on quantized buffers.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="min_x">Input to the operation: The float value that the lowest quantized `x` value represents.</param>
            <param name="max_x">Input to the operation: The float value that the highest quantized `x` value represents.</param>
            <param name="min_y">Input to the operation: The float value that the lowest quantized `y` value represents.</param>
            <param name="max_y">Input to the operation: The float value that the highest quantized `y` value represents.</param>
            <param name="Toutput"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            [1] min_z(type: DtFloat): The float value that the lowest quantized output value represents.
            [2] max_z(type: DtFloat): The float value that the highest quantized output value represents.  *NOTE*: `QuantizedMul` supports limited forms of broadcasting. More about broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SoftmaxCrossEntropyWithLogits(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes softmax cross entropy cost and gradients to backpropagate.
            </summary>
            <param name="features">Input to the operation: batch_size x num_classes matrix</param>
            <param name="labels">Input to the operation: batch_size x num_classes matrix The caller must ensure that each batch of labels represents a valid probability distribution.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] loss(type: DtInvalid): Per example loss (batch_size vector).
            [1] backprop(type: DtInvalid): backpropagated gradients (batch_size x num_classes matrix).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSoftmaxCrossEntropyWithLogits(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes softmax cross entropy cost and gradients to backpropagate.
            </summary>
            <param name="features">Input to the operation: batch_size x num_classes matrix</param>
            <param name="labels">Input to the operation: batch_size vector with values in [0, num_classes). This is the label for the given minibatch entry.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] loss(type: DtInvalid): Per example loss (batch_size vector).
            [1] backprop(type: DtInvalid): backpropagated gradients (batch_size x num_classes matrix).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FractionalAvgPool(Emgu.TF.Output,System.Single[],System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Int64,System.String)">
            <summary>
            Performs fractional average pooling on the input.
            </summary>
            <param name="value">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="pooling_ratio">Pooling ratio for each dimension of `value`, currently only supports row and col dimension and should be &gt;= 1.0. For example, a valid pooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't allow pooling on batch and channels dimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions respectively.</param>
            <param name="pseudo_random">When set to True, generates the pooling sequence in a pseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for difference between pseudorandom and random.</param>
            <param name="overlapping">When set to True, it means when pooling, the values at the boundary of adjacent pooling cells are used by both cells. For example:  `index  0  1  2  3  4`  `value  20 5  16 3  7`  If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [41/3, 26/3] for fractional avg pooling.</param>
            <param name="deterministic">When set to True, a fixed pooling region will be used when iterating over a FractionalAvgPool node in the computation graph. Mainly used in unit test to make FractionalAvgPool deterministic.</param>
            <param name="seed">If either seed or seed2 are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">An second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): output tensor after fractional avg pooling.
            [1] row_pooling_sequence(type: DtInt64): row pooling sequence, needed to calculate gradient.
            [2] col_pooling_sequence(type: DtInt64): column pooling sequence, needed to calculate gradient.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedAvgPool(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64[],System.String,System.String)">
            <summary>
            Produces the average pool of the input tensor for quantized types.
            </summary>
            <param name="input">Input to the operation: 4-D with shape `[batch, height, width, channels]`.</param>
            <param name="min_input">Input to the operation: The float value that the lowest quantized input value represents.</param>
            <param name="max_input">Input to the operation: The float value that the highest quantized input value represents.</param>
            <param name="ksize">The size of the window for each dimension of the input tensor. The length must be 4 to match the number of dimensions of the input.</param>
            <param name="strides">The stride of the sliding window for each dimension of the input tensor.  The length must be 4 to match the number of dimensions of the input.</param>
            <param name="padding">The type of padding algorithm to use.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            [1] min_output(type: DtFloat): The float value that the lowest quantized output value represents.
            [2] max_output(type: DtFloat): The float value that the highest quantized output value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedBiasAdd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Adds Tensor 'bias' to Tensor 'input' for Quantized types.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="bias">Input to the operation: A 1D bias Tensor with size matching the last dimension of 'input'.</param>
            <param name="min_input">Input to the operation: The float value that the lowest quantized input value represents.</param>
            <param name="max_input">Input to the operation: The float value that the highest quantized input value represents.</param>
            <param name="min_bias">Input to the operation: The float value that the lowest quantized bias value represents.</param>
            <param name="max_bias">Input to the operation: The float value that the highest quantized bias value represents.</param>
            <param name="out_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            [1] min_out(type: DtFloat): The float value that the lowest quantized output value represents.
            [2] max_out(type: DtFloat): The float value that the highest quantized output value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedRelu6(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Computes Quantized Rectified Linear 6: `min(max(features, 0), 6)`
            </summary>
            <param name="features">Input to the operation. </param>
            <param name="min_features">Input to the operation: The float value that the lowest quantized value represents.</param>
            <param name="max_features">Input to the operation: The float value that the highest quantized value represents.</param>
            <param name="out_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] activations(type: DtInvalid): Has the same output shape as "features".
            [1] min_activations(type: DtFloat): The float value that the lowest quantized value represents.
            [2] max_activations(type: DtFloat): The float value that the highest quantized value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BatchMatMul(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Multiplies slices of two tensors in batches.
            </summary>
            <param name="x">Input to the operation: 2-D or higher with shape `[..., r_x, c_x]`.</param>
            <param name="y">Input to the operation: 2-D or higher with shape `[..., r_y, c_y]`.</param>
            <param name="adj_x">If `True`, adjoint the slices of `x`. Defaults to `False`.</param>
            <param name="adj_y">If `True`, adjoint the slices of `y`. Defaults to `False`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 3-D or higher with shape `[..., r_o, c_o]`
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Cast(Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Cast x of type SrcT to y of DstT.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="DstT"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Abs(Emgu.TF.Output,System.String)">
            <summary>
            Computes the absolute value of a tensor.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Reciprocal(Emgu.TF.Output,System.String)">
            <summary>
            Computes the reciprocal of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RsqrtGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the gradient for the rsqrt of `x` wrt its input.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Log1p(Emgu.TF.Output,System.String)">
            <summary>
            Computes natural logarithm of (1 + x) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Cosh(Emgu.TF.Output,System.String)">
            <summary>
            Computes hyperbolic cosine of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Acosh(Emgu.TF.Output,System.String)">
            <summary>
            Computes inverse hyperbolic cosine of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StatelessRandomUniform(Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Outputs deterministic pseudorandom random values from a uniform distribution.
            </summary>
            <param name="shape">Input to the operation: The shape of the output tensor.</param>
            <param name="seed">Input to the operation: 2 seeds (shape [2]).</param>
            <param name="dtype">The type of the output.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Random values with specified shape.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TanhGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the gradient for the tanh of `x` wrt its input.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Digamma(Emgu.TF.Output,System.String)">
            <summary>
            Computes Psi, the derivative of Lgamma (the log of the absolute value of
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SigmoidGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the gradient of the sigmoid of `x` wrt its input.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RandomStandardNormal(Emgu.TF.Output,Emgu.TF.DataType,System.Int64,System.Int64,System.String)">
            <summary>
            Outputs random values from a normal distribution.
            </summary>
            <param name="shape">Input to the operation: The shape of the output tensor.</param>
            <param name="dtype">The type of the output.</param>
            <param name="seed">If either `seed` or `seed2` are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A tensor of the specified shape filled with random normal values.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Cos(Emgu.TF.Output,System.String)">
            <summary>
            Computes cos of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RequantizationRange(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Given a quantized tensor described by (input, input_min, input_max), outputs a
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="input_min">Input to the operation: The float value that the minimum quantized input value represents.</param>
            <param name="input_max">Input to the operation: The float value that the maximum quantized input value represents.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_min(type: DtFloat): The computed min output.
            [1] output_max(type: DtFloat): the computed max output.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Asin(Emgu.TF.Output,System.String)">
            <summary>
            Computes asin of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Acos(Emgu.TF.Output,System.String)">
            <summary>
            Computes acos of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Atan(Emgu.TF.Output,System.String)">
            <summary>
            Computes atan of x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IsFinite(Emgu.TF.Output,System.String)">
            <summary>
            Returns which elements of x are finite.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Add(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns x + y element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Sub(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns x - y element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Mul(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns x * y element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.FloorDiv(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns x // y element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterSub(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Subtracts sparse updates to a variable reference.
            </summary>
            <param name="reference">Input to the operation: Should be from a `Variable` node.</param>
            <param name="indices">Input to the operation: A tensor of indices into the first dimension of `ref`.</param>
            <param name="updates">Input to the operation: A tensor of updated values to subtract from `ref`.</param>
            <param name="use_locking">If True, the subtraction will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): = Same as `ref`.  Returned as a convenience for operations that want to use the updated values after the update is done.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Maximum(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the max of x and y (i.e. x &gt; y ? x : y) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Minimum(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the min of x and y (i.e. x &lt; y ? x : y) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Mod(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns element-wise remainder of division. This emulates C semantics in that
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Pow(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the power of one value to another.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Igamma(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Compute the lower regularized incomplete Gamma function `Q(a, x)`.
            </summary>
            <param name="a">Input to the operation. </param>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyGradientDescent(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' by subtracting 'alpha' * 'delta' from it.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="alpha">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="delta">Input to the operation: The change.</param>
            <param name="use_locking">If `True`, the subtraction will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Zeta(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Compute the Hurwitz zeta function \\(\zeta(x, q)\\).
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="q">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Polygamma(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Compute the polygamma function \\(\psi^{(n)}(x)\\).
            </summary>
            <param name="a">Input to the operation. </param>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Atan2(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes arctangent of `y/x` element-wise, respecting signs of the arguments.
            </summary>
            <param name="y">Input to the operation. </param>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterAdd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Adds sparse updates to a variable reference.
            </summary>
            <param name="reference">Input to the operation: Should be from a `Variable` node.</param>
            <param name="indices">Input to the operation: A tensor of indices into the first dimension of `ref`.</param>
            <param name="updates">Input to the operation: A tensor of updated values to add to `ref`.</param>
            <param name="use_locking">If True, the addition will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): = Same as `ref`.  Returned as a convenience for operations that want to use the updated values after the update is done.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Less(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the truth value of (x &lt; y) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LessEqual(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the truth value of (x &lt;= y) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Greater(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the truth value of (x &gt; y) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyGradientDescent(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' by subtracting 'alpha' * 'delta' from it.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="alpha">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="delta">Input to the operation: The change.</param>
            <param name="use_locking">If `True`, the subtraction will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Equal(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the truth value of (x == y) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LinSpace(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Generates values in an interval.
            </summary>
            <param name="start">Input to the operation: First entry in the range.</param>
            <param name="stop">Input to the operation: Last entry in the range.</param>
            <param name="num">Input to the operation: Number of values to generate.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 1-D. The generated values.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.NotEqual(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the truth value of (x != y) element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Variable(System.Int64[],Emgu.TF.DataType,System.String,System.String,System.String)">
            <summary>
            Use VariableV2 instead.
            </summary>
            <param name="shape"></param>
            <param name="dtype"></param>
            <param name="container"></param>
            <param name="shared_name"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] ref(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LogicalNot(Emgu.TF.Output,System.String)">
            <summary>
            Returns the truth value of NOT x element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LogicalAnd(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the truth value of x AND y element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.LogicalOr(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the truth value of x OR y element-wise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StringToHashBucketFast(Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Converts each string in the input Tensor to its hash mod by a number of buckets.
            </summary>
            <param name="input">Input to the operation: The strings to assign a hash bucket.</param>
            <param name="num_buckets">The number of buckets.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInt64): A Tensor of the same shape as the input `string_tensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.MatMul(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Multiply the matrix "a" by the matrix "b".
            </summary>
            <param name="a">Input to the operation. </param>
            <param name="b">Input to the operation. </param>
            <param name="transpose_a">If true, "a" is transposed before multiplication.</param>
            <param name="transpose_b">If true, "b" is transposed before multiplication.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] product(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Sum(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the sum of elements across dimensions of a tensor.
            </summary>
            <param name="input">Input to the operation: The tensor to reduce.</param>
            <param name="reduction_indices">Input to the operation: The dimensions to reduce.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The reduced tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Mean(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the mean of elements across dimensions of a tensor.
            </summary>
            <param name="input">Input to the operation: The tensor to reduce.</param>
            <param name="reduction_indices">Input to the operation: The dimensions to reduce.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The reduced tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseFillEmptyRowsGrad(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            The gradient of SparseFillEmptyRows.
            </summary>
            <param name="reverse_index_map">Input to the operation: 1-D.  The reverse index map from SparseFillEmptyRows.</param>
            <param name="grad_values">Input to the operation: 1-D.  The gradients from backprop.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] d_values(type: DtInvalid): 1-D.  The backprop into values.
            [1] d_default_value(type: DtInvalid): 0-D.  The backprop into default_value.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Prod(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the product of elements across dimensions of a tensor.
            </summary>
            <param name="input">Input to the operation: The tensor to reduce.</param>
            <param name="reduction_indices">Input to the operation: The dimensions to reduce.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The reduced tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Max(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the maximum of elements across dimensions of a tensor.
            </summary>
            <param name="input">Input to the operation: The tensor to reduce.</param>
            <param name="reduction_indices">Input to the operation: The dimensions to reduce.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): The reduced tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ArgMax(Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Returns the index with the largest value across dimensions of a tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="dimension">Input to the operation: int32 or int64, 0 &lt;= dimension &lt; rank(input).  Describes which dimension of the input Tensor to reduce across. For vectors, use dimension = 0.</param>
            <param name="output_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ArgMin(Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Returns the index with the smallest value across dimensions of a tensor.
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="dimension">Input to the operation: int32 or int64, 0 &lt;= dimension &lt; rank(input).  Describes which dimension of the input Tensor to reduce across. For vectors, use dimension = 0.</param>
            <param name="output_type"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SegmentMin(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the minimum along segments of a tensor.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="segment_ids">Input to the operation: A 1-D tensor whose rank is equal to the rank of `data`'s first dimension.  Values should be sorted and can be repeated.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for dimension 0 which has size `k`, the number of segments.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SegmentMax(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the maximum along segments of a tensor.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="segment_ids">Input to the operation: A 1-D tensor whose rank is equal to the rank of `data`'s first dimension.  Values should be sorted and can be repeated.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for dimension 0 which has size `k`, the number of segments.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.UnsortedSegmentSum(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the sum along segments of a tensor.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="segment_ids">Input to the operation: A tensor whose shape is a prefix of `data.shape`.</param>
            <param name="num_segments">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for the first `segment_ids.rank` dimensions, which are replaced with a single dimension which has size `num_segments`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSegmentSum(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the sum along sparse segments of a tensor.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="indices">Input to the operation: A 1-D tensor. Has same rank as `segment_ids`.</param>
            <param name="segment_ids">Input to the operation: A 1-D tensor. Values should be sorted and can be repeated.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for dimension 0 which has size `k`, the number of segments.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSegmentMean(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the mean along sparse segments of a tensor.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="indices">Input to the operation: A 1-D tensor. Has same rank as `segment_ids`.</param>
            <param name="segment_ids">Input to the operation: A 1-D tensor. Values should be sorted and can be repeated.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for dimension 0 which has size `k`, the number of segments.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyProximalAdagrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSegmentMeanGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes gradients for SparseSegmentMean.
            </summary>
            <param name="grad">Input to the operation: gradient propagated to the SparseSegmentMean op.</param>
            <param name="indices">Input to the operation: indices passed to the corresponding SparseSegmentMean op.</param>
            <param name="segment_ids">Input to the operation: segment_ids passed to the corresponding SparseSegmentMean op.</param>
            <param name="output_dim0">Input to the operation: dimension 0 of "data" passed to SparseSegmentMean op.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSegmentSqrtN(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes the sum along sparse segments of a tensor divided by the sqrt of N.
            </summary>
            <param name="data">Input to the operation. </param>
            <param name="indices">Input to the operation: A 1-D tensor. Has same rank as `segment_ids`.</param>
            <param name="segment_ids">Input to the operation: A 1-D tensor. Values should be sorted and can be repeated.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Has same shape as data, except for dimension 0 which has size `k`, the number of segments.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyRMSProp(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the RMSProp algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="ms">Input to the operation: Should be from a Variable().</param>
            <param name="mom">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay rate. Must be a scalar.</param>
            <param name="momentum">Input to the operation. </param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var, ms and mom.</param>
            <param name="use_locking">If `True`, updating of the var, ms, and mom tensors is protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSegmentSqrtNGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Computes gradients for SparseSegmentSqrtN.
            </summary>
            <param name="grad">Input to the operation: gradient propagated to the SparseSegmentSqrtN op.</param>
            <param name="indices">Input to the operation: indices passed to the corresponding SparseSegmentSqrtN op.</param>
            <param name="segment_ids">Input to the operation: segment_ids passed to the corresponding SparseSegmentSqrtN op.</param>
            <param name="output_dim0">Input to the operation: dimension 0 of "data" passed to SparseSegmentSqrtN op.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Any(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the "logical or" of elements across dimensions of a tensor.
            </summary>
            <param name="input">Input to the operation: The tensor to reduce.</param>
            <param name="reduction_indices">Input to the operation: The dimensions to reduce.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtBool): The reduced tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Range(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Creates a sequence of numbers.
            </summary>
            <param name="start">Input to the operation: 0-D (scalar). First entry in the sequence.</param>
            <param name="limit">Input to the operation: 0-D (scalar). Upper limit of sequence, exclusive.</param>
            <param name="delta">Input to the operation: 0-D (scalar). Optional. Default is 1. Number that increments `start`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 1-D.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AssignAdd(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update 'ref' by adding 'value' to it.
            </summary>
            <param name="reference">Input to the operation: Should be from a `Variable` node.</param>
            <param name="value">Input to the operation: The value to be added to the variable.</param>
            <param name="use_locking">If True, the addition will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): = Same as "ref".  Returned as a convenience for operations that want to use the new value after the variable has been updated.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Complex(Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Converts two real numbers to a complex number.
            </summary>
            <param name="real">Input to the operation. </param>
            <param name="imag">Input to the operation. </param>
            <param name="Tout"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Cross(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Compute the pairwise cross product.
            </summary>
            <param name="a">Input to the operation: A tensor containing 3-element vectors.</param>
            <param name="b">Input to the operation: Another tensor, of same type and shape as `a`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] product(type: DtInvalid): Pairwise cross product of the vectors in `a` and `b`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Bincount(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Counts the number of occurrences of each value in an integer array.
            </summary>
            <param name="arr">Input to the operation: int32 `Tensor`.</param>
            <param name="size">Input to the operation: non-negative int32 scalar `Tensor`.</param>
            <param name="weights">Input to the operation: is an int32, int64, float32, or float64 `Tensor` with the same shape as `arr`, or a length-0 `Tensor`, in which case it acts as all weights equal to 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] bins(type: DtInvalid): 1D `Tensor` with length equal to `size`. The counts or summed weights for each value in the range [0, size).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Cumprod(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Compute the cumulative product of the tensor `x` along `axis`.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="axis">Input to the operation. </param>
            <param name="exclusive"></param>
            <param name="reverse"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedMatMul(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.Boolean,System.Boolean,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Perform a quantized matrix multiplication of  `a` by the matrix `b`.
            </summary>
            <param name="a">Input to the operation: Must be a two-dimensional tensor.</param>
            <param name="b">Input to the operation: Must be a two-dimensional tensor.</param>
            <param name="min_a">Input to the operation: The float value that the lowest quantized `a` value represents.</param>
            <param name="max_a">Input to the operation: The float value that the highest quantized `a` value represents.</param>
            <param name="min_b">Input to the operation: The float value that the lowest quantized `b` value represents.</param>
            <param name="max_b">Input to the operation: The float value that the highest quantized `b` value represents.</param>
            <param name="Toutput"></param>
            <param name="transpose_a">If true, `a` is transposed before multiplication.</param>
            <param name="transpose_b">If true, `b` is transposed before multiplication.</param>
            <param name="Tactivation">The type of output produced by activation function following this operation.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid).
            [1] min_out(type: DtFloat): The float value that the lowest quantized output value represents.
            [2] max_out(type: DtFloat): The float value that the highest quantized output value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizedAdd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Returns x + y element-wise, working on quantized buffers.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="min_x">Input to the operation: The float value that the lowest quantized `x` value represents.</param>
            <param name="max_x">Input to the operation: The float value that the highest quantized `x` value represents.</param>
            <param name="min_y">Input to the operation: The float value that the lowest quantized `y` value represents.</param>
            <param name="max_y">Input to the operation: The float value that the highest quantized `y` value represents.</param>
            <param name="Toutput"></param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            [1] min_z(type: DtFloat): The float value that the lowest quantized output value represents.
            [2] max_z(type: DtFloat): The float value that the highest quantized output value represents.  *NOTE*: `QuantizedAdd` supports limited forms of broadcasting. More about broadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.QuantizeDownAndShrinkRange(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Convert the quantized 'input' tensor into a lower-precision 'output', using the
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="input_min">Input to the operation: The float value that the minimum quantized input value represents.</param>
            <param name="input_max">Input to the operation: The float value that the maximum quantized input value represents.</param>
            <param name="out_type">The type of the output. Should be a lower bit depth than Tinput.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            [1] output_min(type: DtFloat): The float value that the minimum quantized output value represents.
            [2] output_max(type: DtFloat): The float value that the maximum quantized output value represents.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyAdagrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update relevant entries in '*var' and '*accum' according to the adagrad scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Invert(Emgu.TF.Output,System.String)">
            <summary>
            Flips all bits elementwise.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] y(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BitwiseAnd(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Elementwise computes the bitwise AND of `x` and `y`.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.BitwiseXor(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Elementwise computes the bitwise XOR of `x` and `y`.
            </summary>
            <param name="x">Input to the operation. </param>
            <param name="y">Input to the operation. </param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] z(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseAddGrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            The gradient operator for the SparseAdd op.
            </summary>
            <param name="backprop_val_grad">Input to the operation: 1-D with shape `[nnz(sum)]`.  The gradient with respect to the non-empty values of the sum.</param>
            <param name="a_indices">Input to the operation: 2-D.  The `indices` of the `SparseTensor` A, size `[nnz(A), ndims]`.</param>
            <param name="b_indices">Input to the operation: 2-D.  The `indices` of the `SparseTensor` B, size `[nnz(B), ndims]`.</param>
            <param name="sum_indices">Input to the operation: 2-D.  The `indices` of the sum `SparseTensor`, size `[nnz(sum), ndims]`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] a_val_grad(type: DtInvalid): 1-D with shape `[nnz(A)]`. The gradient with respect to the non-empty values of A.
            [1] b_val_grad(type: DtInvalid): 1-D with shape `[nnz(B)]`. The gradient with respect to the non-empty values of B.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseAdd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Adds two `SparseTensor` objects to produce another `SparseTensor`.
            </summary>
            <param name="a_indices">Input to the operation: 2-D.  The `indices` of the first `SparseTensor`, size `[nnz, ndims]` Matrix.</param>
            <param name="a_values">Input to the operation: 1-D.  The `values` of the first `SparseTensor`, size `[nnz]` Vector.</param>
            <param name="a_shape">Input to the operation: 1-D.  The `shape` of the first `SparseTensor`, size `[ndims]` Vector.</param>
            <param name="b_indices">Input to the operation: 2-D.  The `indices` of the second `SparseTensor`, size `[nnz, ndims]` Matrix.</param>
            <param name="b_values">Input to the operation: 1-D.  The `values` of the second `SparseTensor`, size `[nnz]` Vector.</param>
            <param name="b_shape">Input to the operation: 1-D.  The `shape` of the second `SparseTensor`, size `[ndims]` Vector.</param>
            <param name="thresh">Input to the operation: 0-D.  The magnitude threshold that determines if an output value/index pair takes space.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sum_indices(type: DtInt64).
            [1] sum_values(type: DtInvalid).
            [2] sum_shape(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseTensorDenseMatMul(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Multiply SparseTensor (of rank 2) "A" by dense matrix "B".
            </summary>
            <param name="a_indices">Input to the operation: 2-D.  The `indices` of the `SparseTensor`, size `[nnz, 2]` Matrix.</param>
            <param name="a_values">Input to the operation: 1-D.  The `values` of the `SparseTensor`, size `[nnz]` Vector.</param>
            <param name="a_shape">Input to the operation: 1-D.  The `shape` of the `SparseTensor`, size `[2]` Vector.</param>
            <param name="b">Input to the operation: 2-D.  A dense Matrix.</param>
            <param name="adjoint_a">Use the adjoint of A in the matrix multiply.  If A is complex, this is transpose(conj(A)).  Otherwise it's transpose(A).</param>
            <param name="adjoint_b">Use the adjoint of B in the matrix multiply.  If B is complex, this is transpose(conj(B)).  Otherwise it's transpose(B).</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] product(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SerializeManySparse(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` string `Tensor`.
            </summary>
            <param name="sparse_indices">Input to the operation: 2-D.  The `indices` of the minibatch `SparseTensor`.</param>
            <param name="sparse_values">Input to the operation: 1-D.  The `values` of the minibatch `SparseTensor`.</param>
            <param name="sparse_shape">Input to the operation: 1-D.  The `shape` of the minibatch `SparseTensor`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] serialized_sparse(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DeserializeManySparse(Emgu.TF.Output,Emgu.TF.DataType,System.String)">
            <summary>
            Deserialize and concatenate `SparseTensors` from a serialized minibatch.
            </summary>
            <param name="serialized_sparse">Input to the operation: 2-D, The `N` serialized `SparseTensor` objects. Must have 3 columns.</param>
            <param name="dtype">The `dtype` of the serialized `SparseTensor` objects.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sparse_indices(type: DtInt64).
            [1] sparse_values(type: DtInvalid).
            [2] sparse_shape(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseConcat(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.String)">
            <summary>
            Concatenates a list of `SparseTensor` along the specified dimension.
            </summary>
            <param name="indices">Input to the operation: 2-D.  Indices of each input `SparseTensor`.</param>
            <param name="values">Input to the operation: 1-D.  Non-empty values of each `SparseTensor`.</param>
            <param name="shapes">Input to the operation: 1-D.  Shapes of each `SparseTensor`.</param>
            <param name="concat_dim">Dimension to concatenate along. Must be in range [-rank, rank), where rank is the number of dimensions in each input `SparseTensor`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64): 2-D.  Indices of the concatenated `SparseTensor`.
            [1] output_values(type: DtInvalid): 1-D.  Non-empty values of the concatenated `SparseTensor`.
            [2] output_shape(type: DtInt64): 1-D.  Shape of the concatenated `SparseTensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSlice(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Slice a `SparseTensor` based on the `start` and `size`.
            </summary>
            <param name="indices">Input to the operation: 2-D tensor represents the indices of the sparse tensor.</param>
            <param name="values">Input to the operation: 1-D tensor represents the values of the sparse tensor.</param>
            <param name="shape">Input to the operation: 1-D. tensor represents the shape of the sparse tensor.</param>
            <param name="start">Input to the operation: 1-D. tensor represents the start of the slice.</param>
            <param name="size">Input to the operation: 1-D. tensor represents the size of the slice. output indices: A list of 1-D tensors represents the indices of the output sparse tensors.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64).
            [1] output_values(type: DtInvalid): A list of 1-D tensors represents the values of the output sparse tensors.
            [2] output_shape(type: DtInt64): A list of 1-D tensors represents the shape of the output sparse tensors.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseReorder(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Reorders a SparseTensor into the canonical, row-major ordering.
            </summary>
            <param name="input_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, possibly not in canonical ordering.</param>
            <param name="input_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `input_indices`.</param>
            <param name="input_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64): 2-D.  `N x R` matrix with the same indices as input_indices, but in canonical row-major ordering.
            [1] output_values(type: DtInvalid): 1-D.  `N` non-empty values corresponding to `output_indices`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseTensorDenseAdd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Adds up a `SparseTensor` and a dense `Tensor`, producing a dense `Tensor`.
            </summary>
            <param name="a_indices">Input to the operation: 2-D.  The `indices` of the `SparseTensor`, with shape `[nnz, ndims]`.</param>
            <param name="a_values">Input to the operation: 1-D.  The `values` of the `SparseTensor`, with shape `[nnz]`.</param>
            <param name="a_shape">Input to the operation: 1-D.  The `shape` of the `SparseTensor`, with shape `[ndims]`.</param>
            <param name="b">Input to the operation: `ndims`-D Tensor.  With shape `a_shape`.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseReduceMaxSparse(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the max of elements across dimensions of a SparseTensor.
            </summary>
            <param name="input_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, possibly not in canonical ordering.</param>
            <param name="input_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `input_indices`.</param>
            <param name="input_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="reduction_axes">Input to the operation: 1-D.  Length-`K` vector containing the reduction axes.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64).
            [1] output_values(type: DtInvalid).
            [2] output_shape(type: DtInt64).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseReduceSum(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Computes the sum of elements across dimensions of a SparseTensor.
            </summary>
            <param name="input_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, possibly not in canonical ordering.</param>
            <param name="input_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `input_indices`.</param>
            <param name="input_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="reduction_axes">Input to the operation: 1-D.  Length-`K` vector containing the reduction axes.</param>
            <param name="keep_dims">If true, retain reduced dimensions with length 1.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): `R-K`-D.  The reduced Tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseDenseCwiseDiv(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Component-wise divides a SparseTensor by a dense Tensor.
            </summary>
            <param name="sp_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, possibly not in canonical ordering.</param>
            <param name="sp_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `sp_indices`.</param>
            <param name="sp_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="dense">Input to the operation: `R`-D.  The dense Tensor operand.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): 1-D.  The `N` values that are operated on.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseSparseMinimum(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Returns the element-wise min of two SparseTensors.
            </summary>
            <param name="a_indices">Input to the operation: 2-D.  `N x R` matrix with the indices of non-empty values in a SparseTensor, in the canonical lexicographic ordering.</param>
            <param name="a_values">Input to the operation: 1-D.  `N` non-empty values corresponding to `a_indices`.</param>
            <param name="a_shape">Input to the operation: 1-D.  Shape of the input SparseTensor.</param>
            <param name="b_indices">Input to the operation: counterpart to `a_indices` for the other operand.</param>
            <param name="b_values">Input to the operation: counterpart to `a_values` for the other operand; must be of the same dtype.</param>
            <param name="b_shape">Input to the operation: counterpart to `a_shape` for the other operand; the two shapes must be equal.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64): 2-D.  The indices of the output SparseTensor.
            [1] output_values(type: DtInvalid): 1-D.  The values of the output SparseTensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AddSparseToTensorsMap(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.String,System.String)">
            <summary>
            Add a `SparseTensor` to a `SparseTensorsMap` return its handle.
            </summary>
            <param name="sparse_indices">Input to the operation: 2-D.  The `indices` of the `SparseTensor`.</param>
            <param name="sparse_values">Input to the operation: 1-D.  The `values` of the `SparseTensor`.</param>
            <param name="sparse_shape">Input to the operation: 1-D.  The `shape` of the `SparseTensor`.</param>
            <param name="container">The container name for the `SparseTensorsMap` created by this op.</param>
            <param name="shared_name">The shared name for the `SparseTensorsMap` created by this op. If blank, the new Operation's unique name is used.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sparse_handle(type: DtInt64): 0-D.  The handle of the `SparseTensor` now stored in the `SparseTensorsMap`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AddManySparseToTensorsMap(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String,System.String,System.String)">
            <summary>
            Add an `N`-minibatch `SparseTensor` to a `SparseTensorsMap`, return `N` handles.
            </summary>
            <param name="sparse_indices">Input to the operation: 2-D.  The `indices` of the minibatch `SparseTensor`. `sparse_indices[:, 0]` must be ordered values in `[0, N)`.</param>
            <param name="sparse_values">Input to the operation: 1-D.  The `values` of the minibatch `SparseTensor`.</param>
            <param name="sparse_shape">Input to the operation: 1-D.  The `shape` of the minibatch `SparseTensor`. The minibatch size `N == sparse_shape[0]`.</param>
            <param name="container">The container name for the `SparseTensorsMap` created by this op.</param>
            <param name="shared_name">The shared name for the `SparseTensorsMap` created by this op. If blank, the new Operation's unique name is used.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] sparse_handles(type: DtInt64): 1-D.  The handles of the `SparseTensor` now stored in the `SparseTensorsMap`.  Shape: `[N]`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseFillEmptyRows(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Fills empty rows in the input 2-D `SparseTensor` with a default value.
            </summary>
            <param name="indices">Input to the operation: 2-D. the indices of the sparse tensor.</param>
            <param name="values">Input to the operation: 1-D. the values of the sparse tensor.</param>
            <param name="dense_shape">Input to the operation: 1-D. the shape of the sparse tensor.</param>
            <param name="default_value">Input to the operation: 0-D. default value to insert into location `[row, 0, ..., 0]`   for rows missing from the input sparse tensor. output indices: 2-D. the indices of the filled sparse tensor.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_indices(type: DtInt64).
            [1] output_values(type: DtInvalid): 1-D. the values of the filled sparse tensor.
            [2] empty_row_indicator(type: DtBool): 1-D. whether the dense row was missing in the input sparse tensor.
            [3] reverse_index_map(type: DtInt64): 1-D. a map from the input indices to the output indices.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RandomUniformInt(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Outputs random integers from a uniform distribution.
            </summary>
            <param name="shape">Input to the operation: The shape of the output tensor.</param>
            <param name="minval">Input to the operation: 0-D.  Inclusive lower bound on the generated integers.</param>
            <param name="maxval">Input to the operation: 0-D.  Exclusive upper bound on the generated integers.</param>
            <param name="seed">If either `seed` or `seed2` are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A tensor of the specified shape filled with uniform random integers.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ParameterizedTruncatedNormal(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Outputs random values from a normal distribution. The parameters may each be a
            </summary>
            <param name="shape">Input to the operation: The shape of the output tensor. Batches are indexed by the 0th dimension.</param>
            <param name="means">Input to the operation: The mean parameter of each batch.</param>
            <param name="stdevs">Input to the operation: The standard deviation parameter of each batch. Must be greater than 0.</param>
            <param name="minvals">Input to the operation: The minimum cutoff. May be -infinity.</param>
            <param name="maxvals">Input to the operation: The maximum cutoff. May be +infinity, and must be more than the minval for each batch.</param>
            <param name="seed">If either `seed` or `seed2` are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A matrix of shape num_batches x samples_per_batch, filled with random truncated normal values using the parameters for each row.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TruncatedNormal(Emgu.TF.Output,Emgu.TF.DataType,System.Int64,System.Int64,System.String)">
            <summary>
            Outputs random values from a truncated normal distribution.
            </summary>
            <param name="shape">Input to the operation: The shape of the output tensor.</param>
            <param name="dtype">The type of the output.</param>
            <param name="seed">If either `seed` or `seed2` are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A tensor of the specified shape filled with random truncated normal values.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.RandomGamma(Emgu.TF.Output,Emgu.TF.Output,System.Int64,System.Int64,System.String)">
            <summary>
            Outputs random values from the Gamma distribution(s) described by alpha.
            </summary>
            <param name="shape">Input to the operation: 1-D integer tensor. Shape of independent samples to draw from each distribution described by the shape parameters given in alpha.</param>
            <param name="alpha">Input to the operation: A tensor in which each scalar is a "shape" parameter describing the associated gamma distribution.</param>
            <param name="seed">If either `seed` or `seed2` are set to be non-zero, the random number generator is seeded by the given seed.  Otherwise, it is seeded by a random seed.</param>
            <param name="seed2">A second seed to avoid seed collision.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): A tensor with shape `shape + shape(alpha)`. Each slice `[:, ..., :, i0, i1, ...iN]` contains the samples drawn for `alpha[i0, i1, ...iN]`. The dtype of the output matches the dtype of alpha.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StatelessRandomNormal(Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Outputs deterministic pseudorandom values from a normal distribution.
            </summary>
            <param name="shape">Input to the operation: The shape of the output tensor.</param>
            <param name="seed">Input to the operation: 2 seeds (shape [2]).</param>
            <param name="dtype">The type of the output.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Random values with specified shape.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StatelessTruncatedNormal(Emgu.TF.Output,Emgu.TF.Output,System.Nullable{Emgu.TF.DataType},System.String)">
            <summary>
            Outputs deterministic pseudorandom values from a truncated normal distribution.
            </summary>
            <param name="shape">Input to the operation: The shape of the output tensor.</param>
            <param name="seed">Input to the operation: 2 seeds (shape [2]).</param>
            <param name="dtype">The type of the output.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): Random values with specified shape.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StringToHashBucketStrong(Emgu.TF.Output,System.Int64,System.Int64[],System.String)">
            <summary>
            Converts each string in the input Tensor to its hash mod by a number of buckets.
            </summary>
            <param name="input">Input to the operation: The strings to assign a hash bucket.</param>
            <param name="num_buckets">The number of buckets.</param>
            <param name="key">The key for the keyed hash function passed as a list of two uint64 elements.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInt64): A Tensor of the same shape as the input `string_tensor`.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AsString(Emgu.TF.Output,System.Int64,System.Boolean,System.Boolean,System.Int64,System.String,System.String)">
            <summary>
            Converts each entry in the given tensor to strings.  Supports many numeric
            </summary>
            <param name="input">Input to the operation. </param>
            <param name="precision">The post-decimal precision to use for floating point numbers. Only used if precision &gt; -1.</param>
            <param name="scientific">Use scientific notation for floating point numbers.</param>
            <param name="shortest">Use shortest representation (either scientific or standard) for floating point numbers.</param>
            <param name="width">Pad pre-decimal numbers to this width. Applies to both floating point and integer numbers. Only used if width &gt; -1.</param>
            <param name="fill">The value to pad if width &gt; -1.  If empty, pads with spaces. Another typical value is '0'.  String cannot be longer than 1 character.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StringJoin(Emgu.TF.Output,System.String,System.String)">
            <summary>
            Joins the strings in the given list of string tensors into one tensor;
            </summary>
            <param name="inputs">Input to the operation: A list of string tensors.  The tensors must all have the same shape, or be scalars.  Scalars may be mixed in; these will be broadcast to the shape of non-scalar inputs.</param>
            <param name="separator">string, an optional join separator.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtString).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.StringSplit(Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Split elements of `input` based on `delimiter` into a `SparseTensor`.
            </summary>
            <param name="input">Input to the operation: 1-D. Strings to split.</param>
            <param name="delimiter">Input to the operation: 0-D. Delimiter characters (bytes), or empty string.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] indices(type: DtInt64): A dense matrix of int64 representing the indices of the sparse tensor.
            [1] values(type: DtString): A vector of strings corresponding to the splited values.
            [2] shape(type: DtInt64): a length-2 vector of int64 representing the shape of the sparse tensor, where the first value is N and the second value is the maximum number of tokens in a single input entry.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Substr(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.String)">
            <summary>
            Return substrings from `Tensor` of strings.
            </summary>
            <param name="input">Input to the operation: Tensor of strings</param>
            <param name="pos">Input to the operation: Scalar defining the position of first character in each substring</param>
            <param name="len">Input to the operation: Scalar defining the number of characters to include in each substring</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtString): Tensor of substrings
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.EncodeBase64(Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Encode strings into web-safe base64 format.
            </summary>
            <param name="input">Input to the operation: Strings to be encoded.</param>
            <param name="pad">Bool whether padding is applied at the ends.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtString): Input strings encoded in base64.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DecodeBase64(Emgu.TF.Output,System.String)">
            <summary>
            Decode web-safe base64-encoded strings.
            </summary>
            <param name="input">Input to the operation: Base64 strings to decode.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtString): Decoded strings.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.VariableV2(System.Int64[],Emgu.TF.DataType,System.String,System.String,System.String)">
            <summary>
            Holds state in the form of a tensor that persists across steps.
            </summary>
            <param name="shape">The shape of the variable tensor.</param>
            <param name="dtype">The type of elements in the variable tensor.</param>
            <param name="container">If non-empty, this variable is placed in the given container. Otherwise, a default container is used.</param>
            <param name="shared_name">If non-empty, this variable is named in the given bucket with this shared_name. Otherwise, the node name is used instead.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] ref(type: DtInvalid): A reference to the variable tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.IsVariableInitialized(Emgu.TF.Output,System.String)">
            <summary>
            Checks whether a tensor has been initialized.
            </summary>
            <param name="reference">Input to the operation: Should be from a `Variable` node. May be uninitialized.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] is_initialized(type: DtBool).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.TemporaryVariable(System.Int64[],Emgu.TF.DataType,System.String,System.String)">
            <summary>
            Returns a tensor that may be mutated, but only persists within a single step.
            </summary>
            <param name="shape">The shape of the variable tensor.</param>
            <param name="dtype">The type of elements in the variable tensor.</param>
            <param name="var_name">Overrides the name used for the temporary variable resource. Default value is the name of the 'TemporaryVariable' op (which is guaranteed unique).</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] ref(type: DtInvalid): A reference to the variable tensor.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.DestroyTemporaryVariable(Emgu.TF.Output,System.String,System.String)">
            <summary>
            Destroys the temporary variable and returns its final value.
            </summary>
            <param name="reference">Input to the operation: A reference to the temporary variable tensor.</param>
            <param name="var_name">Name of the temporary variable, usually the name of the matching 'TemporaryVariable' op.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] value(type: DtInvalid).
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.Assign(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Update 'ref' by assigning 'value' to it.
            </summary>
            <param name="reference">Input to the operation: Should be from a `Variable` node. May be uninitialized.</param>
            <param name="value">Input to the operation: The value to be assigned to the variable.</param>
            <param name="validate_shape">If true, the operation will validate that the shape of 'value' matches the shape of the Tensor being assigned to.  If false, 'ref' will take on the shape of 'value'.</param>
            <param name="use_locking">If True, the assignment will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): = Same as "ref".  Returned as a convenience for operations that want to use the new value after the variable has been reset.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.AssignSub(Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update 'ref' by subtracting 'value' from it.
            </summary>
            <param name="reference">Input to the operation: Should be from a `Variable` node.</param>
            <param name="value">Input to the operation: The value to be subtracted to the variable.</param>
            <param name="use_locking">If True, the subtraction will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): = Same as "ref".  Returned as a convenience for operations that want to use the new value after the variable has been updated.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterUpdate(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Applies sparse updates to a variable reference.
            </summary>
            <param name="reference">Input to the operation: Should be from a `Variable` node.</param>
            <param name="indices">Input to the operation: A tensor of indices into the first dimension of `ref`.</param>
            <param name="updates">Input to the operation: A tensor of updated values to store in `ref`.</param>
            <param name="use_locking">If True, the assignment will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): = Same as `ref`.  Returned as a convenience for operations that want to use the updated values after the update is done.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ScatterNdAdd(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Applies sparse addition between `updates` and individual values or slices
            </summary>
            <param name="reference">Input to the operation: A mutable Tensor. Should be from a Variable node.</param>
            <param name="indices">Input to the operation: A Tensor. Must be one of the following types: int32, int64. A tensor of indices into ref.</param>
            <param name="updates">Input to the operation: A Tensor. Must have the same type as ref. A tensor of updated values to add to ref.</param>
            <param name="use_locking">An optional bool. Defaults to True. If True, the assignment will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output_ref(type: DtInvalid): Same as ref. Returned as a convenience for operations that want to use the updated values after the update is done.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyDelayCompensatedGradientDescent(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            var -= alpha * (delta + lambda * delta * (var - shadow))
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="alpha">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="delta">Input to the operation: The change.</param>
            <param name="lambda">Input to the operation: The variance parameter.</param>
            <param name="shadow">Input to the operation: Same as "var".</param>
            <param name="use_locking">If `True`, the subtraction will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyProximalGradientDescent(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' as FOBOS algorithm with fixed learning rate.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="alpha">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="delta">Input to the operation: The change.</param>
            <param name="use_locking">If True, the subtraction will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyAdadelta(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the adadelta scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="accum_update">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay factor. Must be a scalar.</param>
            <param name="epsilon">Input to the operation: Constant factor. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If True, updating of the var, accum and update_accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyAdadelta(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the adadelta scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="accum_update">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay factor. Must be a scalar.</param>
            <param name="epsilon">Input to the operation: Constant factor. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If True, updating of the var, accum and update_accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyAdadelta(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            var: Should be from a Variable().
            </summary>
            <param name="var">Input to the operation. </param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="accum_update">Input to the operation: : Should be from a Variable().</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay factor. Must be a scalar.</param>
            <param name="epsilon">Input to the operation: Constant factor. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyAdagrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the adagrad scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyProximalAdagrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyProximalAdagrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' and '*accum' according to FOBOS with Adagrad learning rate.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyAdagradDA(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the proximal adagrad scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="gradient_accumulator">Input to the operation: Should be from a Variable().</param>
            <param name="gradient_squared_accumulator">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="global_step">Input to the operation: Training step number. Must be a scalar.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyCenteredRMSProp(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the centered RMSProp algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="mg">Input to the operation: Should be from a Variable().</param>
            <param name="ms">Input to the operation: Should be from a Variable().</param>
            <param name="mom">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay rate. Must be a scalar.</param>
            <param name="momentum">Input to the operation. </param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var, ms and mom.</param>
            <param name="use_locking">If `True`, updating of the var, mg, ms, and mom tensors is protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyAdagradDA(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update entries in '*var' and '*accum' according to the proximal adagrad scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="gradient_accumulator">Input to the operation: Should be from a Variable().</param>
            <param name="gradient_squared_accumulator">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="global_step">Input to the operation: Training step number. Must be a scalar.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyProximalAdagrad(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Sparse update entries in '*var' and '*accum' according to FOBOS algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="use_locking">If True, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyFtrl(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update relevant entries in '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="linear">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="lr_power">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyFtrl(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="linear">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regulariation. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regulariation. Must be a scalar.</param>
            <param name="lr_power">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyFtrl(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update relevant entries in '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="linear">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 regularization. Must be a scalar.</param>
            <param name="lr_power">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyFtrlV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="linear">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regulariation. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 shrinkage regulariation. Must be a scalar.</param>
            <param name="l2_shrinkage">Input to the operation. </param>
            <param name="lr_power">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyFtrlV2(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update relevant entries in '*var' according to the Ftrl-proximal scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="linear">Input to the operation: Should be from a Variable().</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="l1">Input to the operation: L1 regularization. Must be a scalar.</param>
            <param name="l2">Input to the operation: L2 shrinkage regulariation. Must be a scalar.</param>
            <param name="l2_shrinkage">Input to the operation. </param>
            <param name="lr_power">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyMomentum(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the momentum scheme. Set use_nesterov = True if you
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="momentum">Input to the operation: Momentum. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="use_nesterov">If `True`, the tensor passed to compute grad will be var - lr * momentum * accum, so in the end, the var you get is actually var - lr * momentum * accum.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.SparseApplyMomentum(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Update relevant entries in '*var' and '*accum' according to the momentum scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="momentum">Input to the operation: Momentum. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="use_nesterov">If `True`, the tensor passed to compute grad will be var - lr * momentum * accum, so in the end, the var you get is actually var - lr * momentum * accum.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyMomentum(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the momentum scheme. Set use_nesterov = True if you
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="momentum">Input to the operation: Momentum. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="use_nesterov">If `True`, the tensor passed to compute grad will be var - lr * momentum * accum, so in the end, the var you get is actually var - lr * momentum * accum.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceSparseApplyMomentum(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.Boolean,System.String)">
            <summary>
            Update relevant entries in '*var' and '*accum' according to the momentum scheme.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="accum">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Learning rate. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="indices">Input to the operation: A vector of indices into the first dimension of var and accum.</param>
            <param name="momentum">Input to the operation: Momentum. Must be a scalar.</param>
            <param name="use_locking">If `True`, updating of the var and accum tensors will be protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="use_nesterov">If `True`, the tensor passed to compute grad will be var - lr * momentum * accum, so in the end, the var you get is actually var - lr * momentum * accum.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyRMSProp(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the RMSProp algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="ms">Input to the operation: Should be from a Variable().</param>
            <param name="mom">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay rate. Must be a scalar.</param>
            <param name="momentum">Input to the operation. </param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If `True`, updating of the var, ms, and mom tensors is protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ApplyCenteredRMSProp(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the centered RMSProp algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="mg">Input to the operation: Should be from a Variable().</param>
            <param name="ms">Input to the operation: Should be from a Variable().</param>
            <param name="mom">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay rate. Must be a scalar.</param>
            <param name="momentum">Input to the operation. </param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If `True`, updating of the var, mg, ms, and mom tensors is protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] out(type: DtInvalid): Same as "var".
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyRMSProp(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the RMSProp algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="ms">Input to the operation: Should be from a Variable().</param>
            <param name="mom">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay rate. Must be a scalar.</param>
            <param name="momentum">Input to the operation. </param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If `True`, updating of the var, ms, and mom tensors is protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.ResourceApplyCenteredRMSProp(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Boolean,System.String)">
            <summary>
            Update '*var' according to the centered RMSProp algorithm.
            </summary>
            <param name="var">Input to the operation: Should be from a Variable().</param>
            <param name="mg">Input to the operation: Should be from a Variable().</param>
            <param name="ms">Input to the operation: Should be from a Variable().</param>
            <param name="mom">Input to the operation: Should be from a Variable().</param>
            <param name="lr">Input to the operation: Scaling factor. Must be a scalar.</param>
            <param name="rho">Input to the operation: Decay rate. Must be a scalar.</param>
            <param name="momentum">Input to the operation. </param>
            <param name="epsilon">Input to the operation: Ridge term. Must be a scalar.</param>
            <param name="grad">Input to the operation: The gradient.</param>
            <param name="use_locking">If `True`, updating of the var, mg, ms, and mom tensors is protected by a lock; otherwise the behavior is undefined, but may exhibit less contention.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.Skipgram(System.String,System.Int64,System.Int64,System.Int64,System.Single,System.String)">
            <summary>
            Parses a text file and creates a batch of examples.
            </summary>
            <param name="filename">The corpus's text file name.</param>
            <param name="batch_size">The size of produced batch.</param>
            <param name="window_size">The number of words to predict to the left and right of the target.</param>
            <param name="min_count">The minimum number of word occurrences for it to be included in the vocabulary.</param>
            <param name="subsample">Threshold for word occurrence. Words that appear with higher frequency will be randomly down-sampled. Set to 0 to disable.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] vocab_word(type: DtString): A vector of words in the corpus.
            [1] vocab_freq(type: DtInt32): Frequencies of words. Sorted in the non-ascending order.
            [2] words_per_epoch(type: DtInt64): Number of words per epoch in the data file.
            [3] current_epoch(type: DtInt32): The current epoch number.
            [4] total_words_processed(type: DtInt64): The total number of words processed so far.
            [5] examples(type: DtInt32): A vector of word ids.
            [6] labels(type: DtInt32): A vector of word ids.
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.NegTrain(Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,Emgu.TF.Output,System.Int64[],System.Int64,System.String)">
            <summary>
            Training via negative sampling.
            </summary>
            <param name="w_in">Input to the operation: input word embedding.</param>
            <param name="w_out">Input to the operation: output word embedding.</param>
            <param name="examples">Input to the operation: A vector of word ids.</param>
            <param name="labels">Input to the operation: A vector of word ids.</param>
            <param name="lr">Input to the operation. </param>
            <param name="vocab_count">Count of words in the vocabulary.</param>
            <param name="num_negative_samples">Number of negative samples per example.</param>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="M:Emgu.TF.Graph.SymbolicGradient(Emgu.TF.Output,Emgu.TF.DataType[],System.String)">
            <summary>
            Computes the gradient function for function f via backpropagation.
            </summary>
            <param name="input">Input to the operation: a list of input tensors of size N + M;</param>
            <param name="Tout">the type list for the input list.</param>
            <param name="opName">The name of the operation</param>
            <return>
            [0] output(type: DtInvalid): a list of output tensors of size N;
            </return>
        </member>
        <member name="M:Emgu.TF.Graph.NoOp(System.String)">
            <summary>
            Does nothing. Only useful as a placeholder for control edges.
            </summary>
            <param name="opName">The name of the operation</param>
        </member>
        <member name="T:Emgu.TF.ImportGraphDefOptions">
            <summary>
            ImportGraphDefOptions holds options that can be passed to Graph.ImportGraphDef
            </summary>
        </member>
        <member name="M:Emgu.TF.ImportGraphDefOptions.#ctor">
            <summary>
            Create an empty GraphDefOptions
            </summary>
        </member>
        <member name="M:Emgu.TF.ImportGraphDefOptions.DisposeObject">
            <summary>
            Release all the memory associated with this GraphDefOptions
            </summary>
        </member>
        <member name="M:Emgu.TF.ImportGraphDefOptions.SetPrefix(System.String)">
            <summary>
            Set the prefix to be prepended to the names of nodes in `graph_def` that will
            be imported into `graph`.
            </summary>
            <param name="prefix">The node prefix</param>
        </member>
        <member name="T:Emgu.TF.Input">
            <summary>
            Represents a specific input of an operation.
            </summary>
        </member>
        <member name="F:Emgu.TF.Input.Operation">
            <summary>
            The Operation
            </summary>
        </member>
        <member name="F:Emgu.TF.Input.Index">
            <summary>
            The index of the input within the operation
            </summary>
        </member>
        <member name="M:Emgu.TF.Input.#ctor(Emgu.TF.Operation,System.Int32)">
            <summary>
            Create an input by specifying the operation and index.
            </summary>
            <param name="operation">The operation</param>
            <param name="index">The index of the input within the operation</param>
        </member>
        <member name="T:Emgu.TF.Operation">
            <summary>
            Tensorflow operation
            </summary>
        </member>
        <member name="P:Emgu.TF.Operation.Ptr">
            <summary>
            Get the unmanaged pointer to the Operation
            </summary>
        </member>
        <member name="M:Emgu.TF.Operation.op_Implicit(Emgu.TF.Operation)~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="obj">The Operation</param>
            <returns>The Operation pointer for this object</returns>
        </member>
        <member name="M:Emgu.TF.Operation.op_Implicit(Emgu.TF.Operation)~Emgu.TF.Output">
            <summary>
            Implicit operator for Output
            </summary>
            <param name="obj">The operation</param>
            <returns>The first output of this operation</returns>
        </member>
        <member name="P:Emgu.TF.Operation.Name">
            <summary>
            Get the name of the operation
            </summary>
        </member>
        <member name="P:Emgu.TF.Operation.OpType">
            <summary>
            Get the operation type
            </summary>
        </member>
        <member name="P:Emgu.TF.Operation.Device">
            <summary>
            Get the name of the device this operation runs on
            </summary>
        </member>
        <member name="P:Emgu.TF.Operation.NumOutputs">
            <summary>
            Get the number of outputs for this operation
            </summary>
        </member>
        <member name="M:Emgu.TF.Operation.GetOutputType(System.Int32)">
            <summary>
            Get the output type of the specific output index
            </summary>
            <param name="index">the output index</param>
            <returns>The output type of the specific output index</returns>
        </member>
        <member name="P:Emgu.TF.Operation.NumInputs">
            <summary>
            Get the number of inputs for this operation
            </summary>
        </member>
        <member name="M:Emgu.TF.Operation.GetInputType(System.Int32)">
            <summary>
            Get the input type of the specific input index
            </summary>
            <param name="index">The input index</param>
            <returns>The input type of the specific input index</returns>
        </member>
        <member name="T:Emgu.TF.OperationDescription">
            <summary>
            Operation being built. The underlying graph must outlive this
            </summary>
        </member>
        <member name="M:Emgu.TF.OperationDescription.FinishOperation(Emgu.TF.Status)">
            <summary>
            If this function succeeds:
            status is set to an OK value,
            an Operation is added to the graph,
            a non-null value pointing to the added operation is returned
            -- this value is valid until the underlying graph is deleted.
            Otherwise:
            status is set to a non-OK value,
            the graph is not modified,
            a null value is returned.
            In either case, it deletes the OperationDescription.
            </summary>
            <param name="status">The status</param>
            <returns>If success, the Operation that is added to the graph, otherwise null.</returns>
        </member>
        <member name="M:Emgu.TF.OperationDescription.AddInput(Emgu.TF.Output)">
            <summary>
            Add the input to this operation description
            </summary>
            <param name="input">The input to the operation</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.AddInput(Emgu.TF.Output[])">
            <summary>
            Add the inputs to this operation description
            </summary>
            <param name="inputs">The inputs to the operation</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,System.Int64)">
            <summary>
            Set a long value as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,System.Int64[])">
            <summary>
            Set an array of long value as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,System.Boolean)">
            <summary>
            Set a boolean value as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,System.Boolean[])">
            <summary>
            Set an array of boolean value as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,System.Single)">
            <summary>
            Set a floating point value as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,System.Single[])">
            <summary>
            Set an array of floating point value as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,System.String)">
            <summary>
            Set a string value as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,Emgu.TF.DataType)">
            <summary>
            Set a DataType value as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="type">The type</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,Emgu.TF.DataType[])">
            <summary>
            Set an array of DataType value as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="types">The types</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttrShape(System.String,System.Int64[])">
            <summary>
            Set a shape as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="shape">The shape</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttrShapeList(System.String,System.Int64[][])">
            <summary>
            Set a shape list as an attribute
            </summary>
            <param name="attrName">The attribute name</param>
            <param name="shapes">The shapes</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetAttr(System.String,Emgu.TF.Tensor,Emgu.TF.Status)">
            <summary>
            Set a Tensor as an attribute
            </summary>
            <param name="attrName">The name of the attribute</param>
            <param name="tensor">The Tensor</param>
            <param name="status">The status</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.SetDevice(System.String)">
            <summary>
            Specify the device
            </summary>
            <param name="device">The device name</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.AddControlInput(Emgu.TF.Operation)">
            <summary>
            Call once per control input to this Operation description
            </summary>
            <param name="input">The control input</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.ColocateWith(Emgu.TF.Operation)">
            <summary>
            Request this operation be co-located on the device where <paramref name="op"/>
            is placed.
            </summary>
            <param name="op">The other operation</param>
        </member>
        <member name="M:Emgu.TF.OperationDescription.DisposeObject">
            <summary>
            Release all the unmanaged data associated with this OperationDescription
            </summary>
        </member>
        <member name="T:Emgu.TF.Output">
            <summary>
            Represents a specific output of an operation.
            </summary>
        </member>
        <member name="F:Emgu.TF.Output.Operation">
            <summary>
            The Operation
            </summary>
        </member>
        <member name="F:Emgu.TF.Output.Index">
            <summary>
            The index of the input within the operation
            </summary>
        </member>
        <member name="M:Emgu.TF.Output.#ctor(Emgu.TF.Operation,System.Int32)">
            <summary>
            Create an output by specifying the operation and index.
            </summary>
            <param name="operation">The Operation</param>
            <param name="index">The index of the input within the operation</param>
        </member>
        <member name="T:Emgu.TF.Session">
            <summary>
            API for driving Graph execution
            </summary>
        </member>
        <member name="M:Emgu.TF.Session.#ctor(Emgu.TF.Graph,Emgu.TF.SessionOptions,Emgu.TF.Status)">
            <summary>
            Return a new execution session with the associated graph.
            </summary>
            <param name="graph">Graph must be a valid graph (not deleted or null).  This function will
            prevent the graph from being deleted until Session is deleted.
            Does not take ownership of opts.
            </param>
            <param name="sessionOptions">The session options</param>
            <param name="status">The status</param>
        </member>
        <member name="M:Emgu.TF.Session.Close(Emgu.TF.Status)">
            <summary>
            Close a session.
            Contacts any other processes associated with the session, if applicable.
            </summary>
            <param name="status">The status</param>
        </member>
        <member name="M:Emgu.TF.Session.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Session.
            </summary>
        </member>
        <member name="M:Emgu.TF.Session.Run(Emgu.TF.Output[],Emgu.TF.Tensor[],Emgu.TF.Output[],Emgu.TF.Operation[],Emgu.TF.Buffer,Emgu.TF.Buffer,Emgu.TF.Status)">
            <summary>
            Run the graph associated with the session starting with the supplied inputs
            (inputs[0,ninputs-1] with corresponding values in input_values[0,ninputs-1]).
            </summary>
            <param name="inputs">The input nodes</param>
            <param name="inputValues">The input values</param>
            <param name="outputs">The output nodes</param>
            <param name="targetOperations">Optional target operations</param>
            <param name="runOptions"></param>
            May be NULL, in which case it will be ignored; or
            non-NULL, in which case it must point to a `TF_Buffer` containing the
            serialized representation of a `RunOptions` protocol buffer.
            <param name="runMetadata">
            May be NULL, in which case it will be ignored; or
            non-NULL, in which case it must point to an empty, freshly allocated
            `TF_Buffer` that may be updated to contain the serialized representation
            of a `RunMetadata` protocol buffer.
            </param>
            <param name="status">The status</param>
            <returns>On success, the tensors corresponding to outputs[0,noutputs-1] are placed in the returned Tensors.</returns>
        </member>
        <member name="T:Emgu.TF.SessionOptions">
            <summary>
            Tensorflow session options
            </summary>
        </member>
        <member name="M:Emgu.TF.SessionOptions.#ctor">
            <summary>
            Construct a new session options
            </summary>
        </member>
        <member name="M:Emgu.TF.SessionOptions.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this session options.
            </summary>
        </member>
        <member name="M:Emgu.TF.SessionOptions.SetTarget(System.String)">
            <summary>
            Set the target in TF_SessionOptions.options.
            </summary>
            <param name="target">
            target can be empty, a single entry, or a comma separated list of entries.
            Each entry is in one of the following formats :
            "local"
            ip:port
            host:port
            </param>
        </member>
        <member name="T:Emgu.TF.Status">
            <summary>
            The status
            </summary>
        </member>
        <member name="T:Emgu.TF.Status.Code">
            <summary>
            The status code
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.Ok">
            <summary>
            Ok
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.Cancelled">
            <summary>
            Canceled
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.InvalidArgument">
            <summary>
            Invalid argument
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.DeadlineExceeded">
            <summary>
            Deadline exceed
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.NotFound">
            <summary>
            Not found
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.AlreadyExists">
            <summary>
            Already exists
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.PermissionDenied">
            <summary>
            Permission denied
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.Unauthenticated">
            <summary>
            Unauthenticated
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.ResourceExhausted">
            <summary>
            Resource exhausted
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.FailedPrecondition">
            <summary>
            Failed precondition
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.Aborted">
            <summary>
            Aborted
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.OutOfRange">
            <summary>
            Out of range
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.Unimplemented">
            <summary>
            Unimplemented
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.Internal">
            <summary>
            Internal
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.Unavailable">
            <summary>
            Unavailable
            </summary>
        </member>
        <member name="F:Emgu.TF.Status.Code.DataLoss">
            <summary>
            Data loss
            </summary>
        </member>
        <member name="M:Emgu.TF.Status.#ctor">
            <summary>
            Create a new Status
            </summary>
        </member>
        <member name="P:Emgu.TF.Status.Message">
            <summary>
            Get the message from the status
            </summary>
        </member>
        <member name="P:Emgu.TF.Status.StatusCode">
            <summary>
            Get the status code
            </summary>
        </member>
        <member name="P:Emgu.TF.Status.Ptr">
            <summary>
            Get the pointer to the native status
            </summary>
        </member>
        <member name="M:Emgu.TF.Status.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this status
            </summary>
        </member>
        <member name="T:Emgu.TF.StatusChecker">
            <summary>
            A status checker, during the disposal, it will throw exception if the status is not ok.
            </summary>
        </member>
        <member name="M:Emgu.TF.StatusChecker.#ctor(Emgu.TF.Status)">
            <summary>
            Create a status checker
            </summary>
            <param name="status">The status to be check, if null, one will be created</param>
        </member>
        <member name="P:Emgu.TF.StatusChecker.Status">
            <summary>
            Get the status that this status checker is monitoring
            </summary>
        </member>
        <member name="M:Emgu.TF.StatusChecker.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this StatusChecker.
            </summary>
        </member>
        <member name="T:Emgu.TF.DataType">
            <summary>
            The tensor flow datatype.
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Float">
            <summary>
            Float
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Double">
            <summary>
            Double
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Int32">
            <summary>
            Int32 tensors are always in 'host' memory.
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Uint8">
            <summary>
            Uint8
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Int16">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Int8">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.String">
            <summary>
            String
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Complex64">
            <summary>
            Single-precision complex
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Complex">
            <summary>
            Old identifier kept for API backwards compatibility
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Int64">
            <summary>
            Int64
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Bool">
            <summary>
            Boolean
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Qint8">
            <summary>
            Quantized int8
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Quint8">
            <summary>
            Quantized uint8
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Qint32">
            <summary>
            Quantized int32
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Bfloat16">
            <summary>
            Float32 truncated to 16 bits.  Only for cast ops.
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Qint16">
            <summary>
            Quantized int16
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Quint16">
            <summary>
            Quantized uint16
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Uint16">
            <summary>
            Uint16
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Complex128">
            <summary>
            Double-precision complex
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Half">
            <summary>
            Half
            </summary>
        </member>
        <member name="F:Emgu.TF.DataType.Resource">
            <summary>
            Resource
            </summary>
        </member>
        <member name="T:Emgu.TF.Tensor">
             <summary>
             Tensor holds a multi-dimensional array of elements of a single data type.
             For all types other than STRING, the data buffer stores elements
             in row major order.  E.g. if data is treated as a vector of TF_DataType:
            
               element 0:   index (0, ..., 0)
               element 1:   index (0, ..., 1)
               ...
            
             The format for TF_STRING tensors is:
               start_offset: array[uint64]
               data:         byte[...]
            
               The string length (as a varint), followed by the contents of the string
               is encoded at data[start_offset[i]]]. StringEncode and StringDecode
               facilitate this encoding.
             </summary>
        </member>
        <member name="M:Emgu.TF.Tensor.#ctor(Emgu.TF.DataType,System.Int32)">
            <summary>
            Create a single element tensor
            </summary>
            <param name="dataType">The Type of the Tensor</param>
            <param name="sizeInBytes">The size in bytes</param>
        </member>
        <member name="M:Emgu.TF.Tensor.#ctor(Emgu.TF.DataType,System.Int32[])">
            <summary>
            Allocate a new tensor. The caller must set the Tensor values by writing them to the DataPointer
            with length ByteSize.
            </summary>
            <param name="dataType">The type of data</param>
            <param name="dims">The size for each of the dimension of the tensor</param>
        </member>
        <member name="M:Emgu.TF.Tensor.FromString(System.Byte[],Emgu.TF.Status)">
            <summary>
            Convert a byte array to a Tensor
            </summary>
            <param name="value">The byte array</param>
            <param name="status">Optional status</param>
            <returns>The tensor</returns>
        </member>
        <member name="M:Emgu.TF.Tensor.#ctor(System.Int32)">
            <summary>
            Create a Tensor that consist of a single int value
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.Tensor.#ctor(System.Single)">
            <summary>
            Create a Tensor that consist of a single float value
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.Tensor.#ctor(System.Int32[])">
            <summary>
            Create a Tensor that consist of an array of int value
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.Tensor.#ctor(System.Single[])">
            <summary>
            Create a Tensor that consist of an array of float value
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.Tensor.#ctor(System.UInt16[])">
            <summary>
            Create a Tensor that consist of an array of UInt16 value
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="M:Emgu.TF.Tensor.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this tensor
            </summary>
        </member>
        <member name="P:Emgu.TF.Tensor.DataPointer">
            <summary>
            Get the native pointer to the tensor data
            </summary>
        </member>
        <member name="P:Emgu.TF.Tensor.ByteSize">
            <summary>
            Return the size of the underlying data in bytes.
            </summary>
        </member>
        <member name="P:Emgu.TF.Tensor.Dim">
            <summary>
            Return the dimension of the tensor
            </summary>
        </member>
        <member name="P:Emgu.TF.Tensor.Data">
            <summary>
            Get the tensor data as a jagged array
            </summary>
        </member>
        <member name="M:Emgu.TF.Tensor.Flat``1">
            <summary>
            Get the tensor data as a flatten single dimension array
            </summary>
            <typeparam name="T">The type of the data array</typeparam>
            <returns>The tensor data as a flatten single dimension array</returns>
        </member>
        <member name="M:Emgu.TF.Tensor.GetData(System.Boolean)">
            <summary>
            Get a copy of the tensor data as a managed array
            </summary>
            <param name="jagged">If true, return a jagged array, otherwise, a flatten single dimension array</param>
            <returns>A copy of the tensor data as a managed array</returns>
        </member>
        <member name="P:Emgu.TF.Tensor.Type">
            <summary>
            Get the type of data from this tensor
            </summary>
        </member>
        <member name="T:Emgu.TF.Util.DisposableObject">
            <summary>
            An abstract class that wrap around a disposable object
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.DisposableObject._disposed">
            <summary> Track whether Dispose has been called. </summary>
        </member>
        <member name="M:Emgu.TF.Util.DisposableObject.Dispose">
            <summary>
            The dispose function that implements IDisposable interface
            </summary>
        </member>
        <member name="M:Emgu.TF.Util.DisposableObject.Dispose(System.Boolean)">
            <summary> 
             Dispose(bool disposing) executes in two distinct scenarios.
             If disposing equals true, the method has been called directly
             or indirectly by a user's code. Managed and unmanaged resources
             can be disposed.
             If disposing equals false, the method has been called by the
             runtime from inside the finalizer and you should not reference
             other objects. Only unmanaged resources can be disposed.
            </summary>
             <param name="disposing">
             If disposing equals false, the method has been called by the
             runtime from inside the finalizer and you should not reference
             other objects. Only unmanaged resources can be disposed.
             </param>
        </member>
        <member name="M:Emgu.TF.Util.DisposableObject.ReleaseManagedResources">
            <summary>
            Release the managed resources. This function will be called during the disposal of the current object.
            override ride this function if you need to call the Dispose() function on any managed IDisposable object created by the current object
            </summary>
        </member>
        <member name="M:Emgu.TF.Util.DisposableObject.DisposeObject">
            <summary>
            Release the unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.TF.Util.DisposableObject.Finalize">
            <summary>
            Destructor
            </summary>
        </member>
        <member name="T:Emgu.TF.Util.EventArgs`1">
            <summary>
            A generic EventArgs
            </summary>
            <typeparam name="T">The type of arguments</typeparam>
        </member>
        <member name="M:Emgu.TF.Util.EventArgs`1.#ctor(`0)">
            <summary>
            Create a generic EventArgs with the specific value
            </summary>
            <param name="value">The value</param>
        </member>
        <member name="P:Emgu.TF.Util.EventArgs`1.Value">
            <summary>
            The value of the EventArgs
            </summary>
        </member>
        <member name="T:Emgu.TF.Util.EventArgs`2">
            <summary>
            A generic EventArgs
            </summary>
            <typeparam name="T1">The type of the first value</typeparam>
            <typeparam name="T2">The type of the second value</typeparam>
        </member>
        <member name="M:Emgu.TF.Util.EventArgs`2.#ctor(`0,`1)">
            <summary>
            Create a generic EventArgs with two values
            </summary>
            <param name="value1">The first value</param>
            <param name="value2">The second value</param>
        </member>
        <member name="P:Emgu.TF.Util.EventArgs`2.Value1">
            <summary>
            The first value
            </summary>
        </member>
        <member name="P:Emgu.TF.Util.EventArgs`2.Value2">
            <summary>
            The second value
            </summary>
        </member>
        <member name="T:Emgu.TF.Util.ICodeGenerable">
            <summary>
            Implement this interface if the object can output code to generate it self.
            </summary>
        </member>
        <member name="M:Emgu.TF.Util.ICodeGenerable.ToCode(Emgu.TF.Util.TypeEnum.ProgrammingLanguage)">
            <summary>
            Return the code to generate the object itself from the specific language
            </summary>
            <param name="language">The programming language to output code</param>
            <returns>The code to generate the object from the specific language</returns>
        </member>
        <member name="T:Emgu.TF.Util.IInterpolatable`1">
            <summary>
            An object that can be interpolated
            </summary>
        </member>
        <member name="P:Emgu.TF.Util.IInterpolatable`1.InterpolationIndex">
            <summary>
            The index that will be used for interpolation
            </summary>
        </member>
        <member name="M:Emgu.TF.Util.IInterpolatable`1.LinearInterpolate(`0,System.Double)">
            <summary>
            Interpolate base on this point and the other point with the given index
            </summary>
            <param name="other">The other point</param>
            <param name="index">The interpolation index</param>
            <returns>The interpolated point</returns>
        </member>
        <member name="T:Emgu.TF.Util.PinnedArray`1">
            <summary>
            A Pinnned array of the specific type
            </summary>
            <typeparam name="T">The type of the array</typeparam>
        </member>
        <member name="M:Emgu.TF.Util.PinnedArray`1.#ctor(System.Int32)">
            <summary>
            Create a Pinnned array of the specific type
            </summary>
            <param name="size">The size of the array</param>
        </member>
        <member name="M:Emgu.TF.Util.PinnedArray`1.AddrOfPinnedObject">
            <summary>
            Get the address of the pinned array
            </summary>
            <returns>A pointer to the address of the the pinned array</returns>
        </member>
        <member name="P:Emgu.TF.Util.PinnedArray`1.Array">
            <summary>
            Get the array
            </summary>
        </member>
        <member name="M:Emgu.TF.Util.PinnedArray`1.ReleaseManagedResources">
            <summary>
            Release the GCHandle
            </summary>
        </member>
        <member name="M:Emgu.TF.Util.PinnedArray`1.DisposeObject">
            <summary>
            Disposed the unmanaged data
            </summary>
        </member>
        <member name="T:Emgu.TF.Util.Platform">
            <summary>
            Provide information for the platform which is using. 
            </summary>
        </member>
        <member name="P:Emgu.TF.Util.Platform.OperationSystem">
            <summary>
            Get the type of the current operating system
            </summary>
        </member>
        <member name="P:Emgu.TF.Util.Platform.ClrType">
            <summary>
            Get the type of the current runtime environment
            </summary>
        </member>
        <member name="T:Emgu.TF.Util.Toolbox">
            <summary>
            utilities functions for Emgu
            </summary>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.SizeOf``1">
            <summary>
            Similar to Marshal.SizeOf function
            </summary>
            <typeparam name="T">The type</typeparam>
            <returns>The size of T in bytes</returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.MergeBytes(System.Byte[],System.Byte[])">
            <summary>
            Merges two byte vector into one
            </summary>
            <param name="a">the first byte vector to be merged</param>
            <param name="b">the second byte vector to be merged</param>
            <returns>The bytes that is a concatenation of a and b</returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.ExecuteCmd(System.String,System.String)">
            <summary>
            Call a command from command line
            </summary>
            <param name="execFileName">The name of the executable</param>
            <param name="arguments">The arguments to the executable</param>
            <returns>The standard output</returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.GetBaseType(System.Type,System.String)">
            <summary>
            Use reflection to find the base type. If such type do not exist, null is returned
            </summary>
            <param name="currentType">The type to search from</param>
            <param name="baseClassName">The name of the base class to search</param>
            <returns>The base type</returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.ToBytes``1(``0[])">
            <summary>
            Convert some generic vector to vector of Bytes
            </summary>
            <typeparam name="TData">type of the input vector</typeparam>
            <param name="data">array of data</param>
            <returns>the byte vector</returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.LinearInterpolate``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Perform first degree interpolation give the sorted data <paramref name="src"/> and the interpolation <paramref name="indexes"/>
            </summary>
            <param name="src">The sorted data that will be interpolated from</param>
            <param name="indexes">The indexes of the interpolate result</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.LinearSubsample``1(System.Collections.Generic.IEnumerable{``0},System.Double)">
            <summary>
            Get subsamples with the specific rate
            </summary>
            <param name="src">The source which the subsamples will be derived from</param>
            <param name="subsampleRate">The subsample rate</param>
            <returns><paramref name="src"/> subsampled with the specific rate </returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.JoinInterpolatables``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Joining multiple index ascending IInterpolatables together as a single index ascending IInterpolatable. 
            </summary>
            <typeparam name="T">The type of objects that will be joined</typeparam>
            <param name="enums">The enumerables, each should be stored in index ascending order</param>
            <returns>A single enumerable sorted in index ascending order</returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.LoadLibrary(System.String)">
            <summary>
            Maps the specified executable module into the address space of the calling process.
            </summary>
            <param name="dllname">The name of the dll</param>
            <returns>The handle to the library</returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.FreeLibrary(System.IntPtr)">
            <summary>
            Decrements the reference count of the loaded dynamic-link library (DLL). When the reference count reaches zero, the module is unmapped from the address space of the calling process and the handle is no longer valid
            </summary>
            <param name="handle">The handle to the library</param>
            <returns>If the function succeeds, the return value is true. If the function fails, the return value is false.</returns>
        </member>
        <member name="M:Emgu.TF.Util.Toolbox.SetDllDirectory(System.String)">
            <summary>
            Adds a directory to the search path used to locate DLLs for the application
            </summary>
            <param name="path">The directory to be searched for DLLs</param>
            <returns>True if success</returns>
        </member>
        <member name="T:Emgu.TF.Util.TypeEnum.OS">
            <summary>
            Type of operating system
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.OS.Windows">
            <summary>
            Windows
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.OS.Linux">
            <summary>
            Linux
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.OS.MacOSX">
            <summary>
            Mac OSX
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.OS.IOS">
            <summary>
            iOS devices. iPhone, iPad, iPod Touch
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.OS.Android">
            <summary>
            Android devices
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.OS.WindowsPhone">
            <summary>
            The windows phone
            </summary>
        </member>
        <member name="T:Emgu.TF.Util.TypeEnum.ClrType">
            <summary>
            The runtime environment
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.ClrType.DotNet">
            <summary>
            .Net runtime
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.ClrType.NetFxCore">
            <summary>
            Windows Store app runtime
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.ClrType.Mono">
            <summary>
            Mono runtime
            </summary>
        </member>
        <member name="T:Emgu.TF.Util.TypeEnum.ProgrammingLanguage">
            <summary>
            The type of Programming languages
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.ProgrammingLanguage.CSharp">
            <summary>
            C#
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.TypeEnum.ProgrammingLanguage.CPlusPlus">
            <summary>
            C++
            </summary>
        </member>
        <member name="T:Emgu.TF.Util.UnmanagedObject">
            <summary>
            An Unmanaged Object is a disposable object with a Ptr property pointing to the unmanaged object
            </summary>
        </member>
        <member name="F:Emgu.TF.Util.UnmanagedObject._ptr">
            <summary>
            A pointer to the unmanaged object
            </summary>
        </member>
        <member name="P:Emgu.TF.Util.UnmanagedObject.Ptr">
            <summary>
            Pointer to the unmanaged object
            </summary>
        </member>
        <member name="M:Emgu.TF.Util.UnmanagedObject.op_Implicit(Emgu.TF.Util.UnmanagedObject)~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="obj">The UnmanagedObject</param>
            <returns>The unmanaged pointer for this object</returns>
        </member>
    </members>
</doc>
